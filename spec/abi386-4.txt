SYSTEM V
APPLICATION
BINARY INTERFACE
Intel386 Architecture
Processor Supplement

Fourth Edition

Copyright  1990−1996 The Santa Cruz Operation, Inc. All rights reserved.
Copyright  1990−1992 AT&T. All rights reserved.
No part of this publication may be reproduced, transmitted, stored in a retrieval system, nor translated
into any human or computer language, in any form or by any means, electronic, mechanical, magnetic,
optical, chemical, manual, or otherwise, without the prior written permission of the copyright owner,
The Santa Cruz Operation, Inc., 400 Encinal Street, Santa Cruz, California, 95060, USA. Copyright
infringement is a serious matter under the United States and foreign Copyright Laws.
Information in this document is subject to change without notice and does not represent a commitment
on the part of The Santa Cruz Operation, Inc.
SCO UnixWare is commercial computer software and, together with any related documentation, is
subject to the restrictions on US Government use as set forth below. If this procurement is for a DOD
agency, the following DFAR Restricted Rights Legend applies:
RESTRICTED RIGHTS LEGEND: Use, duplication, or disclosure by the Government is subject to
restrictions as set forth in subparagraph (c)(1)(ii) of Rights in Technical Data and Computer Software
Clause at DFARS 252.227-7013. Contractor/Manufacturer is The Santa Cruz Operation, Inc., 400 Encinal
Street, Santa Cruz, CA 95060.

If this procurement is for a civilian government agency, this FAR Restricted Rights Legend applies:
RESTRICTED RIGHTS LEGEND: This computer software is submitted with restricted rights under
Government Contract No. _________ (and Subcontract No. ________, if appropriate). It may not be
used, reproduced, or disclosed by the Government except as provided in paragraph (g)(3)(i) of FAR
Clause 52.227-14 alt III or as otherwise expressly stated in the contract. Contractor/Manufacturer is
The Santa Cruz Operation, Inc., 400 Encinal Street, Santa Cruz, CA 95060.

If any copyrighted software accompanies this publication, it is licensed to the End User only for use in
strict accordance with the End User License Agreement, which should be read carefully before
commencing use of the software.
ACKNOWLEDGEMENTS
"We acknowledge the contributions of the 88OPEN Consortium Ltd., portions of whose System V ABI
Implementation Guide for the M88000 Processor and the System V ABI M88000 Processor Networking
Supplement have been incorporated in this section of the ABI with permission."
TRADEMARKS
SCO, the SCO logo, The Santa Cruz Operation, and UnixWare are trademarks or registered trademarks
of The Santa Cruz Operation, Inc. in the USA and other countries. Intel386, Intel486, and Pentium are
trademarks of Intel Corporation. UNIX is a registered trademark in the USA and other countries,
licensed exclusively through X/Open Company Limited. Motif is a trademark of the Open Software
Foundation, Inc. NeWS is a registered trademark of Sun Microsystems, Inc. X11 and X Window System
are trademarks of Massachusetts Institute of Technology. All other brand and product names are or
may be trademarks of, and are used to identify products or services of, their respective owners.

DRAFT COPY
March 19, 1997
File: abi_386/copyright (Delta 44.3)
386:adm.book:sum
Page: 2

Contents

Table of Contents
Table of Contents
INTRODUCTION
SOFTWARE INSTALLATION
LOW-LEVEL SYSTEM INFORMATION
OBJECT FILES
PROGRAM LOADING AND DYNAMIC LINKING
LIBRARIES
DEVELOPMENT ENVIRONMENT
EXECUTION ENVIRONMENT
Index

1

INTRODUCTION

2

SOFTWARE INSTALLATION

3

LOW-LEVEL SYSTEM INFORMATION

The Intel386 Architecture and the System V ABI
How to Use the Intel386 Architecture ABI Supplement

Software Distribution Formats

Machine Interface
Function Calling Sequence
Operating System Interface
Coding Examples

Table of Contents

1-1
1-2

2-1

3-1
3-9
3-20
3-34

i

DRAFT COPY
March 19, 1997
File: abi_386/MasterToc (Delta 44.6)
386:adm.book:sum
Page: 3

4

OBJECT FILES

5

PROGRAM LOADING AND DYNAMIC
LINKING

ELF Header
Sections
Symbol Table
Relocation

4-1
4-2
4-3
4-4

Program Loading
Dynamic Linking

5-1
5-5

6

LIBRARIES

7

DEVELOPMENT ENVIRONMENT

8

EXECUTION ENVIRONMENT

IN

Index

Shared Library Names
C Library
System Data Interfaces

6-1
6-2
6-5

Development Commands
Software Packaging Tools

Application Environment

Index

7-1
7-2

8-1

IN-1

ii

Table of Contents

DRAFT COPY
March 19, 1997
File: abi_386/MasterToc (Delta 44.6)
386:adm.book:sum
Page: 4

Figures and Tables

Figure 3-1: Scalar Types
Figure 3-2: Structure Smaller Than a Word
Figure 3-3: No Padding
Figure 3-4: Internal Padding
Figure 3-5: Internal and Tail Padding
Figure 3-6: union Allocation
Figure 3-7: Bit-Field Ranges
Figure 3-8: Bit Numbering
Figure 3-9: Right-to-Left Allocation
Figure 3-10: Boundary Alignment
Figure 3-11: Storage Unit Sharing
Figure 3-12: union Allocation
Figure 3-13: Unnamed Bit-Fields
Figure 3-14: Processor Registers
Figure 3-15: Standard Stack Frame
Figure 3-16: Function Prologue
Figure 3-17: Function Epilogue
Figure 3-18: Stack Contents for Functions Returning struct/union
Figure 3-19: Function Prologue (Returning struct/union)
Figure 3-20: Function Epilogue
Figure 3-21: Integral and Pointer Arguments
Figure 3-22: Floating-Point Arguments
Figure 3-23: Structure and Union Arguments
Figure 3-24: Virtual Address Configuration
Figure 3-25: Conventional Segment Arrangements
Figure 3-26: _exit System Trap
Figure 3-27: Hardware Exceptions and Signals
Figure 3-28: Declaration for main
Figure 3-29: EFLAGS Register Fields
Figure 3-30: Floating-Point Control Word
Figure 3-31: Initial Process Stack
Figure 3-32: Auxiliary Vector
Figure 3-33: Auxiliary Vector Types, a_type
Figure 3-34: AT_FPHW values
Figure 3-35: Example Process Stack

Table of Contents

3-2
3-4
3-4
3-4
3-5
3-5
3-6
3-7
3-7
3-7
3-8
3-8
3-8
3-9
3-10
3-13
3-14
3-15
3-16
3-16
3-17
3-18
3-18
3-20
3-22
3-24
3-25
3-26
3-27
3-27
3-28
3-30
3-30
3-32
3-33

iii

DRAFT COPY
March 19, 1997
File: abi_386/MasterToc (Delta 44.6)
386:adm.book:sum
Page: 5

Figure 3-36: Calculating Global Offset Table Address
Figure 3-37: Position-Independent Function Prologue
Figure 3-38: Absolute Data Access
Figure 3-39: Position-Independent Data Access
Figure 3-40: Position-Independent Static Data Access
Figure 3-41: Absolute Direct Function Call
Figure 3-42: Position-Independent Direct Function Call
Figure 3-43: Absolute Indirect Function Call
Figure 3-44: Position-Independent Indirect Function Call
Figure 3-45: Branch Instruction, All Models
Figure 3-46: Absolute switch Code
Figure 3-47: Position-Independent switch Code
Figure 3-48: C Stack Frame
Figure 3-49: Dynamic Stack Allocation
Figure 4-1: Intel386 Identification, e_ident
Figure 4-2: Special Sections
Figure 4-3: Relocatable Fields
Figure 4-4: Relocation Types
Figure 5-1: Executable File
Figure 5-2: Program Header Segments
Figure 5-3: Process Image Segments
Figure 5-4: Example Shared Object Segment Addresses
Figure 5-5: Global Offset Table
Figure 5-6: Absolute Procedure Linkage Table
Figure 5-7: Position-Independent Procedure Linkage Table
Figure 6-1: Shared Library Names
Figure 6-2: libc Additional Required Entry Points
Figure 6-3: libc, Support Routines
Figure 6-4: libc, Global External Data Symbols
Figure 6-5: <aio.h> *
Figure 6-6: <assert.h>
Figure 6-7: <ctype.h>
Figure 6-8: <dirent.h>
Figure 6-9: <dlfcn.h> *
Figure 6-10: <elf.h> *, Part 1 of 6
Figure 6-11: <elf.h> *, Part 2 of 6
Figure 6-12: <elf.h> *, Part 3 of 6
Figure 6-13: <elf.h> *, Part 4 of 6
Figure 6-14: <elf.h> *, Part 5 of 6
Figure 6-15: <elf.h> *, Part 6 of 6
Figure 6-16: <errno.h>, Part 1 of 3
Figure 6-17: <errno.h>, Part 2 of 3
Figure 6-18: <errno.h>, Part 3 of 3
Figure 6-19: <fcntl.h>, Part 1 of 2
Figure 6-20: <fcntl.h>, Part 2 of 2

iv

3-36
3-37
3-37
3-38
3-39
3-39
3-40
3-40
3-40
3-41
3-41
3-42
3-43
3-45
4-1
4-2
4-4
4-5
5-1
5-2
5-3
5-4
5-6
5-8
5-8
6-1
6-2
6-3
6-4
6-6
6-6
6-7
6-8
6-8
6-9
6-10
6-11
6-12
6-13
6-14
6-15
6-16
6-17
6-18
6-19

Table of Contents

DRAFT COPY
March 19, 1997
File: abi_386/MasterToc (Delta 44.6)
386:adm.book:sum
Page: 6

Figure 6-21: <float.h>, Single-Precision
Figure 6-22: <float.h>, Double-Precision
Figure 6-23: <float.h>, Extended-Precision
Figure 6-24: <fmtmsg.h>, Part 1 of 2
Figure 6-25: <fmtmsg.h>, Part 2 of 2
Figure 6-26: <fnmatch.h> *
Figure 6-27: <ftw.h>
Figure 6-28: <glob.h> *
Figure 6-29: <grp.h>
Figure 6-30: <iconv.h> *
Figure 6-31: <sys/ipc.h>
Figure 6-32: <langinfo.h>, Part 1 of 2
Figure 6-33: <langinfo.h>, Part 2 of 2
Figure 6-34: <limits.h>, Part 1 of 2
Figure 6-35: <limits.h>, Part 2 of 2
Figure 6-36: <locale.h>
Figure 6-37: <lwpsynch.h> *
Figure 6-38: <machlock.h> *
Figure 6-39: <math.h>
Figure 6-40: <sys/mman.h>
Figure 6-41: <sys/mod.h> *
Figure 6-42: <sys/mount.h>
Figure 6-43: <sys/msg.h>
Figure 6-44: <netconfig.h>, Part 1 of 2
Figure 6-45: <netconfig.h>, Part 2 of 2
Figure 6-46: <netdir.h>, Part 1 of 2
Figure 6-47: <netdir.h>, Part 2 of 2
Figure 6-48: <nl_types.h>
Figure 6-49: <sys/param.h>
Figure 6-50: <poll.h>
Figure 6-51: <sys/priocntl.h> *
Figure 6-52: <sys/procset.h>
Figure 6-53: <pwd.h>
Figure 6-54: <regex.h> *, Part 1 of 2
Figure 6-55: <regex.h> *, Part 2 of 2
Figure 6-56: <sys/resource.h>
Figure 6-57: <rpc.h>, Part 1 of 16
Figure 6-58: <rpc.h>, Part 2 of 16
Figure 6-59: <rpc.h>, Part 3 of 16
Figure 6-60: <rpc.h>, Part 4 of 16
Figure 6-61: <rpc.h>, Part 5 of 16
Figure 6-62: <rpc.h>, Part 6 of 16
Figure 6-63: <rpc.h>, Part 7 of 16
Figure 6-64: <rpc.h>, Part 8 of 16
Figure 6-65: <rpc.h>, Part 9 of 16

Table of Contents

6-20
6-20
6-21
6-21
6-22
6-22
6-23
6-24
6-25
6-25
6-26
6-27
6-28
6-29
6-30
6-31
6-32
6-32
6-32
6-33
6-34
6-35
6-36
6-37
6-38
6-39
6-40
6-40
6-41
6-42
6-43
6-44
6-45
6-46
6-47
6-48
6-49
6-50
6-51
6-52
6-53
6-54
6-55
6-56
6-57

v

DRAFT COPY
March 19, 1997
File: abi_386/MasterToc (Delta 44.6)
386:adm.book:sum
Page: 7

Figure 6-66: <rpc.h>, Part 10 of 16
Figure 6-67: <rpc.h>, Part 11 of 16
Figure 6-68: <rpc.h>, Part 12 of 16
Figure 6-69: <rpc.h>, Part 13 of 16
Figure 6-70: <rpc.h>, Part 14 of 16
Figure 6-71: <rpc.h>, Part 15 of 16
Figure 6-72: <rpc.h>, Part 16 of 16
Figure 6-73: <rtpriocntl.h> *
Figure 6-74: <search.h>
Figure 6-75: <sys/sem.h>
Figure 6-76: <setjmp.h>
Figure 6-77: <sys/shm.h>
Figure 6-78: <signal.h>, Part 1 of 3
Figure 6-79: <signal.h>, Part 2 of 3
Figure 6-80: <signal.h>, Part 3 of 3
Figure 6-81: <sys/siginfo.h>, Part 1 of 5
Figure 6-82: <sys/siginfo.h>, Part 2 of 5
Figure 6-83: <sys/siginfo.h>, Part 3 of 5
Figure 6-84: <sys/siginfo.h>, Part 4 of 5
Figure 6-85: <sys/siginfo.h> *, Part 5 of 5
Figure 6-86: <sys/stat.h>, Part 1 of 2
Figure 6-87: <sys/stat.h>, Part 2 of 2
Figure 6-88: <sys/statvfs.h>
Figure 6-89: <stdarg.h>
Figure 6-90: <stddef.h>
Figure 6-91: <stdio.h>, Part 1 of 2
Figure 6-92: <stdio.h>, Part 2 of 2
Figure 6-93: <stdlib.h>
Figure 6-94: <stropts.h>, Part 1 of 6
Figure 6-95: <stropts.h>, Part 2 of 6
Figure 6-96: <stropts.h>, Part 3 of 6
Figure 6-97: <stropts.h>, Part 4 of 6
Figure 6-98: <stropts.h>, Part 5 of 6
Figure 6-99: <stropts.h>, Part 6 of 6
Figure 6-100: <synch.h> *, Part 1 of 3
Figure 6-101: <synch.h> *, Part 2 of 3
Figure 6-102: <synch.h> *, Part 3 of 3
Figure 6-103: <sys/sysi86.h>
Figure 6-104: <termios.h>, Part 1 of 10
Figure 6-105: <termios.h>, Part 2 of 10
Figure 6-106: <termios.h>, Part 3 of 10
Figure 6-107: <termios.h>, Part 4 of 10
Figure 6-108: <termios.h>, Part 5 of 10
Figure 6-109: <termios.h>, Part 6 of 10
Figure 6-110: <termios.h>, Part 7 of 10

vi

6-58
6-59
6-60
6-60
6-61
6-62
6-63
6-63
6-64
6-65
6-66
6-66
6-67
6-68
6-69
6-69
6-70
6-71
6-72
6-72
6-73
6-74
6-75
6-76
6-76
6-77
6-78
6-79
6-80
6-81
6-82
6-83
6-84
6-85
6-86
6-87
6-88
6-88
6-89
6-90
6-91
6-92
6-93
6-94
6-95

Table of Contents

DRAFT COPY
March 19, 1997
File: abi_386/MasterToc (Delta 44.6)
386:adm.book:sum
Page: 8

Figure 6-111: <termios.h>, Part 8 of 10
Figure 6-112: <termios.h>, Part 9 of 10
Figure 6-113: <termios.h>, Part 10 of 10
Figure 6-114: <thread.h> *, Part 1 of 2
Figure 6-115: <thread.h> *, Part 2 of 2
Figure 6-116: <sys/ticlts.h>
Figure 6-117: <sys/ticots.h>
Figure 6-118: <sys/ticotsord.h>
Figure 6-119: <time.h> *
Figure 6-120: <sys/time.h>
Figure 6-121: <sys/times.h>
Figure 6-122: <tiuser.h>, Error Return Values
Figure 6-123: <tiuser.h>, Event Bitmasks
Figure 6-124: <tiuser.h>, Flags
Figure 6-125: <tiuser.h>, Service Types
Figure 6-126: <tiuser.h>, Values for flags field in t_info structure
Figure 6-127: <tiuser.h>, Transport Interface Data Structures, 1 of 2
Figure 6-128: <tiuser.h>, Transport Interface Data Structures, 2 of 2
Figure 6-129: <tiuser.h>, Structure Types
Figure 6-130: <tiuser.h>, Fields of Structures
Figure 6-131: <tiuser.h>, Transport Interface States
Figure 6-132: <tiuser.h>, User-level Events
Figure 6-133: <tspriocntl.h> *
Figure 6-134: <sys/types.h>
Figure 6-135: <ucontext.h>, Part 1 of 2
Figure 6-136: <ucontext.h>, Part 2 of 2
Figure 6-137: <sys/uio.h>
Figure 6-138: <ulimit.h>
Figure 6-139: <unistd.h>, Part 1 of 2
Figure 6-140: <unistd.h>, Part 2 of 2
Figure 6-141: <utime.h>
Figure 6-142: <sys/utsname.h>
Figure 6-143: <wait.h>
Figure 6-144: <wchar.h>
Figure 6-145: <wctype.h> *, Part 1 of 3
Figure 6-146: <wctype.h> *, Part 2 of 3
Figure 6-147: <wctype.h> *, Part 3 of 3
Figure 6-148: <wordexp.h> *
Figure 6-149: <X11/Atom.h>, Part 1 of 3
Figure 6-150: <X11/Atom.h>, Part 2 of 3
Figure 6-151: <X11/Atom.h>, Part 3 of 3
Figure 6-152: <X11/Composite.h>
Figure 6-153: <X11/Constraint.h>
Figure 6-154: <X11/Core.h>
Figure 6-155: <X11/cursorfont.h>, Part 1 of 3

Table of Contents

6-96
6-97
6-98
6-99
6-100
6-100
6-101
6-101
6-102
6-103
6-104
6-105
6-106
6-106
6-107
6-107
6-108
6-109
6-110
6-110
6-111
6-112
6-113
6-114
6-115
6-116
6-117
6-117
6-117
6-119
6-119
6-120
6-121
6-122
6-123
6-124
6-125
6-126
6-128
6-129
6-130
6-131
6-131
6-131
6-132

vii

DRAFT COPY
March 19, 1997
File: abi_386/MasterToc (Delta 44.6)
386:adm.book:sum
Page: 9

Figure 6-156: <X11/cursorfont.h>, Part 2 of 3
Figure 6-157: <X11/cursorfont.h>, Part 3 of 3
Figure 6-158: <X11/Intrinsic.h>, Part 1 of 6
Figure 6-159: <X11/Intrinsic.h>, Part 2 of 6
Figure 6-160: <X11/Intrinsic.h>, Part 3 of 6
Figure 6-161: <X11/Intrinsic.h>, Part 4 of 6
Figure 6-162: <X11/Intrinsic.h>, Part 5 of 6
Figure 6-163: <X11/Intrinsic.h>, Part 6 of 6
Figure 6-164: <X11/Object.h>
Figure 6-165: <X11/RectObj.h>
Figure 6-166: <X11/extensions/shape.h>*
Figure 6-167: <X11/Shell.h>
Figure 6-168: <X11/Vendor.h>
Figure 6-169: <X11/X.h>, Part 1 of 12
Figure 6-170: <X11/X.h>, Part 2 of 12
Figure 6-171: <X11/X.h>, Part 3 of 12
Figure 6-172: <X11/X.h>, Part 4 of 12
Figure 6-173: <X11/X.h>, Part 5 of 12
Figure 6-174: <X11/X.h>, Part 6 of 12
Figure 6-175: <X11/X.h>, Part 7 of 12
Figure 6-176: <X11/X.h>, Part 8 of 12
Figure 6-177: <X11/X.h>, Part 9 of 12
Figure 6-178: <X11/X.h>, Part 10 of 12
Figure 6-179: <X11/X.h>, Part 11 of 12
Figure 6-180: <X11/X.h>, Part 12 of 12
Figure 6-181: <X11/Xcms.h>, Part 1 of 5
Figure 6-182: <X11/Xcms.h>, Part 2 of 5
Figure 6-183: <X11/Xcms.h>, Part 3 of 5
Figure 6-184: <X11/Xcms.h>, Part 4 of 5
Figure 6-185: <X11/Xcms.h>, Part 5 of 5
Figure 6-186: <X11/Xlib.h>, Part 1 of 27
Figure 6-187: <X11/Xlib.h>, Part 2 of 27
Figure 6-188: <X11/Xlib.h>, Part 3 of 27
Figure 6-189: <X11/Xlib.h>, Part 4 of 27
Figure 6-190: <X11/Xlib.h>, Part 5 of 27
Figure 6-191: <X11/Xlib.h>, Part 6 of 27
Figure 6-192: <X11/Xlib.h>, Part 7 of 27
Figure 6-193: <X11/Xlib.h>, Part 8 of 27
Figure 6-194: <X11/Xlib.h>, Part 9 of 27
Figure 6-195: <X11/Xlib.h>, Part 10 of 27
Figure 6-196: <X11/Xlib.h>, Part 11 of 27
Figure 6-197: <X11/Xlib.h>, Part 12 of 27
Figure 6-198: <X11/Xlib.h>, Part 13 of 27
Figure 6-199: <X11/Xlib.h>, Part 14 of 27
Figure 6-200: <X11/Xlib.h>, Part 15 of 27

viii

6-133
6-134
6-135
6-136
6-137
6-138
6-139
6-140
6-140
6-140
6-141
6-141
6-141
6-142
6-143
6-144
6-145
6-146
6-147
6-148
6-149
6-150
6-151
6-152
6-153
6-154
6-155
6-156
6-157
6-158
6-159
6-159
6-160
6-161
6-162
6-163
6-164
6-165
6-166
6-167
6-168
6-169
6-170
6-171
6-172

Table of Contents

DRAFT COPY
March 19, 1997
File: abi_386/MasterToc (Delta 44.6)
386:adm.book:sum
Page: 10

Figure 6-201: <X11/Xlib.h>, Part 16 of 27
Figure 6-202: <X11/Xlib.h>, Part 17 of 27
Figure 6-203: <X11/Xlib.h>, Part 18 of 27
Figure 6-204: <X11/Xlib.h>, Part 19 of 27
Figure 6-205: <X11/Xlib.h>, Part 20 of 27
Figure 6-206: <X11/Xlib.h>, Part 21 of 27
Figure 6-207: <X11/Xlib.h>, Part 22 of 27
Figure 6-208: <X11/Xlib.h>, Part 23 of 27
Figure 6-209: <X11/Xlib.h>, Part 24 of 27
Figure 6-210: <X11/Xlib.h>, Part 25 of 27
Figure 6-211: <X11/Xlib.h>, Part 26 of 27
Figure 6-212: <X11/Xlib.h>, Part 27 of 27
Figure 6-213: <X11/Xresource.h>, Part 1 of 2
Figure 6-214: <X11/Xresource.h>, Part 2 of 2
Figure 6-215: <X11/Xutil.h>, Part 1 of 5
Figure 6-216: <X11/Xutil.h>, Part 2 of 5
Figure 6-217: <X11/Xutil.h>, Part 3 of 5
Figure 6-218: <X11/Xutil.h>, Part 4 of 5
Figure 6-219: <X11/Xutil.h>, Part 5 of 5
Figure 6-220: <Xm/ArrowB.h>*
Figure 6-221: <Xm/ArrowBG.h>*
Figure 6-222: <Xm/BulletinB.h>*
Figure 6-223: <Xm/CascadeB.h>*
Figure 6-224: <Xm/CascadeBG.h>*
Figure 6-225: <Xm/Command.h>*
Figure 6-226: <Xm/CutPaste.h>*
Figure 6-227: <Xm/DialogS.h>*
Figure 6-228: <Xm/Display.h>*
Figure 6-229: <Xm/DragC.h>*, Part 1 of 4
Figure 6-230: <Xm/DragC.h>*, Part 2 of 4
Figure 6-231: <Xm/DragC.h>*, Part 3 of 4
Figure 6-232: <Xm/DragC.h>*, Part 4 of 4
Figure 6-233: <Xm/DragIcon.h>*
Figure 6-234: <Xm/DragOverS.h>*
Figure 6-235: <Xm/DrawingA.h>*
Figure 6-236: <Xm/DrawnB.h>*
Figure 6-237: <Xm/DropSMgr.h>*, Part 1 of 2
Figure 6-238: <Xm/DropSMgr.h>*, Part 2 of 2
Figure 6-239: <Xm/DropTrans.h>*
Figure 6-240: <Xm/FileSB.h>*
Figure 6-241: <Xm/Form.h>*
Figure 6-242: <Xm/Frame.h>*
Figure 6-243: <Xm/Label.h>*
Figure 6-244: <Xm/LabelG.h>*
Figure 6-245: <Xm/List.h>*

Table of Contents

6-173
6-174
6-175
6-176
6-177
6-178
6-179
6-180
6-181
6-182
6-183
6-184
6-185
6-186
6-187
6-188
6-189
6-190
6-191
6-193
6-193
6-193
6-193
6-194
6-194
6-195
6-195
6-196
6-197
6-198
6-199
6-200
6-201
6-201
6-202
6-202
6-203
6-204
6-205
6-205
6-205
6-206
6-206
6-206
6-207

ix

DRAFT COPY
March 19, 1997
File: abi_386/MasterToc (Delta 44.6)
386:adm.book:sum
Page: 11

Figure 6-246: <Xm/MainW.h>*
Figure 6-247: <Xm/MenuShell.h>*
Figure 6-248: <Xm/MessageB.h>*
Figure 6-249: <Mrm/MrmPublic.h>*, Part 1 of 3
Figure 6-250: <Mrm/MrmPublic.h>*, Part 2 of 3
Figure 6-251: <Mrm/MrmPublic.h>*, Part 3 of 3
Figure 6-252: <Xm/MwmUtil.h>*, Part 1 of 3
Figure 6-253: <Xm/MwmUtil.h>*, Part 2 of 3
Figure 6-254: <Xm/MwmUtil.h>*, Part 3 of 3
Figure 6-255: <Xm/PanedW.h>*
Figure 6-256: <Xm/PushB.h>*
Figure 6-257: <Xm/PushBG.h>*
Figure 6-258: <Xm/RepType.h>*
Figure 6-259: <Xm/RowColumn.h>*
Figure 6-260: <Xm/Scale.h>*
Figure 6-261: <Xm/Screen.h>*
Figure 6-262: <Xm/ScrollBar.h>*
Figure 6-263: <Xm/ScrolledW.h>*
Figure 6-264: <Xm/SelectioB.h>*
Figure 6-265: <Xm/SeparatoG.h>*
Figure 6-266: <Xm/Separator.h>*
Figure 6-267: <Xm/Text.h>*
Figure 6-268: <Xm/TextF.h>*
Figure 6-269: <Xm/ToggleB.h>*
Figure 6-270: <Xm/ToggleBG.h>*
Figure 6-271: <Xm/VendorS.h>*
Figure 6-272: <Xm/VirtKeys.h>*, Part 1 of 2
Figure 6-273: <Xm/VirtKeys.h>*, Part 2 of 2
Figure 6-274: <Xm/Xm.h>*, Part 1 of 14
Figure 6-275: <Xm/Xm.h>*, Part 2 of 14
Figure 6-276: <Xm/Xm.h>*, Part 3 of 14
Figure 6-277: <Xm/Xm.h>*, Part 4 of 14
Figure 6-278: <Xm/Xm.h>*, Part 5 of 15
Figure 6-279: <Xm/Xm.h>*, Part 6 of 14
Figure 6-280: <Xm/Xm.h>*, Part 7 of 14
Figure 6-281: <Xm/Xm.h>*, Part 8 of 14
Figure 6-282: <Xm/Xm.h>*, Part 9 of 14
Figure 6-283: <Xm/Xm.h>*, Part 10 of 14
Figure 6-284: <Xm/Xm.h>*, Part 11 of 14
Figure 6-285: <Xm/Xm.h>*, Part 12 of 14
Figure 6-286: <Xm/Xm.h>*, Part 13 of 14
Figure 6-287: <Xm/Xm.h>*, Part 14 of 14
Figure 6-288: <Xm/XmStrDefs.h>*, Part 1 of 34
Figure 6-289: <Xm/XmStrDefs.h>*, Part 2 of 34
Figure 6-290: <Xm/XmStrDefs.h>*, Part 3 of 34

x

6-207
6-207
6-208
6-209
6-210
6-211
6-212
6-213
6-214
6-214
6-215
6-215
6-215
6-216
6-216
6-216
6-216
6-217
6-217
6-217
6-217
6-218
6-218
6-218
6-218
6-219
6-219
6-220
6-221
6-222
6-223
6-224
6-225
6-226
6-227
6-228
6-229
6-230
6-231
6-232
6-233
6-234
6-235
6-236
6-237

Table of Contents

DRAFT COPY
March 19, 1997
File: abi_386/MasterToc (Delta 44.6)
386:adm.book:sum
Page: 12

Figure 6-291: <Xm/XmStrDefs.h>*, Part 4 of 34
Figure 6-292: <Xm/XmStrDefs.h>*, Part 5 of 34
Figure 6-293: <Xm/XmStrDefs.h>*, Part 6 of 34
Figure 6-294: <Xm/XmStrDefs.h>*, Part 7 of 34
Figure 6-295: <Xm/XmStrDefs.h>*, Part 8 of 34
Figure 6-296: <Xm/XmStrDefs.h>*, Part 9 of 34
Figure 6-297: <Xm/XmStrDefs.h>*, Part 10 of 34
Figure 6-298: <Xm/XmStrDefs.h>*, Part 11 of 34
Figure 6-299: <Xm/XmStrDefs.h>*, Part 12 of 34
Figure 6-300: <Xm/XmStrDefs.h>*, Part 13 of 34
Figure 6-301: <Xm/XmStrDefs.h>*, Part 14 of 34
Figure 6-302: <Xm/XmStrDefs.h>*, Part 15 of 34
Figure 6-303: <Xm/XmStrDefs.h>*, Part 16 of 34
Figure 6-304: <Xm/XmStrDefs.h>*, Part 17 of 34
Figure 6-305: <Xm/XmStrDefs.h>*, Part 18 of 34
Figure 6-306: <Xm/XmStrDefs.h>*, Part 19 of 34
Figure 6-307: <Xm/XmStrDefs.h>*, Part 20 of 34
Figure 6-308: <Xm/XmStrDefs.h>*, Part 21 of 34
Figure 6-309: <Xm/XmStrDefs.h>*, Part 22 of 34
Figure 6-310: <Xm/XmStrDefs.h>*, Part 23 of 34
Figure 6-311: <Xm/XmStrDefs.h>*, Part 24 of 34
Figure 6-312: <Xm/XmStrDefs.h>*, Part 25 of 34
Figure 6-313: <Xm/XmStrDefs.h>*, Part 26 of 34
Figure 6-314: <Xm/XmStrDefs.h>*, Part 27 of 34
Figure 6-315: <Xm/XmStrDefs.h>*, Part 28 of 34
Figure 6-316: <Xm/XmStrDefs.h>*, Part 29 of 34
Figure 6-317: <Xm/XmStrDefs.h>*, Part 30 of 34
Figure 6-318: <Xm/XmStrDefs.h>*, Part 31 of 34
Figure 6-319: <Xm/XmStrDefs.h>*, Part 32 of 34
Figure 6-320: <Xm/XmStrDefs.h>*, Part 33 of 34
Figure 6-321: <Xm/XmStrDefs.h>*, Part 34 of 34
Figure 6-322: <netinet/in.h>
Figure 6-323: <netinet/ip.h>
Figure 6-324: <netinet/tcp.h>

Table of Contents

6-238
6-239
6-240
6-241
6-242
6-243
6-244
6-245
6-246
6-247
6-248
6-249
6-250
6-251
6-252
6-253
6-254
6-255
6-256
6-257
6-258
6-259
6-260
6-261
6-262
6-263
6-264
6-265
6-266
6-267
6-268
6-270
6-271
6-271

xi

DRAFT COPY
March 19, 1997
File: abi_386/MasterToc (Delta 44.6)
386:adm.book:sum
Page: 13

1

INTRODUCTION

The Intel386 Architecture and the System V
1-1
ABI

How to Use the Intel386 Architecture ABI
Supplement
Evolution of the ABI Specification

Table of Contents

1-2
1-2

i

DRAFT COPY
March 19, 1997
File: abi_386/Cchap1 (Delta 44.3)
386:adm.book:sum
Page: 14

The Intel386 Architecture and the System V ABI
The System V Application Binary Interface, or ABI, defines a system interface for
compiled application programs. Its purpose is to establish a standard binary
interface for application programs on systems that implement the interfaces
defined in the System V Interface Definition, Edition 4. This includes systems that
have implemented UnixWare 2.0.

M

This document is a supplement to the generic System V ABI, and it contains information specific to System V implementations built on the Intel386 processor architecture. Together, these two specifications, the generic System V ABI and the
Intel386 Architecture System V ABI Supplement (hereafter referred to as the Intel386
ABI), constitute a complete System V Application Binary Interface specification for
systems that implement the processor architecture of the Intel386 microprocessors.
Note that, because the Intel486 and Pentium processor are compatible members of
the Intel386 architecture, this Intel386 ABI also applies to any system built with the
Intel486 or the Pentium processor chips.

The Intel386 Architecture and the System V ABI

DRAFT COPY
March 19, 1997
File: abi_386/chap1 (Delta 44.5)
386:adm.book:sum
Page: 15

1-1

M
M

How to Use the Intel386 Architecture ABI
Supplement
This document is a supplement to the generic System V ABI and contains information referenced in the generic specification that may differ when System V is
implemented on different processors. Therefore, the generic ABI is the prime
reference document, and this supplement is provided to fill gaps in that
specification.
As with the System V ABI, this specification references other publicly-available
reference documents, especially the Intel 80386 Programmer’s Reference Manual. All
the information referenced by this supplement should be considered part of this
specification, and just as binding as the requirements and data explicitly included
here.

Evolution of the ABI Specification
The System V Application Binary Interface will evolve over time to address new
technology and market requirements, and will be reissued at intervals of approximately three years. Each new edition of the specification is likely to contain extensions and additions that will increase the potential capabilities of applications that
are written to conform to the ABI.
As with the System V Interface Definition, the ABI will implement Level 1 and
Level 2 support for its constituent parts. Level 1 support indicates that a portion
of the specification will continue to be supported indefinitely, while Level 2 support means that a portion of the specification may be withdrawn or altered after
the next edition of the ABI is made available. That is, a portion of the specification
moved to Level 2 support in an edition of the ABI specification will remain in
effect at least until the following edition of the specification is published.
These Level 1 and Level 2 classifications and qualifications apply to this Supplement, as well as to the generic specification. All components of the ABI and of this
supplement have Level 1 support unless they are explicitly labelled as Level 2.
The following documents may be of interest to the reader of this specification:
i486 MICROPROCESSOR Programmer’s Reference Manual (Intel Literature
order number 240486)

1-2

INTRODUCTION

DRAFT COPY
March 19, 1997
File: abi_386/chap1 (Delta 44.5)
386:adm.book:sum
Page: 16

80386 Programmer’s Reference Manual (Intel Literature order number 230985)
80387 Programmer’s Reference Manual (Intel Literature order number 231917)
UnixWare 2.0 Command Reference (a-l)
UnixWare 2.0 Command Reference (m-z)
UnixWare 2.0 Operating System API Reference: System Calls
UnixWare 2.0 Operating System API Reference: Library Functions
UnixWare 2.0 System Administration: Volumes I and II
System V Interface Definition, Edition 4

NOTE

Diffmarkings have been retained in the text of this book to indicate in which
revisions of System V certain modifications were made to the ABI.
A "G" character in the right hand margin indicates a change in the ABI made
in UNIX System V Release 4.2.
A "M" character in the right hand margin indicates a change in the ABI made
in UnixWare 2.0.

How to Use the Intel386 Architecture ABI Supplement

DRAFT COPY
March 19, 1997
File: abi_386/chap1 (Delta 44.5)
386:adm.book:sum
Page: 17

M

1-3

2

SOFTWARE INSTALLATION

Software Distribution Formats
Physical Distribution Media
File System Formats
s5 File System
UFS File System

Table of Contents

2-1
2-1
2-1
2-1
2-3

i

DRAFT COPY
March 19, 1997
File: abi_386/Cchap2 (Delta 44.3)
386:adm.book:sum
Page: 18

Software Distribution Formats
Physical Distribution Media
Approved media for physical distribution of ABI-conforming software are listed
below. Inclusion of a particular medium on this list does not require an ABIconforming system to accept that medium. For example, a conforming system
may install all software through its network connection and accept none of the
listed media.
1.44MB 3 1/2" floppy disk: quad-density, double-sided, 80 tracks/side, 18
sectors/track, 512 bytes/sector.
1.2MB 5 1/4" floppy disk: quad-density, double-sided, 80 tracks/side, 15
sectors/track, 512 bytes/sector.
360KB 5 1/4" floppy disk: double-density, double-sided, 40 tracks/side, 9
sectors/track, 512 bytes/sector.
60 MB quarter-inch cartridge tape in QIC-24 format.

G

CD-ROM optical disks.

G

150 MB quarter-inch tape.
CAUTION

The use of 360KB 5 1/4" floppy disk, and 60 MB quarter inch cartridge tape
as media for application distribution is moved to Level 2 as of January 1,
1993.

G

File System Formats
Every file system storage volume must conform to a supported format. Two formats are supported: s5 and ufs.

s5 File System
The first physical block on the medium should be empty, and the second contains
the device’s superblock. The third contains an inode list, and remaining blocks on
the device contain data. The superblock has the following format:

Software Distribution Formats

2-1

DRAFT COPY
March 19, 1997
File: abi_386/chap2 (Delta 44.3)
386:adm.book:sum
Page: 19

#define NICFREE
#define NICINOD
struct filsys {
u_short
daddr_t
short
daddr_t
short
ushort_t
char
char
char
char
time_t
short
daddr_t
ushort_t
char
char
long
long
long
long
};
#define FsMAGIC
#define Fs1b
#define Fs2b
#define Fs4b
#define FsOKAY
#define FsACTIVE
#define FsBAD
#define FsBADBLK

50
100

s_isize;
s_fsize;
s_nfree;
s_free[NICFREE];
s_ninode;
s_inode[NICINOD];
s_flock;
s_ilock;
s_fmod;
s_ronly;
s_time;
s_dinfo[4];
s_tfree;
s_tinode;
s_fname[6];
s_fpack[6];
s_fill[12];
s_state;
s_magic;
s_type;

0xfd187e20
1
2
3
0x7c269d38
0x5e72d81a
0xcb096f43
0xbadbc14b

s_type indicates the file system type. Currently, three types of file systems are supported: the original 512-byte logical block, the 1024-byte logical block, and the
2048-byte logical block. s_magic is used to distinguish the original 512-byte
oriented file systems from the newer file systems. If this field is not equal to the
magic number, fsMAGIC, the type is assumed to be fs1b, otherwise the s_type
field is used.
s_state indicates the state of the file system. A cleanly unmounted, undamaged file
system is indicated by the FsOKAY state. After a file system has been mounted for
update, the state changes to FsACTIVE.

2-2

SOFTWARE INSTALLATION

DRAFT COPY
March 19, 1997
File: abi_386/chap2 (Delta 44.3)
386:adm.book:sum
Page: 20

s_isize is the address of the first data block after the i-list; the i-list starts just after
the super-block, namely in block 2; thus the i-list is s_isize–2 blocks long.
s_fsize is the first block not potentially available for allocation to a file.
The free list for each volume is maintained as follows. The s_free array contains up
to 49 numbers of free blocks. s_free[0] is the block number of the head of a chain of
blocks constituting the free list. The first long in each free-chain block is the
number (up to 50) of free-block numbers listed in the next 50 longs of this chain
member. The first of these 50 blocks is the link to the next member of the chain.
s_tfree is the total free blocks available in the file system.
s_ninode is the number of free i-numbers in the s_inode array.
s_tinode is the total free i-nodes available in the file system.
s_flock and s_ilock are flags maintained in the core copy of the file system. s_fmod is
a flag that indicates that the super-block has changed and should be copied to the
disk during the next periodic update of file system information.
s_ronly is a read-only flag to indicate write-protection.
s_time is the last time the super-block of the file system was changed, and is the
number of seconds that have elapsed since 00:00 Jan. 1, 1970 (GMT).
s_fname is the name of the file system and s_fpack is the name of the pack.
I-numbers begin at 1, and the storage for i-nodes begins in block 2. I-node 1 is
reserved for future use. I-node 2 is reserved for the root directory of the file system, but no other i-number has a built-in meaning. Each i-node represents one
file.

UFS File System
In the UFS file system, the first physical block on the device should be empty, and
the second contains the superblock for the file system. Remaining blocks contain
data.
The ufs superblock contains an fs data structure. This structure, and other relevant
data objects are defined below.

Software Distribution Formats

2-3

DRAFT COPY
March 19, 1997
File: abi_386/chap2 (Delta 44.3)
386:adm.book:sum
Page: 21

struct csum {
long
long
long
long
};
struct fs {
struct fs
struct fs
daddr_t
daddr_t
daddr_t
daddr_t
long
long
time_t
long
long
long
long
long
long
long
long
long
long
long
long
long
long
long
long
long
long
long
long
long
long
long
long
long
long
long
daddr_t
long
long
long
long
long
long

cs_ndir;
cs_nbfree;
cs_nifree;
cs_nffree;

*fs_link;
*fs_rlink;
fs_sblkno;
fs_cblkno;
fs_iblkno;
fs_dblkno;
fs_cgoffset;
fs_cgmask;
fs_time;
fs_size;
fs_dsize;
fs_ncg;
fs_bsize;
fs_fsize;
fs_frag;
fs_minfree;
fs_rotdelay;
fs_rps;
fs_bmask;
fs_fmask;
fs_bshift;
fs_fshift;
fs_maxcontig;
fs_maxbpg;
fs_fragshift;
fs_fsbtodb;
fs_sbsize;
fs_csmask;
fs_csshift;
fs_nindir;
fs_inopb;
fs_nspf;
fs_optim;
fs_state;
fs_sparecon[2];
fs_id[2];
fs_csaddr;
fs_cssize;
fs_cgsize;
fs_ntrak;
fs_nsect;
fs_spc;
fs_ncyl;

(continued on next page )

2-4

SOFTWARE INSTALLATION

DRAFT COPY
March 19, 1997
File: abi_386/chap2 (Delta 44.3)
386:adm.book:sum
Page: 22

long
long
long
struct csum
char
char
char
char
char
long
struct csum
long
short
long
u_char

fs_cpg;
fs_ipg;
fs_fpg;
fs_cstotal;
fs_fmod;
fs_clean;
fs_ronly;
fs_flags;
fs_fsmnt[MAXMNTLEN];
fs_cgrotor;
*fs_csp[MAXCSBUFS];
fs_cpc;
fs_postbl[MAXCPG][NRPOS];
fs_magic;
fs_rotbl[1];

};
struct cg {
struct cg
struct cg
time_t
long
short
short
long
struct csum
long
long
long
long
long
short
char
long
u_char
};

*cg_link;
*cg_rlink;
cg_time;
cg_cgx;
cg_ncyl;
cg_niblk;
cg_ndblk;
cg_cs;
cg_rotor;
cg_frotor;
cg_irotor;
cg_frsum[MAXFRAG];
cg_btot[MAXCPG];
cg_b[MAXCPG][NRPOS];
cg_iused[MAXIPG/NBBY];
cg_magic;
cg_free[1];

#define FS_MAGIC
#define BBSIZE
#define SBSIZE
#define BBLOCK
#define SBLOCK
#define UFSROOTINO
#define LOSTFOUNDINO
#define NRPOS
#define MAXIPG
#define MINBSIZE
#define MAXCPG
#define MAXMNTLEN
#define MAXCSBUFS
#define FS_OPTTIME

0x011954
8192
8192
((daddr_t)(0))
((daddr_t)(BBLOCK + BBSIZE / DEV_BSIZE))
((ino_t)2)
(UFSROOTINO + 1)
8
2048
4096
32
512
32
0

(continued on next page )

Software Distribution Formats

2-5

DRAFT COPY
March 19, 1997
File: abi_386/chap2 (Delta 44.3)
386:adm.book:sum
Page: 23

#define FS_OPTSPACE
#define MAXBPC
#define CG_MAGIC

CAUTION

1
(SBSIZE - sizeof (struct fs))
0x090255

The distribution of software in filesystem format is Level 2 as of January 1,
1993.

2-6

G

SOFTWARE INSTALLATION

DRAFT COPY
March 19, 1997
File: abi_386/chap2 (Delta 44.3)
386:adm.book:sum
Page: 24

3

LOW-LEVEL SYSTEM
INFORMATION

Machine Interface
Processor Architecture
Data Representation
Fundamental Types
Aggregates and Unions
Bit-Fields

Function Calling Sequence
Registers and the Stack Frame
Functions Returning Scalars or No Value
Functions Returning Structures or Unions
Integral and Pointer Arguments
Floating-Point Arguments
Structure and Union Arguments

Operating System Interface
Virtual Address Space
Page Size
Virtual Address Assignments
Managing the Process Stack
Coding Guidelines

Processor Execution Modes
Exception Interface
Hardware Exception Types
Software Trap Types

Process Initialization
Special Registers
Process Stack and Registers

Table of Contents

3-1
3-1
3-1
3-2
3-3
3-6

3-9
3-9
3-12
3-14
3-17
3-17
3-18

3-20
3-20
3-20
3-20
3-22
3-23
3-24
3-24
3-24
3-25
3-26
3-26
3-28

i

DRAFT COPY
March 19, 1997
File: abi_386/Cchap3 (Delta 44.4)
386:adm.book:sum
Page: 25

Coding Examples
Code Model Overview
Position-Independent Function Prologue
Data Objects
Function Calls
Branching
C Stack Frame
Variable Argument List
Allocating Stack Space Dynamically

ii

3-34
3-35
3-36
3-37
3-39
3-41
3-43
3-44
3-44

Table of Contents

DRAFT COPY
March 19, 1997
File: abi_386/Cchap3 (Delta 44.4)
386:adm.book:sum
Page: 26

Machine Interface
Processor Architecture
The Intel 80386 Programmer’s Reference Manual (Intel Literature order number
230985) and the Intel 80387 Programmer’s Reference Manual (Intel Literature order
number 231917) together define the processor architecture. The architecture of the
combined Intel386/Intel 387 processors is hereafter referred to as the Intel386
architecture. Programs intended to execute directly on the processor use the
instruction set, instruction encodings, and instruction semantics of the architecture. Three points deserve explicit mention.
A program may assume all documented instructions exist.
A program may assume all documented instructions work.
A program may use only the instructions defined by the architecture.
In other words, from a program’s perspective, the execution environment provides a
complete and working implementation of the Intel386 architecture.
This does not imply that the underlying implementation provides all instructions
in hardware, only that the instructions perform the specified operations and produce the specified results. The ABI neither places performance constraints on systems nor specifies what instructions must be implemented in hardware. A
software emulation of the architecture could conform to the ABI.
Some processors might support the Intel386 architecture as a subset, providing
additional instructions or capabilities. Programs that use those capabilities explicitly do not conform to the Intel386 ABI. Executing those programs on machines
without the additional capabilities gives undefined behavior.

Data Representation
Within this specification, the term halfword refers to a 16-bit object, the term word
refers to a 32-bit object, and the term doubleword refers to a 64-bit object.

Machine Interface

3-1

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 27

Fundamental Types
Figure 3-1 shows the correspondence between ANSI C’s scalar types and the
processor’s.
Figure 3-1: Scalar Types

Alignment
Intel386
Type
C
sizeof (bytes)
Architecture
____________________________________________________________________________
 char



1
1
 signed char


 signed byte
______________________________________________________________



unsigned char 
1
1
______________________________________________________________

 unsigned byte
 short



2
2
 signed short


 signed halfword
______________________________________________________________



unsigned short 
2
2
______________________________________________________________

 unsigned halfword
Integral
 int



 signed int







4
4
 long


 signed word
s
i
g
n
e
d
l
o
n
g







enum
______________________________________________________________
 unsigned int





4

4
 unsigned word
____________________________________________________________________________
 unsigned long 


 any-type *



Pointer
4
4



 unsigned word
any-type
(
*
)
(
)
____________________________________________________________________________




float
4
4
______________________________________________________________


 single-precision (IEEE)
Floating-point ______________________________________________________________
double

8

4
 double-precision (IEEE)
 long double


 extended-precision (IEEE)
12
4
____________________________________________________________________________





NOTE

The Intel386 architecture does not require doubleword alignment for doubleprecision values. Nevertheless, for data structure compatibility with other Intel
architectures, compilers may provide a method to align double-precision
values on doubleword boundaries.

3-2

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 28

CAUTION

A compiler that provides the doubleword alignment mentioned above can
generate code (data structures and function calling sequences) that do not
conform to the Intel386 ABI. Programs built with the doubleword alignment
facility can thus violate conformance to the Intel386 ABI. See ‘‘Aggregates
and Unions’’ below and ‘‘Function Calling Sequence’’ later in this chapter
for more information.

A null pointer (for all types) has the value zero.
The Intel386 architecture does not require all data access to be properly aligned.
For example, double-precision values occupy 1 doubleword (8-bytes), and their
natural alignment is a word boundary, meaning their addresses are multiples of 4.
Compilers should allocate independent data objects with the proper alignment;
examples include global arrays of double-precision variables, FORTRAN COMMON
blocks, and unconstrained stack objects. However, some language facilities (such
as FORTRAN EQUIVALENCE statements) may create objects with only byte alignment. Consequently, arbitrary data accesses, such as pointers dereference or reference arguments, might or might not be properly aligned. Accessing misaligned
data will be slower than accessing properly aligned data, but otherwise there is no
difference.

Aggregates and Unions
Aggregates (structures and arrays) and unions assume the alignment of their most
strictly aligned component. The size of any object, including aggregates and
unions, is always a multiple of the object’s alignment. An array uses the same
alignment as its elements. Structure and union objects can require padding to
meet size and alignment constraints. The contents of any padding is undefined.
An entire structure or union object is aligned on the same boundary as its
most strictly aligned member.
Each member is assigned to the lowest available offset with the appropriate
alignment. This may require internal padding, depending on the previous
member.
A structure’s size is increased, if necessary, to make it a multiple of the
alignment. This may require tail padding, depending on the last member.

Machine Interface

3-3

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 29

G

NOTE

ABI conformant code may not read or modify anything marked reserved or
padding.

M

In the following examples, members’ byte offsets appear in the upper right
corners.
Figure 3-2: Structure Smaller Than a Word

struct {
char
};

Byte aligned, sizeof is 1
c;

c

0

Figure 3-3: No Padding

struct {
char
char
short
long
};

Word aligned, sizeof is 8
c;
d;
s;
n;

s

2

d

1

c

0

4

n

Figure 3-4: Internal Padding

struct {
char
short
};

Halfword aligned, sizeof is 4
c;
s;

s

3-4

2

pad

1

c

0

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 30

Figure 3-5: Internal and Tail Padding

struct {
char
c;
double d;
short s;
};

Word aligned, sizeof is 16
1

pad

c

4

d

8

d
14

pad

NOTE

0

12

s

The Intel386 architecture does not require doubleword alignment for doubleprecision values. Nevertheless, for data structure compatibility with other Intel
architectures, compilers may provide a method to align double-precision
values on doubleword boundaries.

CAUTION

A compiler that provides the doubleword alignment mentioned above would
arrange the preceding structure differently. Programs built with the doubleword alignment facility would not conform to the Intel386 ABI, and they
would not be data-compatible with conforming Intel386 programs.

Figure 3-6: union Allocation

union {
char
short
int
};

Word aligned, sizeof is 4
c;
s;
j;

1

pad
pad

2

j

Machine Interface

s

c

0

0

0

3-5

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 31

Bit-Fields
C struct and union definitions may have bit-fields, which define integral objects
with a specified number of bits.
Figure 3-7: Bit-Field Ranges

Bit-field Type
Width w
Range
_____________________________________________

 − 2 w − 1 to 2 w − 1 − 1
signed char
 1 to 8
 0 to 2 w − 1
char


w
u
nsigned char 
_____________________________________________
 0 to 2 − 1

 − 2 w − 1 to 2 w − 1 − 1
signed short

 0 to 2 w − 1
short
1 to 16

 0 to 2 w − 1
u
nsigned short
_____________________________________________


w −1
signed int
to 2 w − 1 − 1

 −2
w

 0 to 2 − 1
int
 1 to 32
 0 to 2 w − 1
enum

 0 to 2 w − 1
u
nsigned int
_____________________________________________


w −1
signed long
to 2 w − 1 − 1

 −2
w
long
 1 to 32
 0 to 2 − 1
 0 to 2 w − 1
u
nsigned long 
_____________________________________________

‘‘Plain’’ bit-fields (that is, those neither signed nor unsigned) always have nonnegative values. Although they may have type char, short, int, or long (which
can have negative values), these bit-fields have the same range as a bit-field of the
same size with the corresponding unsigned type. Bit-fields obey the same size
and alignment rules as other structure and union members, with the following
additions:
Bit-fields are allocated from right to left (least to most significant).
A bit-field must entirely reside in a storage unit appropriate for its declared
type. Thus a bit-field never crosses its unit boundary.
Bit-fields may share a storage unit with other struct/union members,
including members that are not bit-fields. Of course, struct members
occupy different parts of the storage unit.
Unnamed bit-fields’ types do not affect the alignment of a structure or
union, although individual bit-fields’ member offsets obey the alignment
constraints.

3-6

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 32

The following examples show struct and union members’ byte offsets in the
upper right corners; bit numbers appear in the lower corners.
Figure 3-8: Bit Numbering

0x01020304

3

01
31

2

02

24 23

1

03

16 15

0

04

87

0

Figure 3-9: Right-to-Left Allocation

struct {
int
int
int
};

Word aligned, sizeof is 4
j:5;
k:6;
m:7;

pad

m

31

18 17

k

j
54

11 10

0
0

Figure 3-10: Boundary Alignment

struct {
short
int
char
short
short
char
};

Word aligned, sizeof is 12
s:9;
j:9;
c;
t:9;
u:9;
d;

c

3

pad
23

pad
15

j
18 17

u
98

s
98

6
0 15

pad

Machine Interface

pad

t
98
9

d

0
0
4
0
8

3-7

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 33

Figure 3-11: Storage Unit Sharing

struct {
char
short
};

Halfword aligned, sizeof is 2
c;
s:8;

1

s
15

c

0

8

Figure 3-12: union Allocation

union {
char
short
};

Halfword aligned, sizeof is 2
c;
s:8;

pad

1

pad
15

c
s

87

0

0
0

Figure 3-13: Unnamed Bit-Fields

struct {
char
int
char
short
char
char
};

Byte aligned, sizeof is 9
c;
:0;
d;
:9;
e;
:0;

1

:0
pad
15

:9
98

6

pad

5

c
d

0

4

0

e

8

As the examples show, int bit-fields (including signed and unsigned) pack
more densely than smaller base types. One can use char and short bit-fields to
force particular alignments, but int is generally more efficient.

3-8

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 34

Function Calling Sequence
This section discusses the standard function calling sequence, including stack
frame layout, register usage, parameter passing, and so on. The system libraries
described in Chapter 6 require this calling sequence.
NOTE

NOTE

The standard calling sequence requirements apply only to global functions.
Local functions that are not reachable from other compilation units may use
different conventions. Nonetheless, it is recommended that all functions use
the standard calling sequence when possible.
C programs follow the conventions given here. For specific information on the
implementation of C, see ‘‘Coding Examples’’ in this chapter.

Registers and the Stack Frame
The Intel386 architecture provides a number of registers. All the integer registers
and all the floating-point registers are global to all procedures in a running program.
Brief register descriptions appear in Figure 3-14 more complete information
appears later.

Function Calling Sequence

3-9

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 35

Figure 3-14: Processor Registers

Type
Name
Usage
________________________________________________________________
 %eax
 Return value
 %edx
 Dividend register (divide operations)


 %ecx
 Count register (shift and string operations)
%
e
b
x

 Local register variable
General
 %ebp
 Stack frame pointer (optional)
 %esi
 Local register variable
 %edi
 Local register variable


________________________________________________________________
 %esp
 Stack pointer
 %st(0)  floating-point stack top, return value
 %st(1)  floating-point next to stack top
Floating-point 
. . . 


________________________________________________________________
 %st(7)  floating-point stack bottom

G

In addition to registers, each function has a frame on the run-time stack. This
stack grows downward from high addresses. Figure 3-15 shows the stack frame
organization.
Figure 3-15: Standard Stack Frame

Position
Contents
Frame
_________________________________________________

4n+8(%ebp) 
argument word n
High addresses

 Previous
...


8(%ebp) 
argument word 0
_________________________________________________


4(%ebp) _ ________________________
return address
0(%ebp) _________________________
previous %ebp (optional) 


-4(%ebp) 
unspecified
 Current


...

0(%esp) 
variable size
Low addresses
_________________________________________________

Several key points about the stack frame deserve mention.
The stack is word aligned. Although the architecture does not require any
alignment of the stack, software convention and the operating system
requires that the stack be aligned on a word boundary.

3-10

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 36

G
G

Argument words are pushed onto the stack in reverse order (that is, the
rightmost argument in C call syntax has the highest address), preserving the
stack’s word alignment. All incoming arguments appear on the stack, residing in the stack frame of the caller.
An argument’s size is increased, if necessary, to make it a multiple of words.
This may require tail padding, depending on the size of the argument.
Other areas depend on the compiler and the code being compiled. The standard calling sequence does not define a maximum stack frame size, nor does
it restrict how a language system uses the ‘‘unspecified’’ area of the standard stack frame.
All registers on the Intel386 are global and thus visible to both a calling and a
called function. Registers %ebp, %ebx, %edi, %esi, and %esp ‘‘belong’’ to the calling function. In other words, a called function must preserve these registers’
values for its caller. Remaining registers ‘‘belong’’ to the called function. If a calling function wants to preserve such a register value across a function call, it must
save the value in its local stack frame.
Some registers have assigned roles in the standard calling sequence:
%esp

The stack pointer holds the limit of the current stack frame, which
is the address of the stack’s bottom-most, valid word. At all
times, the stack pointer should point to a word-aligned area.

%ebp

The frame pointer optionally holds a base address for the current
stack frame. Consequently, a function has registers pointing to
both ends of its frame. Incoming arguments reside in the previous frame, referenced as positive offsets from %ebp, while local
variables reside in the current frame, referenced as negative
offsets from %ebp. A function must preserve this register’s value
for its caller.

%eax

Integral and pointer return values appear in %eax. A function that
returns a struct or union value places the address of the result
in %eax. Otherwise this is a scratch register.

%ebx

As described below, this register serves as the global offset table
base register for position-independent code. For absolute code,
%ebx serves as a local register and has no specified role in the
function calling sequence. In either case, a function must
preserve the register value for the caller.

%esi and %edi

These local registers have no specified role in the function calling
sequence. A function must preserve their values for the caller.

Function Calling Sequence

3-11

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 37

G

%ecx and %edx

Scratch registers have no specified role in the standard calling
sequence. Functions do not have to preserve their values for the
caller.

%st(0)

Floating-point return values appear on the top of the floatingpoint register stack; there is no difference in the representation
of single- or double-precision values in floating-point registers.
If the function does not return a floating-point value, then this
register must be empty. This register must be empty before
entry to a function.

G

%st(1) through %st(7)
Floating-point scratch registers have no specified role in the standard calling sequence. These registers must be empty before
entry and upon exit from a function.
EFLAGS

The flags register contains the system flags, such as the direction
flag and the carry flag. The direction flag must be set to the
‘‘forward’’ (that is, zero) direction before entry and upon exit
from a function. Other user flags have no specified role in the
standard calling sequence and are not preserved.

Floating-Point Control Word
The Intel387 control word contains the floating-point flags, such
as the rounding mode and exception masking.
Signals can interrupt processes [see signal(BA_OS)]. Functions called during signal handling have no unusual restrictions on their use of registers. Moreover, if a
signal handling function returns, the process resumes its original execution path
with registers restored to their original values. Thus, programs and compilers
may freely use all registers without the danger of signal handlers changing their
values.

Functions Returning Scalars or No Value
A function that returns an integral or pointer value places its result in register
%eax.
A floating-point return value appears on the top of the Intel387 register stack. The
caller then must remove the value from the Intel387 stack, even if it doesn’t use the
value. Failure of either side to meet its obligations leads to undefined program
behavior. The standard calling sequence does not include any method to detect
such failures nor to detect return value type mismatches. Therefore the user must
declare all functions properly. There is no difference in the representation of

3-12

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 38

*

single-, double- or extended-precision values in floating-point registers.
Functions that return no value (also called procedures or void functions) put no
particular value in any register.
A call instruction pushes the address of the next instruction (the return address)
onto the stack. The ret instruction pops the address off the stack and effectively
continues execution at the next instruction after the call instruction. A function
that returns a scalar or no value must preserve the caller’s registers as described
earlier. Additionally, the called function must remove the return address from the
stack, leaving the stack pointer (%esp) with the value it had before the call
instruction was executed.
To illustrate, the following function prologue allocates 80 bytes of local stack space
and saves the local registers %ebx, %esi, and %edi.
Figure 3-16: Function Prologue

prologue:
pushl
movl
subl
pushl
pushl
pushl

%ebp
%esp, %ebp
$80, %esp
%edi
%esi
%ebx

/ save frame pointer
/ set new frame pointer
/ allocate stack space
/ save local register
/ save local register
/ save local register

An epilogue for the example that restores the state for the caller. This example
returns the value in %edi by moving it to %eax.

Function Calling Sequence

3-13

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 39

Figure 3-17: Function Epilogue

movl
epilogue:
popl
popl
popl
leave
ret

NOTE

%edi, %eax

/ set up return value

%ebx
%esi
%edi

/ restore local register
/ restore local register
/ restore local register
/ restore frame pointer
/ pop return address

Although some functions can be optimized to eliminate the save and restore
of the frame pointer, the general case uses the standard prologue and epilogue.

Sections below describe where arguments appear on the stack. The examples are
written as if the function prologue described above had been used.
Position-independent code uses the %ebx register to hold the address of the global
offset table. If a function needs the global offset table’s address, either directly or
indirectly, it is responsible for computing the value. See ‘‘Coding Examples’’ later
in this chapter and ‘‘Dynamic Linking’’ in Chapter 5 for more information.

Functions Returning Structures or Unions
If a function returns a structure or union, then the caller provides space for the
return value and places its address on the stack as argument word zero. In effect,
this address becomes a ‘‘hidden’’ first argument. Having the caller supply the
return object’s space allows re-entrancy.
NOTE

Structures and unions in this context have fixed sizes. The ABI does not
specify how to handle variable sized objects.

3-14

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 40

A function that returns a structure or union also sets %eax to the value of the original address of the caller’s area before it returns. Thus when the caller receives
control again, the address of the returned object resides in register %eax and can
be used to access the object. Both the calling and the called functions must
cooperate to pass the return value successfully:
The calling function must supply space for the return value and pass its
address in the stack frame;
The called function must use the address from the frame and copy the
return value to the object so supplied;
The called function must remove this address from the stack before returning.
Failure of either side to meet its obligations leads to undefined program behavior.
The standard function calling sequence does not include any method to detect
such failures nor to detect structure and union type mismatches. Therefore the
user must declare all functions properly.
Figure 3-18 illustrates the stack contents when the function receives control (after
the call instruction) and when the calling function again receives control (after
the ret instruction).
Figure 3-18: Stack Contents for Functions Returning struct/union

Position
After call
___________________
4n+4(%esp)  argument word n 


...


8(%esp) ___________________
argument word 1 
4(%esp)  value address

___________________
0(%esp) ___________________
return address 

After ret
Position
___________________
 argument word n  4n-4(%esp)


...


argument word 1  0(%esp)
___________________


undefined




___________________

To illustrate, the following function prologue allocates 80 bytes of local stack space
and saves the local registers %ebx, %esi, and %edi. Additionally, it removes the
‘‘hidden’’ argument from the stack and saves it in the highest word of the local
stack frame.

Function Calling Sequence

3-15

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 41

Figure 3-19: Function Prologue (Returning struct/union)

prologue:
popl %eax
xchgl %eax, 0(%esp)
pushl
movl
subl
pushl
pushl
pushl
movl

/ pop return address
/ swap return address
/ and return value address
%ebp
/ save frame pointer
%esp, %ebp
/ set new frame pointer
$80, %esp
/ allocate local space
%edi
/ save local register
%esi
/ save local register
%ebx
/ save local register
%eax, -4(%ebp) / save return value address

An epilogue for the example that restores the state for the caller.
Figure 3-20: Function Epilogue

epilogue:
movl
popl
popl
popl
leave
ret

-4(%ebp), %eax
%ebx
%esi
%edi

/ set up return value
/ restore local register
/ restore local register
/ restore local register
/ restore frame pointer
/ pop return address

3-16

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 42

NOTE

Although some functions can be optimized to eliminate the save and restore
of the frame pointer, the general case uses the standard prologue and epilogue.

Sections below describe where arguments appear on the stack. The examples are
written as if the function prologue described above had been used.
Position-independent code uses the %ebx register to hold the address of the global
offset table. If a function needs the global offset table’s address, either directly or
indirectly, it is responsible for computing the value. See ‘‘Coding Examples’’ later
in this chapter and ‘‘Dynamic Linking’’ in Chapter 5 for more information.

Integral and Pointer Arguments
As mentioned, a function receives all its arguments through the stack; the last
argument is pushed first. In the standard calling sequence, the first argument is at
offset 8(%ebp), the second argument is at offset 12(%ebp), and so on. Functions
pass all integer-valued arguments as words, expanding or padding signed or
unsigned bytes and halfwords as needed.
Figure 3-21: Integral and Pointer Arguments

Call
Argument
Stack address
___________________________________________


1
8(%ebp)


g(1, 2, 3,
2
12(%ebp)


(void *)0); 
3
16(%ebp)

20(%ebp)
___________________________________________
 (void *)0 

Floating-Point Arguments
The stack also holds floating-point arguments: single-precision values use one
word, double-precision use two, and extended-precision use three. See ‘‘Coding
Examples’’ for information about floating-point arguments and variable argument
lists. The example below uses only double-precision arguments. Single- and
extended-precision arguments behave as specified above.

Function Calling Sequence

3-17

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 43

Figure 3-22: Floating-Point Arguments

Call
Argument
Stack address
________________________________________________
 word 0, 1.414

8(%ebp)
 word 1, 1.414

12(%ebp)
h(1.414, 1, 

1
16(%ebp)

2.998e10); 
word
0,
2
.
9
9
8
e
1
0
20(%ebp)



word
1,
2
.
9
9
8
e
1
0

24(%ebp)
________________________________________________



NOTE

The Intel386 architecture does not require doubleword alignment for doubleprecision values. Nevertheless, for data structure compatibility with other Intel
architectures, compilers may provide a method to align double-precision
values on doubleword boundaries.

CAUTION

A compiler that provides the doubleword alignment mentioned above would
have to maintain doubleword alignment for the stack. Moreover, the arguments in the preceding example would appear in different positions. Programs built with the doubleword alignment facility would not conform to the
Intel386 ABI, and their function calling sequence would not be compatible
with conforming Intel386 programs.

Structure and Union Arguments
As described in the data representation section, structures and unions can have
byte, halfword, or word alignment, depending on the constituents. An
argument’s size is increased, if necessary, to make it a multiple of words. This
may require tail padding, depending on the size of the argument. To ensure that
data in the stack is properly aligned, the stack pointer should always point to a
word boundary. Structure and union arguments are pushed onto the stack in the
same manner as integral arguments, described above. This provides call-by-value
semantics, letting the called function modify its arguments without affecting the
calling function’s object.

3-18

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 44

Figure 3-23: Structure and Union Arguments

Call
Argument
Callee
_________________________________
1
 8(%ebp)
 word 0, s  12(%ebp)
i(1, s); 

 word 1, s  16(%ebp)
...
 . . .

_________________________________

Function Calling Sequence

3-19

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 45

Operating System Interface
Virtual Address Space
Processes execute in a 32-bit virtual address space. Memory management
translates virtual addresses to physical addresses, hiding physical addressing and
letting a process run anywhere in the system’s real memory. Processes typically
begin with three logical segments, commonly called text, data, and stack. As
Chapter 5 describes, dynamic linking creates more segments during execution,
and a process can create additional segments for itself with system services.

Page Size
Memory is organized by pages, which are the system’s smallest units of memory
allocation. Page size can vary from one system to another, depending on the processor, memory management unit and system configuration. Processes may call
sysconf(BA_OS) to determine the system’s current page size.

*

Virtual Address Assignments
Conceptually, processes have the full 32-bit address space available. In practice,
however, several factors limit the size of a process.
The system reserves a configuration-dependent amount of virtual space.
The system reserves a configuration dependent amount of space per process.
A process whose size exceeds the system’s available, combined physical
memory and secondary storage cannot run. Although some physical
memory must be present to run any process, the system can execute
processes that are bigger than physical memory, paging them to and from
secondary storage. Nonetheless, both physical memory and secondary
storage are shared resources. System load, which can vary from one program execution to the next, affects the available amounts.

3-20

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 46

G

Figure 3-24: Virtual Address Configuration

____________________
 End of memory
0xffffffff 
Reserved




...


_ ___________________




...




0x80000000 _ ___________________
Dynamic segments 




...




0 _ ___________________
Process segments  Beginning of memory

CAUTION

Programs that dereference null pointers are erroneous. although an implementation is not obliged to detect such erroneous behavior. Such programs may or may not fail on a particular system. To enhance portability,
programmers are strongly cautioned not to rely on this behavior.

G
G

Process segments
Processes’ loadable segments and stack may begin at 0. The exact
addresses depend on the executable file format [see further information below and in Chapters 4 and 5]. Processes can control the
amount of virtual memory allotted for stack space, as described
below.
Dynamic segments
A process’s dynamic segments reside below the reserved area.
Reserved

A reserved area resides at the top of virtual space.

As the figure shows, the system reserves the high end of virtual address space,
with a process’s dynamic segments below that. Although the exact boundary
between the reserved area and a process depends on the system’s configuration,
the reserved area shall not consume more than 1 GB of the address space. Thus
the user virtual address range has a minimum upper bound of 0xc0000000.
Individual systems may reserve less space, increasing processes’ virtual memory
range.

Operating System Interface

3-21

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 47

Although applications may control their memory assignments, the typical
arrangement appears below.
Figure 3-25: Conventional Segment Arrangements

0x80000000
0x7fffffff

0x8048000

0

____________________




...




Dynamic segments 
____________________




...




Data segment
____________________





...




Text segment
_ ___________________

 Stack segment





...


_ ___________________

The process’s text segment resides at 0x8048000. The data segment follows
immediately, and dynamic segments occupy the higher range. When applications
let the system choose addresses for dynamic segments (including shared object
segments), it chooses high addresses. This leaves the ‘‘middle’’ of the address
spectrum available for dynamic memory allocation with facilities such as
malloc(BA_OS). Processes should not depend on finding their dynamic segments
at particular virtual addresses. Facilities exist to let the system choose dynamic
segment virtual addresses. The stack resides immediately below the text segment,
growing toward lower addresses. This arrangement provides a little over 128 MB
for the stack and about 2 GB for text and data.

Managing the Process Stack
Section ‘‘Process Initialization’’ in this chapter describes the initial stack contents.
Stack addresses can change from one system to the next—even from one process
execution to the next on the same system. Processes, therefore, should not depend
on finding their stack at a particular virtual address.

3-22

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 48

A tunable configuration parameter controls the system maximum stack size. A
process also can use setrlimit(BA_OS), to set its own maximum stack size, up to
the system limit. On the Intel386, the stack segment has read and write permissions.

Coding Guidelines
Operating system facilities, such as mmap(KE_OS), allow a process to establish
address mappings in two ways. First, the program can let the system choose an
address. Second, the program can force the system to use an address the program
supplies. This second alternative can cause application portability problems,
because the requested address might not always be available. Differences in virtual address space can be particularly troublesome between different architectures, but the same problems can arise within a single architecture.
Processes’ address spaces typically have three segment areas that can change size
from one execution to the next: the stack [through setrlimit(BA_OS)], the data
segment [through malloc(BA_OS)], and the dynamic segment area [through
mmap(KE_OS)]. Changes in one area may affect the virtual addresses available for
another. Consequently, an address that is available in one process execution
might not be available in the next. A program that used mmap(KE_OS) to request a
mapping at a specific address thus could appear to work in some environments
and fail in others. For this reason, programs that wish to establish a mapping in
their address space should let the system choose the address.
Despite these warnings about requesting specific addresses, the facility is both
useful and can be used in a controlled manner. For example, a multiprocess application might map several files into the address space of each process and build
relative pointers among the files’ data. This could be done by having each process
ask for a certain amount of memory at an address chosen by the system. After
each process receives its own, private address from the system, it would map the
desired files into memory, at specific addresses within the original area. This collection of mappings could be at different addresses in each process but their relative positions would be fixed. Without the ability to ask for specific addresses, the
application could not build shared data structures, because the relative positions
for files in each process would be unpredictable.

Operating System Interface

3-23

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 49

Processor Execution Modes
Four execution modes exist in the Intel386 architecture: ring 3 (or user mode) and
three privileged rings. User processes run in user mode ring (the least privileged).
The operating system kernel runs in a privileged mode ring, although the ABI
does not specify which one. A program executes the lcall instruction through a
system call gate to change execution modes, and thus the lcall instruction provides the low-level interface to system calls. For the Intel386, one low-level interface is defined: _exit(BA_OS).
To ensure a process has a way to terminate itself, the system treats _exit as a special case. The ABI does not specify the implementation of other system services.
Instead, programs should use the system libraries that Chapter 6 describes. Programs with other embedded lcall instructions do not conform to the ABI.
Figure 3-26: _exit System Trap

.globl _exit
_exit:
movl $1, %eax
lcall $7, $0

Exception Interface
As the Intel386 architecture manuals describe, the processor changes mode to handle exceptions, which may be synchronous, floating-point/coprocessor, or asynchronous. Synchronous and floating-point/coprocessor exceptions, being caused
by instruction execution, can be explicitly generated by a process. This section,
therefore, specifies those exception types with defined behavior. The Intel386
architecture classifies exceptions as faults, traps, and aborts. See the Intel 80386
Programmer’s Reference Manual for more information about their differences.

Hardware Exception Types
The operating system defines the following correspondence between hardware
exceptions and the signals specified by signal(BA_OS).

3-24

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 50

Figure 3-27: Hardware Exceptions and Signals

Number
Exception Name
Signal
________________________________________________
 divide error fault
 SIGFPE
0
 single step trap/fault
 SIGTRAP
1


2
 nonmaskable interrupt
 none
3
breakpoint
trap

 SIGTRAP
 overflow trap
 SIGSEGV
4
 bounds check fault
 SIGSEGV
5
 invalid opcode fault
 SIGILL
6


7
 no coprocessor fault
 SIGFPE
8
double
fault
abort

 none
 coprocessor overrun abort
 SIGSEGV
9
 invalid TSS fault
 none
10
 segment not present fault
 none
11


12
 stack exception fault
 SIGSEGV
13
general
protection
fault/abort

 SIGSEGV
 page fault
 SIGSEGV
14
 (reserved)

15
 coprocessor error fault
 SIGFPE
16


other  (unspecified)
________________________________________________
 SIGILL

Floating-point instructions exist in the architecture, but they may be implemented
either in hardware (via the Intel387 chip) or in software (via the Intel387 emulator). In the case of ‘‘no coprocessor’’ exception, if the Intel387 emulator is
configured into the kernel, the process receives no signal. Instead, the system
intercepts the exception, emulates the instruction, and returns control to the process. A process receives SIGFPE for the ‘‘no coprocessor’’ exception only when the
indicated floating-point instruction is illegal (invalid operands, and so on).

Software Trap Types
Because the int instruction generates traps, some hardware exceptions can be
generated by software. However, the int instruction generates only traps and not
faults; so it is not possible to match the exact hardware generated faults in
software.

Operating System Interface

3-25

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 51

Process Initialization
This section describes the machine state that exec(BA_OS) creates for ‘‘infant’’
processes, including argument passing, register usage, stack frame layout, and so
on. Programming language systems use this initial program state to establish a
standard environment for their application programs. As an example, a C program begins executing at a function named main, conventionally declared in the
following way.
Figure 3-28: Declaration for main

extern int main(int argc, char *argv[], char *envp[]);

Briefly, argc is a non-negative argument count; argv is an array of argument
strings, with argv[argc]= =0; and envp is an array of environment strings, also
terminated by a null pointer.
Although this section does not describe C program initialization, it gives the information necessary to implement the call to main or to the entry point for a program
in any other language.

Special Registers
As the Intel386 architecture defines, several state registers control and monitor the
processor: the Machine Status Word register (MSW, also known as register %cr0),
EFLAGS register, the floating-point status register, and the floating-point control
register. Application programs cannot access the full EFLAGS register directly;
because they run in the processor’s user mode, and the instructions to write some
of the bits of the EFLAGS register are privileged. Nonetheless, a program has
access to many of the flags in the EFLAGS register. Flags identified with an ‘‘*’’
below are not modifiable by a user mode process, they either have unspecified
values or do not affect user program behavior. At process initialization, the
EFLAGS register contains the following values.

3-26

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 52

Figure 3-29: EFLAGS Register Fields

Flag
Value
Note
_____________________________________________
 unspecified  Carry flag
CF
 unspecified  Parity flag
PF


AF
 unspecified  Auxiliary carry flag
ZF
 unspecified  Zero flag
SF
 unspecified  Sign flag
 unspecified  Trap flag
TF
 unspecified  Interrupt enable
IF*


DF
0

 Direction flag low to high
OF
unspecified

 Overflow flag
IOPL*  unspecified  I/O privilege level
 unspecified  Nested task
NT*
 unspecified  Resume flag
RF*


VM*
_____________________________________________
 unspecified  Virtual 8086 mode

The Intel386 architecture defines floating-point instructions, and those instructions
work whether the processor has a hardware floating-point unit or not. (A system
may provide hardware or software floating-point facilities.) Consequently, the
contents of the MSW register is not specified, letting the system set it according to
the hardware configuration. In any case, however, the processor presents a working floating-point implementation, including the Intel387 status and control word
registers with the following values at process initialization.
Figure 3-30: Floating-Point Control Word

Field
Value
Note
_____________________________________________


IC
1
Affine infinity (for compatibility)
 00
 Round to nearest or even
RC


PC
 11
 53-bit (double precision)
PM 
1
 Precision masked
UM 
1
 Underflow masked
 Overflow
OM 
1

 Zero divide
ZM
1


DM 
1
 Denormalized operand masked
IM
1
_____________________________________________

 Invalid operation

Operating System Interface

G

G
G
G

3-27

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 53

CAUTION

The initial floating-point state should be changed with care. In particular,
many floating-point routines may produce undefined behavior if the precision control is set to less than 53 bits. The _fpstart routine (see Chapter 6)
changes the precision control to 64 bits and sets all exceptions to be
asked. This is the default state required for conformance to the ANSI C
standard and to the IEEE 754 Floating-point standard.

G
G
G
G

Process Stack and Registers
When a process receives control, its stack holds the arguments and environment
from exec(BA_OS).
Figure 3-31: Initial Process Stack

_____________________________
_____________________________
 High addresses
Unspecified


 Information block, including 
argument strings,




environment strings,


auxiliary information


...


(size varies)
_____________________________

_____________________________

Unspecified
 Null auxiliary vector entry 
_____________________________
Auxiliary vector




...
_____________________________

(2-word entries)


0 word
_____________________________



Environment pointers


...


(one
word
each)
_____________________________
0 word

_____________________________


Argument pointers


...


4(%esp) _____________________________
(Argument count words)


0(%esp) _____________________________
Argument count


Undefined
_____________________________ Low addresses

3-28

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 54

Argument strings, environment strings, and the auxiliary information appear in
no specific order within the information block; the system makes no guarantees
about their arrangement. The system also may leave an unspecified amount of
memory between the null auxiliary vector entry and the beginning of the information block.
General and floating-point register values are unspecified at process entry, with
the exceptions appearing below. Consequently, a program that requires registers
to have specific values must set them explicitly during process initialization. It
should not rely on the operating system to set all registers to 0.
%ebp

The content of this register is unspecified at process initialization
time, but the user code should mark the deepest stack frame by
setting the frame pointer to zero. No other frame’s %ebp should
have a zero value.

%esp

Performing its usual job, the stack pointer holds the address of the
bottom of the stack, which is guaranteed to be word aligned.

%edx

In a conforming program, this register contains a function pointer
that the application should register with atexit(BA_OS). This
function is used for shared object termination code [see ‘‘Dynamic
Linking’’ in Chapter 5 of the System V ABI].

%cs, %ds, %es, %ss
The segment registers are initialized so that the user process can
address the code, data, and stack segments using a 32-bit virtual
address. A program that alters their values does not conform to
the ABI and has undefined behavior.
Every process has a stack, but the system defines no fixed stack address. Furthermore, a program’s stack address can change from one system to another—even
from one process invocation to another. Thus the process initialization code must
use the stack address in %esp. Data in the stack segment at addresses below the
stack pointer contain undefined values.
Whereas the argument and environment vectors transmit information from one
application program to another, the auxiliary vector conveys information from the
operating system to the program. This vector is an array of the following structures, interpreted according to the a_type member.

Operating System Interface

3-29

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 55

Figure 3-32: Auxiliary Vector

typedef struct
{
int
a_type;
union {
long a_val;
void *a_ptr;
void (*a_fcn)();
} a_un;
} auxv_t;

Figure 3-33: Auxiliary Vector Types, a_type

Name
Value
a_un
__________________________________

AT_NULL
0  ignored

AT_IGNORE
1  ignored


AT_EXECFD
2  a_val

AT_PHDR
3  a_ptr


AT_PHENT
4  a_val

AT_PHNUM
5  a_val

AT_PAGESZ
6  a_val


AT_BASE
7  a_ptr

AT_FLAGS
8  a_val

AT_ENTRY

9  a_ptr
 10  a_val
AT_LIBPATH
 11  a_val
AT_FPHW


AT_INTP_DEVICE  12  a_val
AT_INTP_INODE  13  a_val
__________________________________



AT_NULL

The auxiliary vector has no fixed length; instead its last entry’s
a_type member has this value.

3-30

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 56

M
M
M
M

AT_IGNORE

This type indicates the entry has no meaning. The corresponding
value of a_un is undefined.

AT_EXECFD

As Chapter 5 describes, exec(BA_OS) may pass control to an
interpreter program. When this happens, the system places either
an entry of type AT_EXECFD or one of type AT_PHDR in the auxiliary vector. The entry for type AT_EXECFD uses the a_val member
to contain a file descriptor open to read the application program’s
object file.

AT_PHDR

Under some conditions, the system creates the memory image of
the application program before passing control to the interpreter
program. When this happens, the a_ptr member of the AT_PHDR
entry tells the interpreter where to find the program header table
in the memory image. If the AT_PHDR entry is present, entries of
types AT_PHENT, AT_PHNUM, and AT_ENTRY must also be present.
See Chapter 5 in both the System V ABI and the processor supplement for more information about the program header table.

AT_PHENT

The a_val member of this entry holds the size, in bytes, of one
entry in the program header table to which the AT_PHDR entry
points.

AT_PHNUM

The a_val member of this entry holds the number of entries in
the program header table to which the AT_PHDR entry points.

AT_PAGESZ

If present, this entry’s a_val member gives the system page size,
in bytes. The same information also is available through
sysconf(BA_OS).

AT_BASE

The a_ptr member of this entry holds the base address at which
the interpreter program was loaded into memory. See ‘‘Program
Header’’ in the System V ABI for more information about the base
address.

AT_FLAGS

If present, the a_val member of this entry holds one-bit flags.
Bits with undefined semantics are set to zero.

AT_ENTRY

The a_ptr member of this entry holds the entry point of the
application program to which the interpreter program should
transfer control.

AT_LIBPATH

The a_val member of this entry is non-zero if the dynamic linker
should examine LD_LIBRARY_PATH when searching for shared
objects of the process based on the security considerations in the
Shared Object Dependency section in Chapter 5 of the gABI.

Operating System Interface

3-31

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 57

AT_FPHW

The a_val member of this entry will be set to
Figure 3-34: AT_FPHW values

Value
Meaning
________________________________________________________
 if no floating point support exists
0
 if floating point software emulation exists
1

2
 if it has a 80287 chip
3
 if it has a 80387 chip or a 80487 chip
________________________________________________________

AT_INTP_DEVICE
The a_val member of this entry holds the device number of the
file from which the dynamic linker is loaded.
AT_INTP_INODE
The a_val member of this entry holds the inode of the file from
which the dynamic linker is loaded.
Other auxiliary vector types are reserved. No flags are currently defined for
AT_FLAGS, on the Intel386 architecture.
To illustrate, suppose an example process receives two arguments.
echo
abi
It also inherits two environment strings (this example is not intended to show a
fully configured execution environment).
HOME=/home/dir
PATH=/usr/bin:
Its one non-null auxiliary vector entry holds a file descriptor.
{AT_EXECFD, 13}
The resulting stack resides below 0x8048000, growing toward lower addresses.

3-32

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 58

Figure 3-35: Example Process Stack

0x8047ff0

0x8047fe0

0x8047fd0

0x8047fc0

0x8047fb0
0(%esp), 0x8047fac

_____________________
n  :  \0  pad  High addresses
_____________________





r  /  b  i 
_____________________
=  /  u  s 
_____________________
 P  A  T  H 
_____________________




d  i  r  \0 
_____________________
o  m  e  / 
_____________________





E  =  /  h 
_____________________
\0  H  O  M 
_____________________
 \0  a  b  i 
_____________________




e  c  h  o 
_____________________

0
_____________________


0
_____________________


13
_____________________

 Auxiliary vector
2
_____________________

0

_____________________

0x8047ff0
_____________________


0x8047fe1
_____________________
 Environment vector

0
_____________________


0
x
8
0
4
7
f
d
d
_____________________
0x8047fd8
 Argument vector
_____________________
_____________________
 Argument count
2


Undefined
_____________________
 Low addresses

Operating System Interface

3-33

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 59

Coding Examples
This section discusses example code sequences for fundamental operations such as
calling functions, accessing static objects, and transferring control from one part of
a program to another. Previous sections discuss how a program may use the
machine or the operating system, and they specify what a program may and may
not assume about the execution environment. Unlike previous material, the information here illustrates how operations may be done, not how they must be done.
As before, examples use the ANSI C language. Other programming languages
may use the same conventions displayed below, but failure to do so does not
prevent a program from conforming to the ABI. Two main object code models are
available.
Absolute code. Instructions can hold absolute addresses under this model.
To execute properly, the program must be loaded at a specific virtual
address, making the program’s absolute addresses coincide with the
process’s virtual addresses.
Position-independent code. Instructions under this model hold relative
addresses, not absolute addresses. Consequently, the code is not tied to a
specific load address, allowing it to execute properly at various positions in
virtual memory.
Following sections describe the differences between these models. Code
sequences for the models (when different) appear together, allowing easier comparison.
NOTE

Examples below show code fragments with various simplifications. They are
intended to explain addressing modes, not to show optimal code sequences
nor to reproduce compiler output.

NOTE

When other sections of this document show assembly language code
sequences, they typically show only the absolute versions. Information in this
section explains how position-independent code would alter the examples.

3-34

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 60

Code Model Overview
When the system creates a process image, the executable file portion of the process
has fixed addresses, and the system chooses shared object library virtual addresses
to avoid conflicts with other segments in the process. To maximize text sharing,
shared objects conventionally use position-independent code, in which instructions contain no absolute addresses. Shared object text segments can be loaded at
various virtual addresses without having to change the segment images. Thus
multiple processes can share a single shared object text segment, even though the
segment resides at a different virtual address in each process.
Position-independent code relies on two techniques.
Control transfer instructions hold offsets relative to the extended instruction
pointer (EIP). An EIP-relative branch or function call computes its destination address in terms of the current instruction pointer, not relative to any
absolute address.
When the program requires an absolute address, it computes the desired
value. Instead of embedding absolute addresses in the instructions, the
compiler generates code to calculate an absolute address during execution.
Because the Intel386 architecture provides EIP-relative call and branch instructions, compilers can satisfy the first condition easily.
A global offset table provides information for address calculation. Positionindependent object files (executable and shared object files) have this table in their
data segment. When the system creates the memory image for an object file, the
table entries are relocated to reflect the absolute virtual addresses as assigned for
an individual process. Because data segments are private for each process, the
table entries can change—unlike text segments, which multiple processes share.
Assembly language examples below show the explicit notation needed for
position-independent code.
name@GOT(%ebx)
This expression denotes an %ebx-relative reference to the global
offset table entry for the symbol name. The %ebx register contains
the absolute address of the global offset table, as explained below.
name@GOTOFF(%ebx)
This expression denotes an %ebx-relative reference to the symbol
name. Again, %ebx holds the global offset table address. Note
this expression references name, not the global offset table entry
for name.

Coding Examples

3-35

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 61

name@PLT

This expression denotes an EIP-relative reference to the procedure
linkage table entry for the symbol name.

_GLOBAL_OFFSET_TABLE_
The symbol _GLOBAL_OFFSET_TABLE_ is used to access the global
offset table. When an instruction uses the symbol, it sees the
offset between the current instruction and the global offset table
as the symbol value.

Position-Independent Function Prologue
This section describes the function prologue for position-independent code. A
function’s prologue allocates the local stack space, saves any registers it must
preserve, and sets register %ebx to the global offset table’s address. Because %ebx
is private for each function and preserved across function calls, a function calculates its value once at the entry.
Figure 3-36: Calculating Global Offset Table Address

Line
1
2
3

Code
__________________________________________________________


call .L1
 .L1: popl %ebx



addl $_GLOBAL_OFFSET_TABLE_+[.-.L1], %ebx 
__________________________________________________________

These three lines accomplish the following.
1 . The call instruction pushes the absolute address of the next instruction
onto the stack.
2 . Consequently, the popl instruction pops the absolute address of .L1 into
register %ebx.
3 . The last instruction computes the desired absolute value into %ebx. This
works because _GLOBAL_OFFSET_TABLE_ in the expression gives the distance from the addl instruction to the global offset table; [.-.L1] gives the
distance from .L1 to the addl instruction. Adding their sum to the absolute address of .L1, already in %ebx, gives the absolute address of the global offset table.

3-36

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 62

This computation can be added to the standard function prologue, giving the standard prologue for position-independent code. To illustrate, the following function
prologue allocates 80 bytes of local stack space and saves the local registers %ebx,
%esi, and %edi.
Figure 3-37: Position-Independent Function Prologue

prologue:
pushl
movl
subl
pushl
pushl
pushl
call
.L1: popl
addl

%ebp
%esp, %ebp
$80, %esp
%edi
%esi
%ebx
.L1
%ebx
$_GLOBAL_OFFSET_TABLE_+[.-.L1], %ebx

Position-independent and absolute code use the same function epilogue.

Data Objects
This discussion excludes stack-resident objects, because programs always compute
their virtual addresses relative to the stack and frame pointers. Instead, this section describes objects with static storage duration.
In the Intel386 architecture, all memory reference instructions can address any
location within the 32-bit address space. Symbolic references in absolute code put
the symbols’ values—or absolute virtual addresses—into instructions.

Coding Examples

3-37

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 63

Figure 3-38: Absolute Data Access

C
____________________
 extern int src; 
 extern int dst; 


 extern int *ptr; 
 ptr = &dst;



 *ptr = src;





_ ___________________

Assembly
___________________________
 .globl src, dst, ptr 






$dst, ptr
 movl



 movl

ptr, %eax
 movl

src, %edx


movl
%edx, (%eax) 
___________________________

Position-independent instructions cannot contain absolute addresses. Instead,
instructions that reference symbols hold the symbols’ offsets into the global offset
table. Combining the offset with the global offset table address in %ebx gives the
absolute address of the table entry holding the desired address.
Figure 3-39: Position-Independent Data Access

C
____________________
 extern int src; 
 extern int dst; 


 extern int *ptr; 
 ptr = &dst;









 *ptr = src;









_ ___________________

Assembly
__________________________________
 .globl src, dst, ptr







ptr@GOT(%ebx), %eax 
 movl
 movl
dst@GOT(%ebx), %edx 
 movl

%edx, (%eax)




ptr@GOT(%ebx), %eax 
 movl
(%eax), %eax
 movl

 movl
src@GOT(%ebx), %edx 
 movl

(%edx), %edx
 movl

%edx, (%eax)
__________________________________


Finally, position-independent references to static data may be optimized. Because
%ebx holds a known address, the global offset table, a program may use it as a
base register. External references should use the global offset table entry, because
dynamic linking may bind the entry to a definition outside the current object file’s
scope.

3-38

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 64

Figure 3-40: Position-Independent Static Data Access

C
____________________
 static int src; 
 static int dst; 


 static int *ptr; 
 ptr = &dst;









 *ptr = src;



_ ___________________

Assembly
___________________________________








 leal ptr@GOTOFF(%ebx), %eax 
 leal dst@GOTOFF(%ebx), %edx 
 movl %edx, (%eax)





 movl ptr@GOTOFF(%ebx), %eax 
 movl src@GOTOFF(%ebx), %edx 
___________________________________
movl %edx, (%eax)


Function Calls
Programs use the call instruction to make direct function calls. A call
instruction’s destination is an EIP-relative value that can reach any address in the
32-bit virtual space. Even when the code for a function resides in a shared object,
the caller uses the same assembly language instruction sequence, although in that
case control passes from the original call, through an indirection sequence, to the
desired destination. See ‘‘Procedure Linkage Table’’ in Chapter 5 for more information on the indirection sequence.
Figure 3-41: Absolute Direct Function Call

C
____________________________
 extern void function(); 
 function();

____________________________

Assembly
______________________
 .globl function 
 call
function 
______________________

Dynamic linking may redirect a function call outside the current object file’s scope;
so position-independent calls should use the procedure linkage table explicitly.

Coding Examples

3-39

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 65

Figure 3-42: Position-Independent Direct Function Call

C
____________________________
 extern void function(); 
 function();

____________________________

Assembly
__________________________
 .globl function

 call

f
u
n
c
t
i
o
n
@
P
L
T
__________________________

Indirect function calls use the indirect call instruction.
Figure 3-43: Absolute Indirect Function Call

C
__________________________
 extern void (*ptr)(); 
 extern void name();



 ptr = name;



(*ptr)();
__________________________


Assembly
________________________
 .globl ptr, name; 




$name, ptr 
 movl


call
*ptr
________________________


For position-independent code, the global offset table supplies absolute addresses
for all required symbols, whether the symbols name objects or functions.
Figure 3-44: Position-Independent Indirect Function Call

C
__________________________
 extern void (*ptr)(); 
 extern void name();



 ptr = name;







 (*ptr)();



__________________________

Assembly
___________________________________
 .globl ptr, name





ptr@GOT(%ebx), %eax 
 movl
name@GOT(%ebx), %edx 
 movl
 movl

%edx, (%eax)


 movl
ptr@GOT(%ebx), %eax 


call
*(%eax)
___________________________________


3-40

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 66

Branching
Programs use branch instructions to control their execution flow. As defined by
the Intel386 architecture, branch instructions hold an EIP-relative value with a
signed 32-bit range, allowing a jump to any location within the virtual address
space.
Figure 3-45: Branch Instruction, All Models

C
_________________________
 label:



. . .


goto label; 
_________________________

Assembly
_________________________
 .L01:



. . .


jmp
.L01 
_________________________

C switch statements provide multiway selection. When the case labels of a
switch statement satisfy grouping constraints, the compiler implements the selection with an address table. The following examples use several simplifying conventions to hide irrelevant details:
The selection expression resides in register %eax;
case label constants begin at zero;
case labels, default, and the address table use assembly names .Lcasei,
.Ldef, and .Ltab, respectively.
Address table entries for absolute code contain virtual addresses; the selection
code extracts an entry’s value and jumps to that address. Position-independent
table entries hold offsets; the selection code computes a destination’s absolute
address.

Coding Examples

3-41

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 67

Figure 3-46: Absolute switch Code

C
______________
 switch (j) 
{



 case 0:

. . . 

 case 2:


. . . 
 case 3:



. . . 

 default:


. . . 
______________

}

Assembly
______________________________________


cmpl
$3, %eax


ja
.Ldef


jmp
*.Ltab(,%eax,4) 

 .Ltab: .long .Lcase0


.long .Ldef



.long .Lcase2


.long .Lcase3








______________________________________

Figure 3-47: Position-Independent switch Code

C
______________
 switch (j) 
{



 case 0:

. . . 

 case 2:


. . . 
 case 3:



. . . 

 default:


. . . 
}









______________

Assembly
___________________________________________________


cmpl
$3, %eax


ja
.Ldef


leal
.Ltab@GOTOFF(%ebx), %edx


movl
(%edx,%eax,4), %eax



movl
.Ltab@GOTOFF(%ebx,%eax,4), %eax 


call
.Ljmp
 .Ljmp:



popl
%ecx


addl
%ecx, %eax



jmp
*%eax

 .Ltab:



.long .Lcase0 - .Ljmp


.long .Ldef - .Ljmp


.long .Lcase2 - .Ljmp


___________________________________________________
.long .Lcase3 - .Ljmp


3-42

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 68

C Stack Frame
Figure 3-48 shows the C stack frame organization. It conforms to the standard
stack frame with designated roles for unspecified areas in the standard frame.
This represents one possible organization of the C stack frame. Usage of %ebp as a
frame pointer, the exact positions of the callee saved registers, and space for local
storage is implementation specific.
Figure 3-48: C Stack Frame

Base
Offset
Contents
___________________________________
%ebp
4n+8 _____________________
argument word n  High addresses


...
_____________________

8 _____________________
argument word 0 

4 _____________________
return address


%
ebp
0 
caller’s %ebp

___________________________________
%ebp
–4  x words local space: 
 automatic variables, 


temporaries,


%ebp
–4x 
etc.

______________________
%esp
12 ____________________

%esp
8 _____________________
caller’s %edi


4 _____________________
caller’s %esi

%
esp
0 
caller’s %ebx
 Low addresses
___________________________________

A C stack frame doesn’t normally change size during execution. The exception is
dynamically allocated stack memory, discussed below. By convention, a function
allocates automatic (local) variables in the middle of its frame and references them
as negative offsets from %ebp. Its incoming arguments reside in the previous
frame, referenced as positive offsets from %ebp. If necessary, a function saves the
values of %edi, %esi, and %ebx in the positions shown and restores their values
before returning to the caller. The positions may be different from the diagram
above, depending on which of these three registers the function saves and
restores.

Coding Examples

3-43

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 69

M
M
M

Variable Argument List
Previous sections describe the rules for passing arguments. Unfortunately, some
otherwise portable C programs depend on the argument passing scheme, implicitly assuming that 1) all arguments reside on the stack, and 2) arguments appear
in increasing order on the stack. Programs that make these assumptions never
have been portable, but they have worked on many machines, including the
Intel386. Nonetheless, portable C programs should use the facilities defined in the
header files <stdarg.h> or <varargs.h> to deal with variable argument lists.

Allocating Stack Space Dynamically
Unlike some other languages, C does not need dynamic stack allocation within a
stack frame. Frames are allocated dynamically on the program stack, depending
on program execution, but individual stack frames can have static sizes. Nonetheless, the architecture supports dynamic allocation for those languages that require
it, and the standard calling sequence and stack frame support it as well. Thus
languages that need dynamic stack frame sizes can call C functions, and vice
versa.
Figure 3-48 shows the layout of the C stack frame. The double line divides the
area referenced from %ebp from the area referenced from %esp. Dynamic space is
allocated below the line, as a downward growing heap whose size changes as
required. Typical C functions have no space in the heap. All areas above the heap
in the current frame have a known size to the compiler. Dynamic stack allocation
thus takes the following steps.
1 . Stack frames are word aligned; dynamic allocation should preserve this
property. Thus the program rounds (up) the desired byte count to a multiple of 4.
2 . The program decreases the stack pointer by the rounded byte count,
increasing its frame size. At this point, the ‘‘new’’ space resides just below
the register save area at the bottom of the stack.
3 . The program copies the register save area (three or fewer words) to the bottom of the stack, effectively moving the new space up into the frame.

3-44

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 70

NOTE

The register save area is reserved and should not be used for purposes outside of this document.

G

Even in the presence of signals, dynamic allocation is ‘‘safe.’’ If a signal interrupts
allocation, one of three things can happen.
The signal handler can return. The process then resumes the dynamic allocation from the point of interruption.
The signal handler can execute a non-local goto, or longjmp [see
setjmp(BA_LIB)]. This resets the process to a new context in a previous
stack frame, automatically discarding the dynamic allocation.
The process can terminate.
Regardless of when the signal arrives during dynamic allocation, the result is a
consistent (though possibly dead) process.
To illustrate, assume a program wants to allocate 50 bytes, and it has saved three
registers in the bottom of the frame. The first step is rounding 50 to 52, making it
a multiple of 4. Figure 3-49 shows how the stack frame changes.
Figure 3-49: Dynamic Stack Allocation

Original
_______________

0(%ebp)
arguments 


and


 automatic 
variables
_______________
12(%esp) _______________
 save area



0(%esp) _______________
3 words








 undefined







_______________

Intermediate
_______________
 arguments 


and


 automatic 
variables

________________
______________
 save area

 3 words

_______________
 +++++++++ 
 new space



52 bytes
 +++++++++ 
_______________


 undefined

_______________

Final
_______________
 arguments  0(%ebp)


and


 automatic 
 variables

_______________
 old save area 
 3 words

_______________

 +++++++++ 
 new space



52 bytes
 +++++++++ 
________________
______________ 12(%esp)


 save area

_______________
3 words
 0(%esp)

New space starts at 12(%esp). As described, every dynamic allocation in this
function will return a new area starting at 12(%esp), leaving previous heap
objects untouched (other functions could have different heap addresses).

Coding Examples

3-45

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 71

Consequently, the compiler should compute the absolute address for each area,
avoiding relative references. Otherwise, future allocations in the same frame
would destroy the heap’s integrity.
Existing stack objects reside at fixed offsets from the frame pointer (%ebp).
Dynamic allocation preserves those offsets, because the frame pointer does not
change and the objects relative to it do not move. Objects relative to the stack
pointer (%esp) move, but their %esp-relative positions do not change. Accordingly, compilers arrange not to publicize the absolute address of any object in the
bottom half of the stack frame (in a way that violates the scope rules). %esprelative references stay valid after dynamic allocation, but absolute addresses do
not.
No special code is needed to free dynamically allocated stack memory. The function return resets the stack pointer and removes the entire stack frame, including
the heap, from the stack. Naturally, a program should not reference heap objects
after they have gone out of scope.

3-46

LOW-LEVEL SYSTEM INFORMATION

DRAFT COPY
March 19, 1997
File: abi_386/chap3 (Delta 44.6)
386:adm.book:sum
Page: 72

4

OBJECT FILES

ELF Header

4-1
4-1

Machine Information

Sections

4-2
4-2

Special Sections

Symbol Table

4-3
4-3

Symbol Values

Relocation

4-4
4-4

Relocation Types

Table of Contents

i

DRAFT COPY
March 19, 1997
File: abi_386/Cchap4 (Delta 44.3)
386:adm.book:sum
Page: 73

ELF Header
Machine Information
For file identification in e_ident, the Intel386 architecture requires the following
values.
Figure 4-1: Intel386 Identification, e_ident

Position
Value
__________________________________

e_ident[EI_CLASS] ELFCLASS32
e_ident[EI_DATA]  ELFDATA2LSB
__________________________________


Processor identification resides in the ELF header’s e_machine member and must
have the value EM_386.
The ELF header’s e_flags member holds bit flags associated with the file. The
Intel386 architecture defines no flags; so this member contains zero.

ELF Header

4-1

DRAFT COPY
March 19, 1997
File: abi_386/chap4 (Delta 44.3)
386:adm.book:sum
Page: 74

Sections
Special Sections
Various sections hold program and control information. Sections in the list below
are used by the system and have the indicated types and attributes.
Figure 4-2: Special Sections

Name
Type
Attributes
___________________________________________________


.got
SHT_PROGBITS SHF_ALLOC + SHF_WRITE
.plt  SHT_PROGBITS  SHF_ALLOC + SHF_EXECINSTR
___________________________________________________



.got

This section holds the global offset table. See ‘‘Coding Examples’’
in Chapter 3 and ‘‘Global Offset Table’’ in Chapter 5 for more
information.

.plt

This section holds the procedure linkage table. See ‘‘Procedure
Linkage Table’’ in Chapter 5 for more information.

4-2

OBJECT FILES

DRAFT COPY
March 19, 1997
File: abi_386/chap4 (Delta 44.3)
386:adm.book:sum
Page: 75

Symbol Table
Symbol Values
If an executable file contains a reference to a function defined in one of its associated shared objects, the symbol table section for that file will contain an entry for
that symbol. The st_shndx member of that symbol table entry contains
SHN_UNDEF. This signals to the dynamic linker that the symbol definition for that
function is not contained in the executable file itself. If that symbol has been allocated a procedure linkage table entry in the executable file, and the st_value
member for that symbol table entry is non-zero, the value will contain the virtual
address of the first instruction of that procedure linkage table entry. Otherwise,
the st_value member contains zero. This procedure linkage table entry address
is used by the dynamic linker in resolving references to the address of the function. See ‘‘Function Addresses’’ in Chapter 5 for details.

Symbol Table

4-3

DRAFT COPY
March 19, 1997
File: abi_386/chap4 (Delta 44.3)
386:adm.book:sum
Page: 76

Relocation
Relocation Types
Relocation entries describe how to alter the following instruction and data fields
(bit numbers appear in the lower box corners).
Figure 4-3: Relocatable Fields

word32
31

word32

0

This specifies a 32-bit field occupying 4 bytes with arbitrary byte
alignment. These values use the same byte order as other word
values in the Intel386 architecture.

0x01020304

01

3

02

2

03

31

1

04

0
0

Calculations below assume the actions are transforming a relocatable file into
either an executable or a shared object file. Conceptually, the link editor merges
one or more relocatable files to form the output. It first decides how to combine
and locate the input files, then updates the symbol values, and finally performs
the relocation. Relocations applied to executable or shared object files are similar
and accomplish the same result. Descriptions below use the following notation.
A

This means the addend used to compute the value of the relocatable field.

B

This means the base address at which a shared object has been loaded into
memory during execution. Generally, a shared object file is built with a 0
base virtual address, but the execution address will be different. See ‘‘Program Header’’ in the System V ABI for more information about the base
address.

G

This means the offset into the global offset table at which the address of
the relocation entry’s symbol will reside during execution. See ‘‘Coding
Examples’’ in Chapter 3 and ‘‘Global Offset Table’’ in Chapter 5 for more
information.

4-4

OBJECT FILES

DRAFT COPY
March 19, 1997
File: abi_386/chap4 (Delta 44.3)
386:adm.book:sum
Page: 77

GOT

This means the address of the global offset table. See ‘‘Coding Examples’’
in Chapter 3 and ‘‘Global Offset Table’’ in Chapter 5 for more information.

L

This means the place (section offset or address) of the procedure linkage
table entry for a symbol. A procedure linkage table entry redirects a function call to the proper destination. The link editor builds the initial procedure linkage table, and the dynamic linker modifies the entries during
execution. See ‘‘Procedure Linkage Table’’ in Chapter 5 for more information.

P

This means the place (section offset or address) of the storage unit being
relocated (computed using r_offset).

S

This means the value of the symbol whose index resides in the relocation
entry.

A relocation entry’s r_offset value designates the offset or virtual address of the
first byte of the affected storage unit. The relocation type specifies which bits to
change and how to calculate their values. The Intel386 architecture uses only
Elf32_Rel relocation entries, the field to be relocated holds the addend. In all
cases, the addend and the computed result use the same byte order.
Figure 4-4: Relocation Types

Name
Value
Field
Calculation
________________________________________________

 none
R_386_NONE
0  none

R_386_32
1  word32  S + A



R_386_PC32
2  word32  S + A - P

R_386_GOT32
3  word32  G + A - P

R_386_PLT32

4  word32  L + A - P

 none
R_386_COPY
5  none
R_386_GLOB_DAT 
6  word32  S



R_386_JMP_SLOT 
7  word32  S
R_386_RELATIVE 
8  word32  B + A
R_386_GOTOFF

9  word32  S + A - GOT
 10  word32  GOT + A - P
R_386_GOTPC
________________________________________________




Some relocation types have semantics beyond simple calculation.
R_386_GOT32

This relocation type computes the distance from the base of
the global offset table to the symbol’s global offset table entry.
It additionally instructs the link editor to build a global offset
table.

Relocation

4-5

DRAFT COPY
March 19, 1997
File: abi_386/chap4 (Delta 44.3)
386:adm.book:sum
Page: 78

R_386_PLT32

This relocation type computes the address of the symbol’s
procedure linkage table entry and additionally instructs the
link editor to build a procedure linkage table.

R_386_COPY

The link editor creates this relocation type for dynamic linking. Its offset member refers to a location in a writable segment. The symbol table index specifies a symbol that should
exist both in the current object file and in a shared object.
During execution, the dynamic linker copies data associated
with the shared object’s symbol to the location specified by
the offset.

R_386_GLOB_DAT

This relocation type is used to set a global offset table entry to
the address of the specified symbol. The special relocation
type allows one to determine the correspondence between
symbols and global offset table entries.

R_386_JMP_SLOT

The link editor creates this relocation type for dynamic linking. Its offset member gives the location of a procedure linkage table entry. The dynamic linker modifies the procedure
linkage table entry to transfer control to the designated
symbol’s address [see ‘‘Procedure Linkage Table’’ in Chapter
5].

R_386_RELATIVE

The link editor creates this relocation type for dynamic linking. Its offset member gives a location within a shared object
that contains a value representing a relative address. The
dynamic linker computes the corresponding virtual address
by adding the virtual address at which the shared object was
loaded to the relative address. Relocation entries for this type
must specify 0 for the symbol table index.

R_386_GOTOFF

This relocation type computes the difference between a
symbol’s value and the address of the global offset table. It
additionally instructs the link editor to build the global offset
table.

R_386_GOTPC

This relocation type resembles R_386_PC32, except it uses the
address of the global offset table in its calculation. The symbol referenced in this relocation normally is
_GLOBAL_OFFSET_TABLE_, which additionally instructs the
link editor to build the global offset table.

4-6

OBJECT FILES

DRAFT COPY
March 19, 1997
File: abi_386/chap4 (Delta 44.3)
386:adm.book:sum
Page: 79

5

PROGRAM LOADING AND
DYNAMIC LINKING

Program Loading

5-1

Dynamic Linking

5-5
5-5
5-5
5-6
5-7
5-10

Dynamic Section
Global Offset Table
Function Addresses
Procedure Linkage Table
Program Interpreter

Table of Contents

i

DRAFT COPY
March 19, 1997
File: abi_386/Cchap5 (Delta 44.3)
386:adm.book:sum
Page: 80

Program Loading
As the system creates or augments a process image, it logically copies a file’s segment to a virtual memory segment. When—and if—the system physically reads
the file depends on the program’s execution behavior, system load, and so on. A
process does not require a physical page unless it references the logical page during execution, and processes commonly leave many pages unreferenced. Therefore delaying physical reads frequently obviates them, improving system performance. To obtain this efficiency in practice, executable and shared object files
must have segment images whose file offsets and virtual addresses are congruent,
modulo the page size.
Virtual addresses and file offsets for the Intel386 architecture segments are
congruent modulo 4 KB (0x1000) or larger powers of 2. Because 4 KB is the maximum page size, the files will be suitable for paging regardless of physical page
size.
Figure 5-1: Executable File

File Offset ______________________
File
Virtual Address


0 ______________________
ELF header


Program
header table 
_ _____________________
Other information 
_ _____________________
 0x8048100
0x100 
Text segment


...


0x2be00 bytes
 0x8073eff
_ _____________________

 0x8074f00
0x2bf00
Data segment


...


0x4e00 bytes
_ _____________________
 0x8079cff
0x30d00  Other information 
...
_ _____________________


Program Loading

5-1

DRAFT COPY
March 19, 1997
File: abi_386/chap5 (Delta 44.3)
386:adm.book:sum
Page: 81

Figure 5-2: Program Header Segments

Member
Text
Data
__________________________________________

p_type
PT_LOAD 
PT_LOAD
p_offset 
0x100 
0x2bf00


p_vaddr  0x8048100 
0x8074f00
p_paddr  unspecified 
unspecified
p_filesz 
0x2be00 
0x4e00
p_memsz 
0x2be00 
0x5e24
p_flags  PF_R + PF_X  PF_R + PF_W + PF_X


p_align 
0x1000 
0x1000
__________________________________________

Although the example’s file offsets and virtual addresses are congruent modulo
4 KB for both text and data, up to four file pages hold impure text or data
(depending on page size and file system block size).
The first text page contains the ELF header, the program header table, and
other information.
The last text page holds a copy of the beginning of data.
The first data page has a copy of the end of text.
The last data page may contain file information not relevant to the running
process.
Logically, the system enforces the memory permissions as if each segment were
complete and separate; segments’ addresses are adjusted to ensure each logical
page in the address space has a single set of permissions. In the example above,
the region of the file holding the end of text and the beginning of data will be
mapped twice: at one virtual address for text and at a different virtual address for
data.
The end of the data segment requires special handling for uninitialized data,
which the system defines to begin with zero values. Thus if a file’s last data page
includes information not in the logical memory page, the extraneous data must be
set to zero, not the unknown contents of the executable file. ‘‘Impurities’’ in the
other three pages are not logically part of the process image; whether the system
expunges them is unspecified. The memory image for this program follows,
assuming 4 KB (0x1000) pages.

5-2

PROGRAM LOADING AND DYNAMIC LINKING

DRAFT COPY
March 19, 1997
File: abi_386/chap5 (Delta 44.3)
386:adm.book:sum
Page: 82

Figure 5-3: Process Image Segments

Virtual Address ___________________
Contents
Segment

0x8048000  Header padding


0x100 bytes
_ __________________

0x8048100  Text segment




 Text
...




0x2be00 bytes
_ __________________


0x8073f00 
Data padding


0
x
1
0
0
bytes
___________________
___________________

0x8074000 
Text padding


0
x
f
0
0
bytes
_ __________________
0x8074f00  Data segment





...




0x4e00 bytes
_ __________________

0x8079d00  Uninitialized data 
___________________
0x1024 zero bytes 


0x807ad24 
Page padding

0x2dc zero bytes 
_ __________________

Data

One aspect of segment loading differs between executable files and shared objects.
Executable file segments typically contain absolute code (see ‘‘Coding Examples’’
in Chapter 3). To let the process execute correctly, the segments must reside at the
virtual addresses used to build the executable file. Thus the system uses the
p_vaddr values unchanged as virtual addresses.
On the other hand, shared object segments typically contain position-independent
code. This lets a segment’s virtual address change from one process to another,
without invalidating execution behavior. Though the system chooses virtual
addresses for individual processes, it maintains the segments’ relative positions.
Because position-independent code uses relative addressing between segments,
the difference between virtual addresses in memory must match the difference
between virtual addresses in the file. The following table shows possible shared
object virtual address assignments for several processes, illustrating constant relative positioning. The table also illustrates the base address computations.

Program Loading

5-3

DRAFT COPY
March 19, 1997
File: abi_386/chap5 (Delta 44.3)
386:adm.book:sum
Page: 83

Figure 5-4: Example Shared Object Segment Addresses

Source
Text
Data
Base Address
___________________________________________________

File
0x200 
0x2a400 
0x0
Process 1  0x80000200  0x8002a400  0x80000000



Process 2  0x80081200  0x800ab400  0x80081000
Process 3  0x900c0200  0x900ea400  0x900c0000
Process
4  0x900c6200  0x900f0400  0x900c6000
___________________________________________________

5-4

PROGRAM LOADING AND DYNAMIC LINKING

DRAFT COPY
March 19, 1997
File: abi_386/chap5 (Delta 44.3)
386:adm.book:sum
Page: 84

Dynamic Linking
Dynamic Section
Dynamic section entries give information to the dynamic linker. Some of this
information is processor-specific, including the interpretation of some entries in
the dynamic structure.
On the Intel386 architecture, this entry’s d_ptr member gives the
address of the first entry in the global offset table. As mentioned
below, the first three global offset table entries are reserved, and
two are used to hold procedure linkage table information.

DT_PLTGOT

Global Offset Table
Position-independent code cannot, in general, contain absolute virtual addresses.
Global offset tables hold absolute addresses in private data, thus making the
addresses available without compromising the position-independence and sharability of a program’s text. A program references its global offset table using
position-independent addressing and extracts absolute values, thus redirecting
position-independent references to absolute locations.
Initially, the global offset table holds information as required by its relocation
entries [see ‘‘Relocation’’ in Chapter 4]. After the system creates memory segments for a loadable object file, the dynamic linker processes the relocation entries,
some of which will be type R_386_GLOB_DAT referring to the global offset table.
The dynamic linker determines the associated symbol values, calculates their
absolute addresses, and sets the appropriate memory table entries to the proper
values. Although the absolute addresses are unknown when the link editor builds
an object file, the dynamic linker knows the addresses of all memory segments
and can thus calculate the absolute addresses of the symbols contained therein.
If a program requires direct access to the absolute address of a symbol, that symbol will have a global offset table entry. Because the executable file and shared
objects have separate global offset tables, a symbol’s address may appear in
several tables. The dynamic linker processes all the global offset table relocations
before giving control to any code in the process image, thus ensuring the absolute
addresses are available during execution.

Dynamic Linking

5-5

DRAFT COPY
March 19, 1997
File: abi_386/chap5 (Delta 44.3)
386:adm.book:sum
Page: 85

The table’s entry zero is reserved to hold the address of the dynamic structure,
referenced with the symbol _DYNAMIC. This allows a program, such as the
dynamic linker, to find its own dynamic structure without having yet processed
its relocation entries. This is especially important for the dynamic linker, because
it must initialize itself without relying on other programs to relocate its memory
image. On the Intel386 architecture, entries one and two in the global offset table
also are reserved. ‘‘Procedure Linkage Table’’ below describes them.
The system may choose different memory segment addresses for the same shared
object in different programs; it may even choose different library addresses for different executions of the same program. Nonetheless, memory segments do not
change addresses once the process image is established. As long as a process
exists, its memory segments reside at fixed virtual addresses.
A global offset table’s format and interpretation are processor-specific. For the
Intel386 architecture, the symbol _GLOBAL_OFFSET_TABLE_ may be used to access
the table.
Figure 5-5: Global Offset Table

extern Elf32_Addr

_GLOBAL_OFFSET_TABLE_[];

The symbol _GLOBAL_OFFSET_TABLE_ may reside in the middle of the .got section, allowing both negative and non-negative ‘‘subscripts’’ into the array of
addresses.

Function Addresses
References to the address of a function from an executable file and the shared
objects associated with it might not resolve to the same value. References from
within shared objects will normally be resolved by the dynamic linker to the virtual address of the function itself. References from within the executable file to a
function defined in a shared object will normally be resolved by the link editor to
the address of the procedure linkage table entry for that function within the executable file.
To allow comparisons of function addresses to work as expected, if an executable
file references a function defined in a shared object, the link editor will place the
address of the procedure linkage table entry for that function in its associated
symbol table entry. [See ‘‘Symbol Values’’ in Chapter 4]. The dynamic linker

5-6

PROGRAM LOADING AND DYNAMIC LINKING

DRAFT COPY
March 19, 1997
File: abi_386/chap5 (Delta 44.3)
386:adm.book:sum
Page: 86

treats such symbol table entries specially. If the dynamic linker is searching for a
symbol, and encounters a symbol table entry for that symbol in the executable file,
it normally follows the rules below.
1 . If the st_shndx member of the symbol table entry is not SHN_UNDEF, the
dynamic linker has found a definition for the symbol and uses its st_value
member as the symbol’s address.
2 . If the st_shndx member is SHN_UNDEF and the symbol is of type STT_FUNC
and the st_value member is not zero, the dynamic linker recognizes this
entry as special and uses the st_value member as the symbol’s address.
3 . Otherwise, the dynamic linker considers the symbol to be undefined within
the executable file and continues processing.
Some relocations are associated with procedure linkage table entries. These
entries are used for direct function calls rather than for references to function
addresses. These relocations are not treated in the special way described above
because the dynamic linker must not redirect procedure linkage table entries to
point to themselves.

Procedure Linkage Table
Much as the global offset table redirects position-independent address calculations
to absolute locations, the procedure linkage table redirects position-independent
function calls to absolute locations. The link editor cannot resolve execution
transfers (such as function calls) from one executable or shared object to another.
Consequently, the link editor arranges to have the program transfer control to
entries in the procedure linkage table. On the Intel386 architecture, procedure
linkage tables reside in shared text, but they use addresses in the private global
offset table. The dynamic linker determines the destinations’ absolute addresses
and modifies the global offset table’s memory image accordingly. The dynamic
linker thus can redirect the entries without compromising the positionindependence and sharability of the program’s text. Executable files and shared
object files have separate procedure linkage tables.

Dynamic Linking

5-7

DRAFT COPY
March 19, 1997
File: abi_386/chap5 (Delta 44.3)
386:adm.book:sum
Page: 87

Figure 5-6: Absolute Procedure Linkage Table

.PLT0: pushl got_plus_4
jmp
*got_plus_8
nop; nop
nop; nop
.PLT1: jmp
*name1_in_GOT
pushl $offset
jmp
.PLT0@PC
.PLT2: jmp
*name2_in_GOT
pushl $offset
jmp
.PLT0@PC
...

Figure 5-7: Position-Independent Procedure Linkage Table

.PLT0: pushl 4(%ebx)
jmp
*8(%ebx)
nop; nop
nop; nop
.PLT1: jmp
*name1@GOT(%ebx)
pushl $offset
jmp
.PLT0@PC
.PLT2: jmp
*name2@GOT(%ebx)
pushl $offset
jmp
.PLT0@PC
...

5-8

PROGRAM LOADING AND DYNAMIC LINKING

DRAFT COPY
March 19, 1997
File: abi_386/chap5 (Delta 44.3)
386:adm.book:sum
Page: 88

NOTE

As the figures show, the procedure linkage table instructions use different
operand addressing modes for absolute code and for position-independent
code. Nonetheless, their interfaces to the dynamic linker are the same.

Following the steps below, the dynamic linker and the program ‘‘cooperate’’ to
resolve symbolic references through the procedure linkage table and the global
offset table.
1 . When first creating the memory image of the program, the dynamic linker
sets the second and the third entries in the global offset table to special
values. Steps below explain more about these values.
2 . If the procedure linkage table is position-independent, the address of the
global offset table must reside in %ebx. Each shared object file in the process image has its own procedure linkage table, and control transfers to a
procedure linkage table entry only from within the same object file. Consequently, the calling function is responsible for setting the global offset table
base register before calling the procedure linkage table entry.
3 . For illustration, assume the program calls name1, which transfers control to
the label .PLT1.
4 . The first instruction jumps to the address in the global offset table entry for
name1. Initially, the global offset table holds the address of the following
pushl instruction, not the real address of name1.
5 . Consequently, the program pushes a relocation offset (offset) on the stack.
The relocation offset is a 32-bit, non-negative byte offset into the relocation
table. The designated relocation entry will have type R_386_JMP_SLOT,
and its offset will specify the global offset table entry used in the previous
jmp instruction. The relocation entry also contains a symbol table index,
thus telling the dynamic linker what symbol is being referenced, name1 in
this case.
6 . After pushing the relocation offset, the program then jumps to .PLT0, the
first entry in the procedure linkage table. The pushl instruction places the
value of the second global offset table entry (got_plus_4 or 4(%ebx)) on the
stack, thus giving the dynamic linker one word of identifying information.
The program then jumps to the address in the third global offset table entry
(got_plus_8 or 8(%ebx)), which transfers control to the dynamic linker.
7 . When the dynamic linker receives control, it unwinds the stack, looks at the
designated relocation entry, finds the symbol’s value, stores the ‘‘real’’
address for name1 in its global offset table entry, and transfers control to the
desired destination.

Dynamic Linking

5-9

DRAFT COPY
March 19, 1997
File: abi_386/chap5 (Delta 44.3)
386:adm.book:sum
Page: 89

8 . Subsequent executions of the procedure linkage table entry will transfer
directly to name1, without calling the dynamic linker a second time. That
is, the jmp instruction at .PLT1 will transfer to name1, instead of ‘‘falling
through’’ to the pushl instruction.
The LD_BIND_NOW environment variable can change dynamic linking behavior. If
its value is non-null, the dynamic linker evaluates procedure linkage table entries
before transferring control to the program. That is, the dynamic linker processes
relocation entries of type R_386_JMP_SLOT during process initialization. Otherwise, the dynamic linker evaluates procedure linkage table entries lazily, delaying
symbol resolution and relocation until the first execution of a table entry.
NOTE

Lazy binding generally improves overall application performance, because
unused symbols do not incur the dynamic linking overhead. Nevertheless,
two situations make lazy binding undesirable for some applications. First, the
initial reference to a shared object function takes longer than subsequent
calls, because the dynamic linker intercepts the call to resolve the symbol.
Some applications cannot tolerate this unpredictability. Second, if an error
occurs and the dynamic linker cannot resolve the symbol, the dynamic linker
will terminate the program. Under lazy binding, this might occur at arbitrary
times. Once again, some applications cannot tolerate this unpredictability. By
turning off lazy binding, the dynamic linker forces the failure to occur during
process initialization, before the application receives control.

Program Interpreter

G

There is one valid program interpreter for programs conforming to the Intel386
ABI:

G

/usr/lib/libc.so.1

5-10

G

PROGRAM LOADING AND DYNAMIC LINKING

DRAFT COPY
March 19, 1997
File: abi_386/chap5 (Delta 44.3)
386:adm.book:sum
Page: 90

6

LIBRARIES

Shared Library Names

6-1

C Library

6-2
6-2
6-3
6-4
6-4

Additional Entry Points
Support Routines
Global Data Symbols
Application Constraints

System Data Interfaces
Data Definitions
Reentrancy Considerations

X Window Data Definitions
Motif 1.2 Data Definitions
TCP/IP Data Definitions

Table of Contents

6-5
6-5
6-5
6-127
6-192
6-269

i

DRAFT COPY
March 19, 1997
File: abi_386/Cchap6 (Delta 44.4)
386:adm.book:sum
Page: 91

Shared Library Names

M

The version number of the libraries named in the System V Generic ABI is specified
below.

M
M

Figure 6-1: Shared Library Names

M

Library
Reference Name
______________________
libc.so.1
libthread.so.1
libdl.so.1
libnsl.so.1
libX11.so.5.0
libXt.so.5.0
libXext.so.5.0
libXm.so.1.2
l
ibMrm.so.1.2
______________________

Shared Library Names

M
M
M
M
M
M
M
M
M
M
M
M

6-1

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 92

C Library

M

Additional Entry Points
The following routines are included in the libc library to provide entry points for
the required source-level interface listed in the System V ABI. A description and
syntax symmary for each function follows the table.
Figure 6-2: libc Additional Required Entry Points

_fxstat
_nuname

_lxstat _xmknod _xstat nuname

int _fxstat(int, int, struct stat *);
The semantics of this function are identical to those of the
fstat(BA_OS) function described in the System V Interface
Definition, Edition 4. Its only difference is that it requires an extra
first argument whose value must be 2.
int _lxstat(int, char *, struct stat *);
The semantics of this function are identical to those of the
lstat(BA_OS) function described in the System V Interface
Definition, Edition 4. Its only difference is that it requires an extra
first argument whose value must be 2.
int nuname(struct utsname *);
The semantics and syntax of this function are identical to those of
the uname(BA_OS) function described in the System V Interface
Definition, Edition 4. The symbol _nuname is also available with
the same semantics.
int _xmknod(int, char *, mode_t, dev_t);
The semantics of this function are identical to those of the
mknod(BA_OS) function described in the System V Interface
Definition, Edition 4. Its only difference is that it requires an extra
first argument whose value must be 2.
int _xstat(int, char *, struct stat *);
The semantics of this function are identical to those of the
stat(BA_OS) function described in the System V Interface

6-2

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 93

M

Definition, Edition 4. Its only difference is that it requires an extra
first argument whose value must be 2.

Support Routines
Besides operating system services, libc contains the following processor-specific
support routines.
Figure 6-3: libc, Support Routines

_fpstart

_ _fpstart

sbrk

_sbrk

char *sbrk(int incr);
This function adds incr bytes to the break value and changes the
allocated space accordingly. Incr can be negative, in which case
the amount of allocated space is decreased. The break value is the
address of the first allocation beyond the end of the data segment.
The amount of allocated space increases as the break value
increases. Newly allocated space is set to zero. If, however, the
same memory space is reallocated to the same process, its contents are undefined. Upon successful completion, sbrk returns
the old break value. Otherwise, it returns -1 and sets errno to
indicate the error. The symbol _sbrk is also available with the
same semantics.
void _ _fpstart(void);
This function calls _fpstart(), to initialize the floating-point
environment.
void _fpstart(void);
This function initializes the floating-point execution environment.
It sets _fp_hw to the appropriate value. It sets the rounding mode
to ‘‘nearest.’’ It also resets the Intel387 control word to the default
state.

C Library

6-3

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 94

M

Global Data Symbols
The libc library requires that some globel external data objects be defined for the
routines to work properly. In addition to the corresponding data symbols listed in
the System V ABI, the following symbols must be provided in the system library
on all ABI-conforming systems implemented with the Intel386 architecture.
Declarations for the data objects listed below can be found in the Data Definitions
section of this chapter or immediately following the table.

M

Figure 6-4: libc, Global External Data Symbols

_ _flt_rounds

_fp_hw

_ _huge_val

extern int _fp_hw;
This variable describes the floating-point hardware available. If
the value is zero, no floating-point support is present. If the value
is 1, the floating-point support is provided by an Intel387 software
emulator. If the value is 2, an 80287 chip is available. If the value
is 3, an Intel387 chip is available. System software sets the value
appropriately, before transferring control to main.

Application Constraints
As described above, libc provides symbols for applications. In a few cases, however, an application is obliged to provide symbols for the library. In addition to
the application-provided symbols listed in this section of the System V ABI, conforming applications on the Intel386 architecture are also required to provide the
following symbols.
extern _end;
This symbol refers neither to a routine nor to a location with
interesting contents. Instead, its address must correspond to the
beginning of a program’s dynamic allocation area, called the
heap. Typically, the heap begins immediately after the data segment of the program’s executable file.
extern const int _lib_version;
This variable’s value specifies the compilation and execution
mode for the program. If the value is zero, the program wants to
preserve the semantics of older (pre-ANSI) C, where conflicts
exist with ANSI. Otherwise, the value is non-zero, and the program wants ANSI C semantics.

6-4

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 95

M

System Data Interfaces
Data Definitions
This section contains standard data definitions that describe system data. These
files are referred to by their names in angle brackets: <name.h> and <sys/name.h>.
Included in these data definitions are macro definitions and data definitions.
The data objects described in this section are part of the interface between an ABIconforming application and the underlying ABI-conforming system where it will
run. While an ABI-conforming system must provide these interfaces, it is not
required to contain the actual data definitions referenced here. Programmers
should observe that the sources of the structures defined in these data definitions
are defined in SVID.
ANSI C serves as the ABI reference programming language, and data definitions
are specificed in ANSI C format. The C language is used here as a convenient
notation. Using a C language description of these data objects does not preclude
their use by other programming languages.

M

Reentrancy Considerations

M

New conventions have been added to accomodate the new requirements of reentrancy. Some historic binary code sequences are inherently non-reentrant. Unless
great care is taken, multi-threaded applications cannot safely use such sequences.
The most portable (i.e. those guaranteed to work in all cases) are those that are
marked as reentrant in this chapter. For the ABI, this sometimes requires that two
definitions exist for these interfaces, one that is reentrant and one that is not.
These are indicated by comments that define which of the alternate definitions is
reentrant. These alternatives are not selected at run-time, but are intended to be
bound at application build time.

M
M
M
M
M
M
M
M

NOTE

All information presented in the figures marked with * are new to the Fourth
Edition of the psABI.

System Data Interfaces

M

6-5

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 96

Figure 6-5: <aio.h> *

struct

aiocb {
int
aio_fildes;
volatile void* aio_buf;
size_t
aio_nbytes;
off_t
aio_offset;
int
aio_reqprio;
struct sigevent aio_sigevent;
int
aio_lio_opcode;
ssize_t
;
int
;
int
;
void
;
int
;

} ;
#define AIO_CANCELED
(0)
#define AIO_ALLDONE
(1)
#define AIO_NOTCANCELED (2)
#define LIO_NOWAIT
#define LIO_WAIT
#define LIO_NOP
#define LIO_READ
#define LIO_WRITE

(0)
(1)
(0)
(1)
(2)

Figure 6-6: <assert.h>

extern void _ _assert(const char *, const char *, int);
#define assert(EX) (void)((EX)||(_ _assert(#EX, _ _FILE_ _, _ _LINE_ _), 0))

6-6

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 97

Figure 6-7: <ctype.h>

#define _U
#define _L
#define _N
#define _S
#define _P
#define _C
#define _B
#define _X

01
02
04
010
020
040
0100
0200

extern unsigned char

_ _ctype[];

#define isalpha(c) ((_ _ctype+1)[c]&(_U|_L))
#define isupper(c) ((_ _ctype+1)[c]&_U)
#define islower(c) ((_ _ctype+1)[c]&_L)
#define isdigit(c) ((_ _ctype+1)[c]&_N)
#define isxdigit(c) ((_ _ctype+1)[c]&_X)
#define isalnum(c) ((_ _ctype+1)[c]&(_U|_L|_N))
#define isspace(c) ((_ _ctype+1)[c]&_S)
#define ispunct(c) ((_ _ctype+1)[c]&_P)
#define isprint(c) ((_ _ctype+1)[c]&(_P|_U|_L|_N|_B))
#define isgraph(c) ((_ _ctype+1)[c]&(_P|_U|_L|_N))
#define iscntrl(c) ((_ _ctype+1)[c]&_C)
#define isascii(c) (!((c)&˜0177))
#define _toupper(c) ((_ _ctype+258)[c])
#define _tolower(c) ((_ _ctype+258)[c])
#define toascii(c) ((c)&0177)

CAUTION

The data definitions in ctype.h are moved to Level 2 as of January 1, 1993.
In order to correctly function in an internationalized environment, applications are encouraged to use the functions in libc instead.

System Data Interfaces

M

6-7

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 98

Figure 6-8: <dirent.h>

typedef struct {
int
int
int
char
} DIR;

dd_fd;
dd_loc;
dd_size;
*dd_buf;

struct dirent {
ino_t
d_ino;
off_t
d_off;
unsigned short
d_reclen;
char
d_name[1];
};

Figure 6-9: <dlfcn.h> *

#define RTLD_LAZY
#define RTLD_NOW
#define RTLD_GLOBAL

1
2
4

6-8

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 99

Figure 6-10: <elf.h> *, Part 1 of 6

#define ELF32_FSZ_ADDR
#define ELF32_FSZ_HALF
#define ELF32_FSZ_OFF
#define ELF32_FSZ_SWORD
#define ELF32_FSZ_WORD
#define EI_NIDENT

4
2
4
4
4

16

typedef struct {
unsigned chare_ident[EI_NIDENT];
Elf32_Half
e_type;
Elf32_Half
e_machine;
Elf32_Word
e_version;
Elf32_Addr
e_entry;
Elf32_Off
e_phoff;
Elf32_Off
e_shoff;
Elf32_Word
e_flags;
Elf32_Half
e_ehsize;
Elf32_Half
e_phentsize;
Elf32_Half
e_phnum;
Elf32_Half
e_shentsize;
Elf32_Half
e_shnum;
Elf32_Half
e_shstrndx;
} Elf32_Ehdr;
#define ELFMAG0
#define ELFMAG1
#define ELFMAG2
#define ELFMAG3
#define ELFMAG
#define SELFMAG

0x7f
’E’
’L’
’F’
"\177ELF"
4

System Data Interfaces

6-9

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 100

Figure 6-11: <elf.h> *, Part 2 of 6

#define EI_MAG0
#define EI_MAG1
#define EI_MAG2
#define EI_MAG3
#define EI_CLASS
#define EI_DATA
#define EI_VERSION
#define EI_PAD

0
1
2
3
4
5
6
7

#define ELFCLASSNONE
#define ELFCLASS32
#define ELFCLASS64
#define ELFCLASSNUM
#define ELFDATANONE
#define ELFDATA2LSB
#define ELFDATA2MSB
#define ELFDATANUM

0
1
2
3
0
1
2
3

#define ET_NONE
#define ET_REL
#define ET_EXEC
#define ET_DYN
#define ET_CORE
#define ET_NUM

0
1
2
3
4
5

#define
#define

0xff00
0xffff

ET_LOPROC
ET_HIPROC

#define EM_NONE
#define EM_M32
#define EM_SPARC
#define EM_386
#define EM_68K
#define EM_88K
#define EM_486
#define EM_860
#define EM_NUM

0
1
2
3
4
5
6
7
8

6-10

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 101

Figure 6-12: <elf.h> *, Part 3 of 6

#define EV_NONE
#define EV_CURRENT
#define EV_NUM
typedef struct {
Elf32_Word
Elf32_Off
Elf32_Addr
Elf32_Addr
Elf32_Word
Elf32_Word
Elf32_Word
Elf32_Word
} Elf32_Phdr;

0
1
2

p_type;
p_offset;
p_vaddr;
p_paddr;
p_filesz;
p_memsz;
p_flags;
p_align;

#define PT_NULL
#define PT_LOAD
#define PT_DYNAMIC
#define PT_INTERP
#define PT_NOTE
#define PT_SHLIB
#define PT_PHDR
#define PT_NUM

0
1
2
3
4
5
6
7

#define PT_LOPROC
#define PT_HIPROC

0x70000000
0x7fffffff

#define PF_R
#define PF_W
#define PF_X

0x4
0x2
0x1

#define PF_MASKPROC 0xf0000000

System Data Interfaces

6-11

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 102

Figure 6-13: <elf.h> *, Part 4 of 6

typedef struct {
Elf32_Word
Elf32_Word
Elf32_Word
Elf32_Addr
Elf32_Off
Elf32_Word
Elf32_Word
Elf32_Word
Elf32_Word
Elf32_Word
} Elf32_Shdr;

sh_name;
sh_type;
sh_flags;
sh_addr;
sh_offset;
sh_size;
sh_link;
sh_info;
sh_addralign;
sh_entsize;

#define SHT_NULL
#define SHT_PROGBITS
#define SHT_SYMTAB
#define SHT_STRTAB
#define SHT_RELA
#define SHT_HASH
#define SHT_DYNAMIC
#define SHT_NOTE
#define SHT_NOBITS
#define SHT_REL
#define SHT_SHLIB
#define SHT_DYNSYM
#define SHT_NUM

0
1
2
3
4
5
6
7
8
9
10
11
12

#define SHT_LOUSER 0x80000000
#define SHT_HIUSER 0xffffffff
#define
SHT_LOPROC
0x70000000
#define
SHT_HIPROC
0x7fffffff
#define SHF_MASKPROC
0xf0000000
#define SHF_WRITE
#define SHF_ALLOC
#define SHF_EXECINSTR

0x1
0x2
0x4

6-12

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 103

Figure 6-14: <elf.h> *, Part 5 of 6

#define SHN_UNDEF
#define SHN_LORESERVE
#define SHN_ABS
#define SHN_COMMON
#define SHN_HIRESERVE
#define SHN_LOPROC
#define SHN_HIPROC

0
0xff00
0xfff1
0xfff2
0xffff
0xff00
0xff1f

typedef struct {
Elf32_Word
Elf32_Addr
Elf32_Word
unsigned char
unsigned char
Elf32_Half
} Elf32_Sym;

st_name;
st_value;
st_size;
st_info;
st_other;
st_shndx;

#define STN_UNDEF

0

#define ELF32_ST_BIND(info)
((info) >> 4)
#define ELF32_ST_TYPE(info)
((info) & 0xf)
#define ELF32_ST_INFO(bind,type) (((bind)<<4)+((type)&0xf))
#define STB_LOCAL
#define STB_GLOBAL
#define STB_WEAK
#define STB_NUM
#define STB_LOPROC
#define STB_HIPROC

0
1
2
3
13
15

System Data Interfaces

6-13

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 104

Figure 6-15: <elf.h> *, Part 6 of 6

#define STT_NOTYPE 0
#define STT_OBJECT 1
#define STT_FUNC
2
#define STT_SECTION 3
#define STT_FILE
4
#define STT_NUM
5
#define STT_LOPROC 13
#define STT_HIPROC 15
typedef struct {
Elf32_Addr
Elf32_Word
} Elf32_Rel;

r_offset;
r_info;

typedef struct {
Elf32_Addr
Elf32_Word
Elf32_Sword
} Elf32_Rela;

r_offset;
r_info;
r_addend;

#define ELF32_R_SYM(info) ((info)>>8)
#define ELF32_R_TYPE(info) ((unsigned char)(info))
#define ELF32_R_INFO(sym,type) (((sym)<<8)+(unsigned char)(type))

6-14

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 105

Figure 6-16: <errno.h>, Part 1 of 3

#define EPERM
#define ENOENT
#define ESRCH
#define EINTR
#define EIO
#define ENXIO
#define E2BIG
#define ENOEXEC
#define EBADF
#define ECHILD
#define EAGAIN
#define ENOMEM
#define EACCES
#define EFAULT
#define ENOTBLK
#define EBUSY
#define EEXIST
#define EXDEV
#define ENODEV
#define ENOTDIR
#define EISDIR
#define EINVAL
#define ENFILE
#define EMFILE
#define ENOTTY
#define ETXTBSY
#define EFBIG

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27

System Data Interfaces

6-15

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 106

Figure 6-17: <errno.h>, Part 2 of 3

#define ENOSPC
#define ESPIPE
#define EROFS
#define EMLINK
#define EPIPE
#define EDOM
#define ERANGE
#define ENOMSG
#define EIDRM
#define ECHRNG
#define EL2NSYNC
#define EL3HLT
#define EL3RST
#define ELNRNG
#define EUNATCH
#define ENOCSI
#define EL2HLT
#define EDEADLK
#define ENOLCK
#define ENOSTR
#define ENODATA
#define ETIME
#define ENOSR
#define ENONET
#define ENOPKG
#define EREMOTE
#define ENOLINK

28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
60
61
62
63
64
65
66
67

6-16

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 107

Figure 6-18: <errno.h>, Part 3 of 3

#define EADV
#define ESRMNT
#define ECOMM
#define EPROTO
#define EMULTIHOP
#define EBADMSG
#define ENAMETOOLONG
#define EOVERFLOW
#define ENOTUNIQ
#define EBADFD
#define EREMCHG
#define ENOSYS
#define ELOOP
#define ERESTART
#define ESTRPIPE
#define ENOTEMPTY
#define EUSERS
#define ECONNABORTED
#define CONNRESET
#define ECONNREFUSED
#define EINPROGRESS
#define ESTALE
#define ECANCELED

68
69
70
71
74
77
78
79
80
81
82
89
90
91
92
93
94
130
131

G
G
G
M

146
150
151
158

M

/* Non-reentrant */
extern int errno;

M
M

/* Reentrant */
#define errno
(*__thr_errno())

M
M

System Data Interfaces

6-17

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 108

Figure 6-19: <fcntl.h>, Part 1 of 2

#define O_RDONLY
#define O_WRONLY
#define O_RDWR
#define O_NDELAY
#define O_APPEND
#define O_SYNC
#define O_NONBLOCK
#define O_CREAT
#define O_TRUNC
#define O_EXCL
#define O_NOCTTY

0
1
2
0x04
0x08
0x10
0x80
0x100
0x200
0x400
0x800

#define F_DUPFD
#define F_GETFD
#define F_SETFD
#define F_GETFL
#define F_SETFL
#define F_GETLK
#define F_SETLK
#define F_SETLKW

0
1
2
3
4
14
6
7

6-18

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 109

Figure 6-20: <fcntl.h>, Part 2 of 2

typedef struct flock {
short l_type;
short l_whence;
off_t l_start;
off_t l_len;
long l_sysid;
pid_t l_pid;
long pad[4];
} flock_t;
#define F_RDLCK
#define F_WRLCK
#define F_UNLCK

01
02
03

#define O_ACCMODE
#define FD_CLOEXEC

3
1

System Data Interfaces

6-19

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 110

Figure 6-21: <float.h>, Single-Precision

extern int
_ _flt_rounds;
#define FLT_ROUNDS
_ _flt_rounds
#define FLT_RADIX
#define FLT_MANT_DIG
#define FLT_EPSILON
#define FLT_DIG
#define FLT_MIN_EXP
#define FLT_MIN
#define FLT_MIN_10_EXP
#define FLT_MAX_EXP
#define FLT_MAX
#define FLT_MAX_10_EXP

2
24
1.19209290E-07F
6
(-125)
1.17549435E-38F
(-37)
(+128)
3.40282347E+38F
(+38)

Figure 6-22: <float.h>, Double-Precision

#define DBL_MANT_DIG
#define DBL_EPSILON
#define DBL_DIG
#define DBL_MIN_EXP
#define DBL_MIN
#define DBL_MIN_10_EXP
#define DBL_MAX_EXP
#define DBL_MAX
#define DBL_MAX_10_EXP

53
2.2204460492503131E-16
15
(-1021)
2.2250738585072014E-308
(-307)
(+1024)
1.7976931348623157E+308
(+308)

6-20

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 111

Figure 6-23: <float.h>, Extended-Precision

#define LDBL_MANT_DIG
#define LDBL_EPSILON
#define LDBL_DIG
#define LDBL_MIN_EXP
#define LDBL_MIN
#define LDBL_MIN_10_EXP
#define LDBL_MAX_EXP
#define LDBL_MAX
#define LDBL_MAX_10_EXP

G
G
G
G
G
G
G
G
G

64
1.084202172485504434e-19
18
-16381
3.362103143112093506e-4932
-4931
16384
1.189731495347231765e+4932
4932

Figure 6-24: <fmtmsg.h>, Part 1 of 2

#define MM_NULL

0L

#define MM_HARD
#define MM_SOFT
#define MM_FIRM
#define MM_RECOVER
#define MM_NRECOV
#define MM_APPL
#define MM_UTIL
#define MM_OPSYS
#define MM_PRINT
#define MM_CONSOLE

0x00000001L
0x00000002L
0x00000004L
0x00000100L
0x00000200L
0x00000008L
0x00000010L
0x00000020L
0x00000040L
0x00000080L

System Data Interfaces

6-21

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 112

Figure 6-25: <fmtmsg.h>, Part 2 of 2

#define MM_NOSEV
#define MM_HALT
#define MM_ERROR
#define MM_WARNING
#define MM_INFO

0
1
2
3
4

#define MM_NULLLBL
#define MM_NULLSEV
#define MM_NULLMC
#define MM_NULLTXT
#define MM_NULLACT
#define MM_NULLTAG

((char *) NULL)
MM_NOSEV
MM_NULL
((char *) NULL)
((char *) NULL)
((char *) NULL)

#define MM_NOTOK
#define MM_OK
#define MM_NOMSG
#define MM_NOCON

-1
0x00
0x01
0x04

Figure 6-26: <fnmatch.h> *

#define FNM_PATHNAME
#define FNM_PERIOD
#define FNM_NOESCAPE
#define FNM_BADRANGE
#define FNM_EXTENDED

0x001
0x002
0x004
0x008
0x020

#define FNM_NOSYS
#define FNM_NOMATCH

(-1)
(-2)

6-22

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 113

Figure 6-27: <ftw.h>

#define FTW_F
#define FTW_D
#define FTW_DNR
#define FTW_NS
#define FTW_SL
#define FTW_DP
#define FTW_SLN

0
1
2
3
4
6
7

#define FTW_PHYS
#define FTW_MOUNT
#define FTW_CHDIR
#define FTW_DEPTH

01
02
04
010

struct FTW {
int
quit;
int
base;
int
level;
};
#define FTW_SKD
#define FTW_FOLLOW
#define FTW_PRUNE

1
2
4

System Data Interfaces

6-23

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 114

Figure 6-28: <glob.h> *

#define GLOB_APPEND
#define GLOB_DOOFFS
#define GLOB_ERR
#define GLOB_MARK
#define GLOB_NOCHECK
#define GLOB_NOSORT
#define GLOB_NOESCAPE
#define GLOB_OKAYDOT
#define GLOB_BADRANGE
#define GLOB_EXTENDED

0x0001
0x0002
0x0004
0x0008
0x0010
0x0020
0x0040
0x0200
0x0400
0x1000

#define GLOB_NOSYS
#define GLOB_ABORTED
#define GLOB_NOSPACE
#define GLOB_NOMATCH

(-1)
(-2)
(-3)
(-4)

typedef struct
{
void
char
size_t
size_t
} glob_t;

*;
**gl_pathv;
gl_pathc;
gl_offs;

6-24

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 115

Figure 6-29: <grp.h>

struct group {
char *gr_name;
char *gr_passwd;
gid_t gr_gid;
char **gr_mem;
};

Figure 6-30: <iconv.h> *

typedef void *iconv_t;

System Data Interfaces

6-25

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 116

Figure 6-31: <sys/ipc.h>

struct ipc_perm {
uid_t
gid_t
uid_t
gid_t
mode_t
ulong
key_t
long
};

uid;
gid;
cuid;
cgid;
mode;
seq;
key;
pad[4];

#define IPC_CREAT 0001000
#define IPC_EXCL
0002000
#define IPC_NOWAIT 0004000
#define IPC_PRIVATE (key_t)0
#define IPC_RMID
#define IPC_SET
#define IPC_STAT

10
11
12

6-26

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 117

Figure 6-32: <langinfo.h>, Part 1 of 2

#define DAY_1
#define DAY_2
#define DAY_3
#define DAY_4
#define DAY_5
#define DAY_6
#define DAY_7

1
2
3
4
5
6
7

#define ABDAY_1
#define ABDAY_2
#define ABDAY_3
#define ABDAY_4
#define ABDAY_5
#define ABDAY_6
#define ABDAY_7

8
9
10
11
12
13
14

#define MON_1
#define MON_2
#define MON_3
#define MON_4
#define MON_5
#define MON_6
#define MON_7
#define MON_8
#define MON_9
#define MON_10
#define MON_11
#define MON_12

15
16
17
18
19
20
21
22
23
24
25
26

System Data Interfaces

6-27

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 118

Figure 6-33: <langinfo.h>, Part 2 of 2

#define ABMON_1
#define ABMON_2
#define ABMON_3
#define ABMON_4
#define ABMON_5
#define ABMON_6
#define ABMON_7
#define ABMON_8
#define ABMON_9
#define ABMON_10
#define ABMON_11
#define ABMON_12

27
28
29
30
31
32
33
34
35
36
37
38

#define RADIXCHAR
#define THOUSEP
#define YESSTR
#define NOSTR
#define CRNCYSTR

39
40
41
42
43

#define D_T_FMT
#define D_FMT
#define T_FMT
#define AM_STR
#define PM_STR
#define CODESET
#define T_FMT_AMPM
#define ERA
#define ERA_D_FMT
#define ERA_D_T_FMT
#define ERA_T_FMT
#define ALT_DIGITS
#define YESEXPR
#define NOEXPR

44
45
46
47
48
49
50
51
52
53
54
55
56
57

6-28

M
M
M
M
M
M
M
M
M

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 119

Figure 6-34: <limits.h>, Part 1 of 2

#define CHAR_BIT
#define SCHAR_MIN
#define SCHAR_MAX
#define UCHAR_MAX
#define MB_LEN_MAX

8
(-128)
127
255
5

#define CHAR_MIN
#define CHAR_MAX

SCHAR_MIN
SCHAR_MAX

#define SHRT_MIN
#define SHRT_MAX
#define USHRT_MAX
#define INT_MIN
#define INT_MAX
#define UINT_MAX
#define LONG_MIN
#define LONG_MAX
#define ULONG_MAX

(-32768)
32767
65535
(-2147483647-1)
2147483647
4294967295
(-2147483647-1)
2147483647
4294967295

#define ARG_MAX
#define LINK_MAX
#define MAX_CANON
#define MAX_INPUT
#define NGROUPS_MAX
#define PATH_MAX
#define PIPE_BUF
#define TMP_MAX
#define PASS_MAX
#define CHILD_MAX

*
*
*
*
*
*
*
*
*
*

/* starred values vary and should be
retrieved using sysconf() or pathconf() */

System Data Interfaces

6-29

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 120

Figure 6-35: <limits.h>, Part 2 of 2

#define NL_ARGMAX
#define NL_LANGMAX
#define NL_MSGMAX
#define NL_NMAX
#define NL_SETMAX
#define NL_TEXTMAX
#define NZERO

9
14
32767
1
255
255
20

#define WORD_BIT
#define LONG_BIT

32
32

#define DBL_DIG
#define DBL_MAX
#define DBL_MIN
#define FLT_DIG
#define FLT_MAX
#define FLT_MIN

15
1.7976931348623157E+308
2.2250738585072014E-308
6
3.40282347E+38F
1.17549435E-38F

#define FCHR_MAX

1048576

6-30

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 121

Figure 6-36: <locale.h>

struct lconv {
char *decimal_point;
char *thousands_sep;
char *grouping;
char *int_curr_symbol;
char *currency_symbol;
char *mon_decimal_point;
char *mon_thousands_sep;
char *mon_grouping;
char *positive_sign;
char *negative_sign;
char int_frac_digits;
char frac_digits;
char p_cs_precedes;
char p_sep_by_space;
char n_cs_precedes;
char n_sep_by_space;
char p_sign_posn;
char n_sign_posn;
};
#define LC_CTYPE
#define LC_NUMERIC
#define LC_TIME
#define LC_COLLATE
#define LC_MONETARY
#define LC_MESSAGES
#define LC_ALL

0
1
2
3
4
5
6

System Data Interfaces

6-31

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 122

Figure 6-37: <lwpsynch.h> *

typedef volatile struct {
char
wanted;
_simplelock_t
lock;
} lwp_mutex_t;
typedef volatile struct {
char
wanted;
} lwp_cond_t;

Figure 6-38: <machlock.h> *

typedef volatile unsigned char _simplelock_t;

Figure 6-39: <math.h>

G
G

extern const double __huge_val;
#define HUGE_VAL
_ _huge_val

6-32

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 123

Figure 6-40: <sys/mman.h>

#define PROT_READ
#define PROT_WRITE
#define PROT_EXEC
#define PROT_NONE

0x1
0x2
0x4
0x0

#define MAP_SHARED
#define MAP_PRIVATE
#define MAP_FIXED

1
2
0x10

#define MS_SYNC
#define MS_ASYNC
#define MS_INVALIDATE

0x0
0x1
0x2

#define PROC_TEXT
#define PROC_DATA

G
G

(PROT_EXEC | PROT_READ)
(PROT_READ | PROT_WRITE | PROT_EXEC)

#define SHARED
#define PRIVATE

G
G

0x10
0x20

#define
#define
#define
#define
#define

MC_SYNC
MC_LOCK
MC_UNLOCK
MC_LOCKAS
MC_UNLOCKAS

3
5
6

G
G
G
G
G

#define
#define

MCL_CURRENT
MCL_FUTURE

0x1
0x2

G
G

1
2

System Data Interfaces

6-33

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 124

Figure 6-41: <sys/mod.h> *

#define VOID
void
#define MAXPATHLEN
1024
#define MODMAXLINKINFOLEN 32
struct modspecific_stat {
char mss_linkinfo[MODMAXLINKINFOLEN];
int
mss_type;
int
mss_p0[2];
int
mss_p1[2];
};
#define MODMAXLINK

4

struct modstatus {
int
ms_id;
VOID
*ms_base;
unsigned int
ms_size;
int
ms_rev;
char
ms_path[MAXPATHLEN];
time_t
ms_unload_delay;
int
ms_refcnt;
int
ms_depcnt;
struct modspecific_stat
ms_msinfo[MODMAXLINK];
};

6-34

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 125

Figure 6-42: <sys/mount.h>

#define MS_RDONLY
#define MS_FSS
#define MS_DATA
#define MS_HADBAD

0x01
0x02
0x04
0x08

#define MS_NOSUID
#define MS_REMOUNT
#define MS_NOTRUNC

0x10
0x20
0x40

System Data Interfaces

6-35

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 126

Figure 6-43: <sys/msg.h>

#define MSG_NOERROR

010000

struct msqid_ds {
struct ipc_perm
msg_perm;
struct msg
*msg_first;
struct msg
*msg_last;
ulong
msg_cbytes;
ulong
msg_qnum;
ulong
msg_qbytes;
pid_t
msg_lspid;
pid_t
msg_lrpid;
time_t
msg_stime;
long
msg_pad1;
time_t
msg_rtime;
long
msg_pad2;
time_t
msg_ctime;
long
msg_pad3;
long
msg_pad4[4];
};
struct msg {
struct msg
long
ushort
short
};

*msg_next;
msg_type;
msg_ts;
msg_spot;

6-36

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 127

Figure 6-44: <netconfig.h>, Part 1 of 2

G
struct netconfig {
char
unsigned long
unsigned long
char
char
char
unsigned long
char
unsigned long
};

*nc_netid;
nc_semantics;
nc_flag;
*nc_protofmly;
*nc_proto;
*nc_device;
nc_nlookups;
**nc_lookups;
nc_unused[8];

#define NC_TPI_CLTS
#define NC_TPI_COTS
#define NC_TPI_COTS_ORD
#define NC_TPI_RAW

1
2
3
4

#define NC_NOFLAG
#define NC_VISIBLE

00
01

System Data Interfaces

6-37

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 128

Figure 6-45: <netconfig.h>, Part 2 of 2

#define NC_NOPROTOFMLY
#define NC_LOOPBACK
#define NC_INET
#define NC_IMPLINK
#define NC_PUP
#define NC_CHAOS
#define NC_NS
#define NC_NBS
#define NC_ECMA
#define NC_DATAKIT
#define NC_CCITT
#define NC_SNA
#define NC_DECNET
#define NC_DLI
#define NC_LAT
#define NC_HYLINK
#define NC_APPLETALK
#define NC_NIT
#define NC_IEEE802
#define NC_OSI
#define NC_X25
#define NC_OSINET
#define NC_GOSIP
#define NC_NETWARE

"-"
"loopback"
"inet"
"implink"
"pup"
"chaos"
"ns"
"nbs"
"ecma"
"datakit"
"ccitt"
"sna"
"decnet"
"dli"
"lat"
"hylink"
"appletalk"
"nit"
"ieee802"
"osi"
"x25"
"osinet"
"gosip"
"netware"

M

#define NC_NOPROTO
#define NC_TCP
#define NC_UDP
#define NC_ICMP
#define NC_IPX
#define NC_SPX

"-"
"tcp"
"udp"
"icmp"
"ipx"
"spx"

M
M

6-38

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 129

Figure 6-46: <netdir.h>, Part 1 of 2

struct nd_addrlist {
int
struct netbuf
};

n_cnt;
*n_addrs;

struct nd_hostservlist {
int
h_cnt;
struct nd_hostserv *h_hostservs;
};
struct nd_hostserv {
char
*h_host;
char
*h_serv;
};
#define ND_HOSTSERV
#define ND_HOSTSERVLIST
#define ND_ADDR
#define ND_ADDRLIST

0
1
2
3

#define ND_BADARG
#define ND_NOMEM
#define ND_OK
#define ND_NOHOST
#define ND_NOSERV
#define ND_NOSYM
#define ND_OPEN
#define ND_ACCESS
#define ND_UKNWN
#define ND_NOCTRL
#define ND_FAILCTRL
#define ND_SYSTEM
#define ND_NOERRMEM
#define ND_NOLIB
#define ND_XTIERROR
#define ND_BADSTATE

-2
-1
0
1
2
3
4
5
6
7
8
9
10
11
12
13

System Data Interfaces

M
M
M
M

6-39

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 130

Figure 6-47: <netdir.h>, Part 2 of 2

#define ND_SET_BROADCAST
#define ND_SET_RESERVEDPORT
#define ND_CHECK_RESERVEDPORT
#define ND_MERGEADDR
#define ND_CLEAR_BROADCAST
#define ND_SET_REUSEADDR
#define ND_CLEAR_REUSEADDR

1
2
3
4
5
6
7

#define HOST_SELF
#define HOST_ANY
#define HOST_BROADCAST

"\\1"
"\\2"
"\\3"

M
M
M

Figure 6-48: <nl_types.h>

#define NL_SETD

1

typedef int nl_item;
typedef void *nl_catd;

6-40

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 131

Figure 6-49: <sys/param.h>

#define CANBSIZ
#define HZ
#define TICK

256
100
10000000

#define NGROUPS_UMIN

0

#define NBPSCTR

512

#define MAXPATHLEN
#define MAXSYMLINKS
#define MAXNAMELEN

1024
20
256

#define NADDR

13

#define PIPE_MAX

5120

#define NBBY

8

#define MAXFRAG

8

System Data Interfaces

6-41

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 132

Figure 6-50: <poll.h>

struct pollfd {
int
fd;
short events;
short revents;
};
#define POLLIN
#define POLLPRI
#define POLLOUT
#define POLLRDNORM
#define POLLWRNORM
#define POLLRDBAND
#define POLLWRBAND

0x0001
0x0002
0x0004
0x0040
POLLOUT
0x0080
0x0100

#define POLLNORM

POLLRDNORM

#define POLLERR
#define POLLHUP
#define POLLNVAL

0x0008
0x0010
0x0020

6-42

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 133

Figure 6-51: <sys/priocntl.h> *

#define PC_GETCID
#define PC_GETCLINFO
#define PC_SETPARMS
#define PC_GETPARMS

0

#define PC_CLNULL

-1

1
2
3

#define PC_CLNMSZ 16
#define PC_CLINFOSZ (32 / sizeof(long))
#define PC_CLPARMSZ (32 / sizeof(long))
typedef struct pcinfo {
id_t pc_cid;
char pc_clname[PC_CLNMSZ];
long pc_clinfo[PC_CLINFOSZ];
} pcinfo_t;
typedef struct pcparms {
id_t pc_cid;
long pc_clparms[PC_CLPARMSZ];
} pcparms_t;

System Data Interfaces

6-43

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 134

Figure 6-52: <sys/procset.h>

#define P_INITPID
#define P_INITUID
#define P_INITPGID

1
0
0

typedef enum idtype {
P_PID,
P_PPID,
P_PGID,
P_SID,
P_CID,
P_UID,
P_GID,
P_ALL
} idtype_t;
typedef enum idop {
POP_DIFF,
POP_AND,
POP_OR,
POP_XOR
} idop_t;

typedef struct procset {
idop_t
p_op;
idtype_t
p_lidtype;
id_t
p_lid;
idtype_t
p_ridtype;
id_t
p_rid;
} procset_t;

6-44

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 135

Figure 6-53: <pwd.h>

struct passwd {
char
char
uid_t
gid_t
char
char
char
char
char
};

*pw_name;
*pw_passwd;
pw_uid;
pw_gid;
*pw_age;
*pw_comment;
*pw_gecos;
*pw_dir;
*pw_shell;

System Data Interfaces

6-45

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 136

Figure 6-54: <regex.h> *, Part 1 of 2

#define REG_NOTBOL
#define REG_NOTEOL
#define REG_NONEMPTY

0x000001
0x000002
0x000004

#define REG_OR
#define REG_PLUS
#define REG_QUEST
#define REG_BRACES
#define REG_PARENS
#define REG_ANCHORS
#define REG_NOBACKREF
#define REG_NOAUTOQUOTE

0x000001
0x000002
0x000004
0x000008
0x000010
0x000020
0x000040
0x000080

#define REG_EXTENDED
(REG_OR | REG_PLUS | REG_QUEST |
REG_BRACES | REG_PARENS | REG_ANCHORS |
REG_NOBACKREF | REG_NOAUTOQUOTE)
#define REG_ICASE
0x000100
#define REG_NOSUB
0x000200
#define REG_NEWLINE
0x000400
#define REG_ONESUB
0x000800
#define REG_BADRANGE
0x004000
#define REG_ANGLES
0x040000
#define REG_ESCNL
0x080000
#define REG_OLDBRE (REG_BADRANGE | REG_ANGLES | REG_ESCNL)

6-46

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 137

Figure 6-55: <regex.h> *, Part 2 of 2

#define REG_ENOSYS
#define REG_NOMATCH
#define REG_BADPAT
#define REG_ECOLLATE
#define REG_ECTYPE
#define REG_EESCAPE
#define REG_ESUBREG
#define REG_EBRACK
#define REG_NOPAT
#define REG_EPAREN
#define REG_EBRACE
#define REG_BADBR
#define REG_ERANGE
#define REG_ESPACE
#define REG_BADRPT

(-1)
1
2
3
4
7
8
9
12
13
14
15
16
17
18

typedef struct
{
size_t
re_nsub;
unsigned long
re_flags;
void
*[4];
} regex_t;
typedef ssize_t regoff_t;
typedef struct
{
regoff_t
regoff_t
} regmatch_t;

rm_so;
rm_eo;

System Data Interfaces

6-47

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 138

Figure 6-56: <sys/resource.h>

#define RLIMIT_CPU
#define RLIMIT_FSIZE
#define RLIMIT_DATA
#define RLIMIT_STACK
#define RLIMIT_CORE
#define RLIMIT_NOFILE
#define RLIMIT_VMEM
#define RLIM_NLIMITS
#define RLIMIT_AS
#define RLIM_INFINITY

0
1
2
3
4
5
6
7
RLIMIT_VMEM
0x7fffffff

typedef unsigned long

rlim_t;

struct rlimit {
rlim_t
rlim_t
};

rlim_cur;
rlim_max;

6-48

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 139

Figure 6-57: <rpc.h>, Part 1 of 16

#define bool_t
#define enum_t

int
int

enum xdr_op {
XDR_ENCODE=0,
XDR_DECODE=1,
XDR_FREE=2
};
typedef bool_t

(*xdrproc_t)();

typedef struct {
enum xdr_op x_op;
struct xdr_ops {
bool_t (*x_getlong)();
bool_t (*x_putlong)();
bool_t (*x_getbytes)();
bool_t (*x_putbytes)();
u_int (*x_getpostn)();
bool_t (*x_setpostn)();
long * (*x_inline)();
void (*x_destroy)();
} *x_ops;
caddr_t
x_public;
caddr_t
x_private;
caddr_t
x_base;
int
x_handy;
} XDR;

System Data Interfaces

6-49

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 140

Figure 6-58: <rpc.h>, Part 2 of 16

#define xdr_getpos(xdrs)
(*(xdrs)->x_ops->x_getpostn)(xdrs)
#define xdr_setpos(xdrs, pos)
(*(xdrs)->x_ops->x_setpostn)(xdrs, pos)
#define xdr_inline(xdrs, len)
(*(xdrs)->x_ops->x_inline)(xdrs, len)
#define xdr_destroy(xdrs)
\
(*(xdrs)->x_ops->x_destroy)(xdrs)

\
\
\
M
M

#define NULL_xdrproc_t
((xdrproc_t)0)
struct xdr_discrim {
int
value;
xdrproc_t
proc;
};

6-50

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 141

Figure 6-59: <rpc.h>, Part 3 of 16

#define MAX_AUTH_BYTES
#define MAXNETNAMELEN
#define HEXKEYBYTES

400
255
48

enum auth_stat {
AUTH_OK=0,
AUTH_BADCRED=1,
AUTH_REJECTEDCRED=2,
AUTH_BADVERF=3,
AUTH_REJECTEDVERF=4,
AUTH_TOOWEAK=5,
AUTH_INVALIDRESP=6,
AUTH_FAILED=7
};
typedef u_long

M

u_int32

union des_block {
struct {
u_int32
u_int32
} key;
char c[8];
};
typedef union des_block

M
M

high;
low;

des_block;

System Data Interfaces

6-51

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 142

Figure 6-60: <rpc.h>, Part 4 of 16

struct opaque_auth {
enum_t
oa_flavor;
caddr_t
oa_base;
u_int
oa_length;
};
typedef struct {
struct opaque_auth ah_cred;
struct opaque_auth ah_verf;
union des_block
ah_key;
struct auth_ops {
void (*ah_nextverf)();
int
(*ah_marshal)();
int
(*ah_validate)();
int
(*ah_refresh)();
void (*ah_destroy)();
} *ah_ops;
caddr_t
ah_private;
} AUTH;
#define auth_destroy(auth)
\
((*((auth)->ah_ops->ah_destroy))(auth))
#define AUTH_NONE
#define AUTH_NULL
#define AUTH_SYS
#define AUTH_UNIX
#define AUTH_SHORT
#define AUTH_DES
#define AUTH_ESV

0
0
1
AUTH_SYS
2
3
200004

6-52

M

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 143

Figure 6-61: <rpc.h>, Part 5 of 16

enum clnt_stat {
RPC_SUCCESS=0,
RPC_CANTENCODEARGS=1,
RPC_CANTDECODERES=2,
RPC_CANTSEND=3,
RPC_CANTRECV=4,
RPC_TIMEDOUT=5,
RPC_INTR=18,
RPC_UDERROR=23,
RPC_VERSMISMATCH=6,
RPC_AUTHERROR=7,
RPC_PROGUNAVAIL=8,
RPC_PROGVERSMISMATCH=9,
RPC_PROCUNAVAIL=10,
RPC_CANTDECODEARGS=11,
RPC_SYSTEMERROR=12,
RPC_UNKNOWNHOST=13,
RPC_UNKNOWNPROTO=17,
RPC_UNKNOWNADDR=19,
RPC_NOBROADCAST=21,
RPC_RPCBFAILURE=14,
RPC_PROGNOTREGISTERED=15,
RPC_N2AXLATEFAILURE=22,
RPC_TLIERROR=20,
RPC_FAILED=16
};
#define RPC_PMAPFAILURE
RPC_RPCBFAILURE

System Data Interfaces

6-53

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 144

Figure 6-62: <rpc.h>, Part 6 of 16

struct rpc_err {
enum clnt_stat
re_status;
union {
struct {
int
errno;
int
t_errno;
} RE_err;
enum auth_stat
RE_why;
struct {
u_long
low;
u_long
high;
} RE_vers;
struct {
long s1;
long s2;
} RE_lb;
} ru;
};
typedef struct {
AUTH *cl_auth;
struct clnt_ops {
enum clnt_stat
(*cl_call)();
void
(*cl_abort)();
void
(*cl_geterr)();
bool_t
(*cl_freeres)();
void
(*cl_destroy)();
bool_t
(*cl_control)();
} *cl_ops;
caddr_t
cl_private;
char
*cl_netid;
char
*cl_tp;
} CLIENT;

6-54

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 145

Figure 6-63: <rpc.h>, Part 7 of 16

#define FEEDBACK_REXMIT1
#define FEEDBACK_OK

1
2

#define clnt_call(rh, proc, xargs, argsp, xres, resp, secs)\
((*(rh)->cl_ops->cl_call)
\
(rh, proc, xargs, argsp, xres, resp, secs))
#define clnt_abort(rh)
\
((*(rh)->cl_ops->cl_abort)(rh))
#define clnt_geterr(rh, errp)
\
((*(rh)->cl_ops->cl_geterr)(rh, errp))
#define clnt_freeres(rh,xres,resp)
\
((*(rh)->cl_ops->cl_freeres)(rh,xres,resp))
#define clnt_control(cl, rq, in)
\
((*(cl)->cl_ops->cl_control)(cl, rq, in))
#define clnt_destroy(rh)
\
((*(rh)->cl_ops->cl_destroy)(rh))
#define CLSET_TIMEOUT
#define CLGET_TIMEOUT
#define CLGET_SERVER_ADDR
#define CLGET_FD
#define CLGET_SVC_ADDR
#define CLSET_FD_CLOSE
#define CLSET_FD_NCLOSE
#define CLSET_RETRY_TIMEOUT
#define CLGET_RETRY_TIMEOUT

1
2
3
6
7
8
9
4
5

System Data Interfaces

6-55

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 146

Figure 6-64: <rpc.h>, Part 8 of 16

typedef struct {
enum
clnt_stat
struct rpc_err
} rpc_createerr_t;

cf_stat;
cf_error;

M
M
M
M

extern

rpc_createerr;

M

rpc_createerr_t

6-56

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 147

Figure 6-65: <rpc.h>, Part 9 of 16

enum msg_type {
CALL=0,
REPLY=1
};
enum reply_stat {
MSG_ACCEPTED=0,
MSG_DENIED=1
};
enum accept_stat {
SUCCESS=0,
PROG_UNAVAIL=1,
PROG_MISMATCH=2,
PROC_UNAVAIL=3,
GARBAGE_ARGS=4,
SYSTEM_ERR=5
};
enum reject_stat {
RPC_MISMATCH=0,
AUTH_ERROR=1
};

System Data Interfaces

6-57

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 148

Figure 6-66: <rpc.h>, Part 10 of 16

struct accepted_reply {
struct opaque_auth
enum accept_stat
union {
struct {
u_long
u_long
} AR_versions;
struct {
caddr_t
xdrproc_t
} AR_results;

ar_verf;
ar_stat;

low;
high;

where;
proc;

} ru;
};
struct rejected_reply {
enum reject_stat
rj_stat;
union {
struct {
u_long
low;
u_long
high;
} RJ_versions;
enum auth_stat
RJ_why;
} ru;
};

6-58

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 149

Figure 6-67: <rpc.h>, Part 11 of 16

struct reply_body {
enum reply_stat
rp_stat;
union {
struct accepted_reply RP_ar;
struct rejected_reply RP_dr;
} ru;
};
struct call_body {
u_long
u_long
u_long
u_long
struct opaque_auth
struct opaque_auth
};

cb_rpcvers;
cb_prog;
cb_vers;
cb_proc;
cb_cred;
cb_verf;

struct rpc_msg {
u_long
rm_xid;
enum msg_type
rm_direction;
union {
struct call_body
RM_cmb;
struct reply_body RM_rmb;
} ru;
};

System Data Interfaces

6-59

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 150

Figure 6-68: <rpc.h>, Part 12 of 16

struct authsys_parms {
u_long
aup_time;
char
*aup_machname;
uid_t
aup_uid;
gid_t
aup_gid;
u_int
aup_len;
gid_t
*aup_gids;
};

Figure 6-69: <rpc.h>, Part 13 of 16

enum authdes_namekind {
ADN_FULLNAME,
ADN_NICKNAME
};
struct authdes_fullname {
char
*name;
des_block
key;
u_long
window;
};
struct authdes_cred {
enum authdes_namekind
struct authdes_fullname
u_long
};

adc_namekind;
adc_fullname;
adc_nickname;

6-60

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 151

Figure 6-70: <rpc.h>, Part 14 of 16

enum xprt_stat {
XPRT_DIED,
XPRT_MOREREQS,
XPRT_IDLE
};
typedef struct {
int
xp_fd;
u_short
xp_port;
struct xp_ops {
bool_t
(*xp_recv)();
enum xprt_stat
(*xp_stat)();
bool_t
(*xp_getargs)();
bool_t
(*xp_reply)();
bool_t
(*xp_freeargs)();
void
(*xp_destroy)();
} *xp_ops;
int
xp_addrlen;
char
*xp_tp;
char
*xp_netid;
struct netbuf
xp_ltaddr;
struct netbuf
xp_rtaddr;
char
xp_raddr[16];
struct opaque_auth xp_verf;
caddr_t
xp_p1;
caddr_t
xp_p2;
caddr_t
xp_p3;
int
xp_type;
} SVCXPRT;

System Data Interfaces

M

6-61

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 152

Figure 6-71: <rpc.h>, Part 15 of 16

#define svc_getrpccaller(x) (&(x)->xp_rtaddr)
#define svc_getargs(xprt, xargs, argsp)
\
(*(xprt)->xp_ops->xp_getargs)((xprt), (xargs), (argsp))
#define svc_freeargs(xprt, xargs, argsp)
\
(*(xprt)->xp_ops->xp_freeargs)((xprt), (xargs), (argsp))
#define svc_destroy(xprt)
\
(*(xprt)->xp_ops->xp_destroy)(xprt)
struct svc_req {
u_long
u_long
u_long
struct opaque_auth
caddr_t
SVCXPRT
};

#define FD_SETSIZE
#define NBBY 8

rq_prog;
rq_vers;
rq_proc;
rq_cred;
rq_clntcred;
*rq_xprt;

M
M

1024

typedef long
fd_mask;
#define NFDBITS (sizeof(fd_mask) * NBBY)
#define howmany(x, y)
(((x)+((y)-1))/(y))

M
M
M

typedef struct fd_set {
fd_mask fds_bits[howmany(FD_SETSIZE, NFDBITS)];
} fd_set;

M
M
M

extern fd_set svc_fdset;

6-62

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 153

Figure 6-72: <rpc.h>, Part 16 of 16

struct rpcb {
u_long
r_prog;
u_long
r_vers;
char
*r_netid;
char
*r_addr;
char
*r_owner;
};
typedef struct rpcb RPCB;
struct rpcblist {
RPCB
struct rpcblist
};

rpcb_map;
*rpcb_next;

Figure 6-73: <rtpriocntl.h> *

typedef struct rtparms {
short rt_pri;
ulong rt_tqsecs;
long rt_tqnsecs;
} rtparms_t;
typedef struct rtinfo {
short rt_maxpri;
} rtinfo_t;
#define RT_NOCHANGE -1
#define RT_TQINF
-2
#define RT_TQDEF
-3

System Data Interfaces

6-63

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 154

Figure 6-74: <search.h>

typedef enum { FIND, ENTER } ACTION;
typedef struct entry { char *key; void *data; } ENTRY;
typedef enum { preorder, postorder, endorder, leaf } VISIT;

6-64

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 155

Figure 6-75: <sys/sem.h>

#define SEM_UNDO
#define GETNCNT
#define GETPID
#define GETVAL
#define GETALL
#define GETZCNT
#define SETVAL
#define SETALL

010000
3
4
5
6
7
8
9

struct semid_ds {
struct ipc_perm
sem_perm;
struct sem
*sem_base;
ushort
sem_nsems;
time_t
sem_otime;
long
sem_pad1;
time_t
sem_ctime;
long
sem_pad2;
long
sem_pad3[4];
};
struct sem {
ushort
pid_t
ushort
ushort
};

semval;
sempid;
semncnt;
semzcnt;

struct sembuf {
ushort
short
short
};

sem_num;
sem_op;
sem_flg;

System Data Interfaces

6-65

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 156

Figure 6-76: <setjmp.h>

#define _SIGJBLEN
#define _JBLEN
typedef int
typedef int

128
10

jmp_buf[_JBLEN];
sigjmp_buf[_SIGJBLEN];

Figure 6-77: <sys/shm.h>

#define SHMLBA

((1)<<12)

#define SHM_RDONLY
#define SHM_RND

010000
020000

struct shmid_ds {
struct ipc_perm
shm_perm;
int
shm_segsz;
struct anon_map
*shm_amp;
ushort
shm_lkcnt;
pid_t
shm_lpid;
pid_t
shm_cpid;
ulong
shm_nattch;
ulong
shm_cnattch;
time_t
shm_atime;
long
shm_pad1;
time_t
shm_dtime;
long
shm_pad2;
time_t
shm_ctime;
long
shm_pad3;
long
shm_pad4[4];
};

6-66

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 157

Figure 6-78: <signal.h>, Part 1 of 3

#define SIGHUP
#define SIGINT
#define SIGQUIT
#define SIGILL
#define SIGTRAP
#define SIGIOT
#define SIGABRT
#define SIGEMT
#define SIGFPE
#define SIGKILL
#define SIGBUS
#define SIGSEGV
#define SIGSYS
#define SIGPIPE
#define SIGALRM
#define SIGTERM
#define SIGUSR1
#define SIGUSR2
#define SIGCLD
#define SIGCHLD
#define SIGPWR
#define SIGWINCH
#define SIGURG
#define SIGPOLL
#define SIGIO
#define SIGSTOP
#define SIGTSTP
#define SIGCONT
#define SIGTTIN
#define SIGTTOU
#define SIGVTALRM
#define SIGPROF

System Data Interfaces

1
2
3
4
5
6
6
7
8
9
10
11
12
13
14
15
16
17
18
18
19
20
21
22
22
23
24
25
26
27
28
29

6-67

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 158

Figure 6-79: <signal.h>, Part 2 of 3

#define SIGXCPU
#define SIGXFSZ

30
31

#define SIG_DFL
#define SIG_ERR
#define SIG_IGN
#define SIG_HOLD

(void(*)())0
(void(*)())-1
(void(*)())1
(void(*)())2

#define SIG_BLOCK
#define SIG_UNBLOCK
#define SIG_SETMASK

1
2
3

typedef struct {
unsigned int
} sigset_t;

sa_sigbits[4];

struct sigaction {
int
void
sigset_t
int
};

M
M
M

sa_flags;
(*sa_handler)();
sa_mask;
sa_resv[2];

#define SA_NOCLDSTOP
#define SA_ONSTACK
#define SA_RESETHAND
#define SA_RESTART
#define SA_SIGINFO
#define SA_NODEFER
#define SA_NOCLDWAIT

0x00020000
0x00000001
0x00000002
0x00000004
0x00000008
0x00000010
0x00010000

6-68

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 159

Figure 6-80: <signal.h>, Part 3 of 3

#define SS_ONSTACK
#define SS_DISABLE

0x00000001
0x00000002

struct sigaltstack {
char *ss_sp;
int
ss_size;
int
ss_flags;
};
typedef struct sigaltstack

stack_t;

Figure 6-81: <sys/siginfo.h>, Part 1 of 5

#define ILL_ILLOPC
#define ILL_ILLOPN
#define ILL_ILLADR
#define ILL_ILLTRP
#define ILL_PRVOPC
#define ILL_PRVREG
#define ILL_COPROC
#define ILL_BADSTK

1
2
3
4
5
6
7
8

#define FPE_INTDIV
#define FPE_INTOVF
#define FPE_FLTDIV
#define FPE_FLTOVF
#define FPE_FLTUND
#define FPE_FLTRES
#define FPE_FLTINV
#define FPE_FLTSUB

1
2
3
4
5
6
7
8

System Data Interfaces

6-69

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 160

Figure 6-82: <sys/siginfo.h>, Part 2 of 5

#define SEGV_MAPERR
#define SEGV_ACCERR

1
2

#define BUS_ADRALN
#define BUS_ADRERR
#define BUS_OBJERR

1
2
3

#define TRAP_BRKPT
#define TRAP_TRACE

1
2

#define CLD_EXITED
#define CLD_KILLED
#define CLD_DUMPED
#define CLD_TRAPPED
#define CLD_STOPPED
#define CLD_CONTINUED

1
2
3
4
5
6

#define POLL_IN
#define POLL_OUT
#define POLL_MSG
#define POLL_ERR
#define POLL_PRI
#define POLL_HUP

1
2
3
4
5
6

#define SI_MAXSZ
#define SI_PAD

128
((SI_MAXSZ / sizeof(int)) - 3)

6-70

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 161

Figure 6-83: <sys/siginfo.h>, Part 3 of 5

typedef struct siginfo {
int
si_signo;
int
si_code;
int
si_errno;
union {
int
_pad[SI_PAD];
struct {
pid_t _pid;
union {
struct {
uid_t _uid;
} _kill;
struct {
clock_t
_utime;
int
_status;
clock_t
_stime;
} _cld;
} _pdata;
} _proc;
struct {
caddr_t
_addr;
} _fault;
struct {
int
_fd;
long _band;
} _file;
} _data;
} siginfo_t;

System Data Interfaces

6-71

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 162

Figure 6-84: <sys/siginfo.h>, Part 4 of 5

#define si_pid
#define si_status
#define si_stime
#define si_utime
#define si_uid
#define si_addr
#define si_fd
#define si_band

_data._proc._pid
_data._proc._pdata._cld._status
_data._proc._pdata._cld._stime
_data._proc._pdata._cld._utime
_data._proc._pdata._kill._uid
_data._fault._addr
_data._file._fd
_data._file._band

Figure 6-85: <sys/siginfo.h> *, Part 5 of 5

union sigval {
int
void
};

sival_int;
*sival_ptr;

union notifyinfo {
int
void
};

nisigno;
(*nifunc)(union sigval);

struct sigevent {
int
sigev_notify;
union notifyinfo sigev_notifyinfo;
union sigval
sigev_value;
};
#define SIGEV_NONE
#define SIGEV_SIGNAL
#define SIGEV_CALLBACK

1
2
3

6-72

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 163

Figure 6-86: <sys/stat.h>, Part 1 of 2

#define _ST_FSTYPSZ
struct stat {
dev_t
long
ino_t
mode_t
nlink_t
uid_t
gid_t
dev_t
long
off_t
long
timestruc_t
timestruc_t
timestruc_t
long
long
char
long
};
#define st_atime
#define st_mtime
#define st_ctime

16

st_dev;
st_pad1[3];
st_ino;
st_mode;
st_nlink;
st_uid;
st_gid;
st_rdev;
st_pad2[2];
st_size;
st_pad3;
st_atim;
st_mtim;
st_ctim;
st_blksize;
st_blocks;
st_fstype[_ST_FSTYPSZ];
st_pad4[8];
st_atim.tv_sec
st_mtim.tv_sec
st_ctim.tv_sec

System Data Interfaces

6-73

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 164

Figure 6-87: <sys/stat.h>, Part 2 of 2

#define S_IFMT
#define S_IFIFO
#define S_IFCHR
#define S_IFDIR
#define S_IFBLK
#define S_IFREG
#define S_IFLNK

0xF000
0x1000
0x2000
0x4000
0x6000
0x8000
0xA000

#define S_ISUID
#define S_ISGID
#define S_ISVTX

0x800
0x400
0x200

#define S_IRWXU
#define S_IRUSR
#define S_IWUSR
#define S_IXUSR
#define S_IRWXG
#define S_IRGRP
#define S_IWGRP
#define S_IXGRP
#define S_IRWXO
#define S_IROTH
#define S_IWOTH
#define S_IXOTH

00700
00400
00200
00100
00070
00040
00020
00010
00007
00004
00002
00001

#define S_ISFIFO(mode)
#define S_ISCHR(mode)
#define S_ISDIR(mode)
#define S_ISBLK(mode)
#define S_ISREG(mode)

((mode&0xF000) == 0x1000)
((mode&0xF000) == 0x2000)
((mode&0xF000) == 0x4000)
((mode&0xF000) == 0x6000)
((mode&0xF000) == 0x8000)

6-74

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 165

Figure 6-88: <sys/statvfs.h>

#define FSTYPSZ

16

typedef struct statvfs {
u_long
f_bsize;
u_long
f_frsize;
u_long
f_blocks;
u_long
f_bfree;
u_long
f_bavail;
u_long
f_files;
u_long
f_ffree;
u_long
f_favail;
u_long
f_fsid;
char
f_basetype[FSTYPSZ];
u_long
f_flag;
u_long
f_namemax;
char
f_fstr[32];
u_long
f_filler[16];
} statvfs_t;
#define ST_RDONLY 0x01
#define ST_NOSUID 0x02
#define ST_NOTRUNC 0x04

System Data Interfaces

6-75

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 166

Figure 6-89: <stdarg.h>

G
G
G
G
G
G

typedef void
*va_list;
extern void
va_end(va_list);
#define va_start(list, name) (void) (list = (void *)((char *)&...))
#define va_arg(list, mode)
((mode *)(list = (char *)list + \
sizeof(mode)))[-1]
#define va_end(list)
(void)0

NOTE

The construction &... is a syntactic extension to ANSI C and may not be supported by all C compilers. The intended semantics are to set list to the
address on the stack of the first incoming argument in the variable part of the
argument list. See "Function Calling Sequence" in Chapter 3.

G
G

Figure 6-90: <stddef.h>

typedef int
typedef unsigned int
#define NULL
typedef long

ptrdiff_t;
size_t;
0
wchar_t;

#define offsetof(s, m)

(size_t)(&(((s *)0)->m))

6-76

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 167

Figure 6-91: <stdio.h>, Part 1 of 2

typedef unsigned int
typedef long

size_t;
fpos_t;

#define NULL

0

#define BUFSIZ

1024

#define _IOFBF
#define _IOLBF
#define _IONBF
#define _IOEOF
#define _IOERR

0000
0100
0004
0020
0040

#define EOF

(-1)

#define FOPEN_MAX
#define FILENAME_MAX

60
1024

#define L_ctermid
#define L_cuserid
#define P_tmpdir
#define L_tmpnam

9
9
"/var/tmp/"
25

#define stdin
#define stdout
#define stderr

(&_ _iob[0])
(&_ _iob[1])
(&_ _iob[2])

System Data Interfaces

6-77

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 168

Figure 6-92: <stdio.h>, Part 2 of 2

typedef struct {
int
unsigned char
unsigned char
unsigned char
unsigned char
} FILE;
extern FILE

_cnt;
*_ptr;
*_base;
_flag;
_file; ††

G

_ _iob[];

#define clearerr(p) ((void)((p)->_flag &= ˜(_IOERR | _IOEOF))) †
#define feof(p)
((p)->_flag & _IOEOF)
#define ferror(p) ((p)->_flag & _IOERR)
#define fileno(p) (p)->_file †
/* Non reentrant */
#define getc_unlocked(p)
(--(p)->_cnt < 0 ? _ _filbuf(p)
: (int)*(p)->_ptr++)
#define putc_unlocked(x, p) (--(p)->_cnt < 0 ? _ _flsbuf(x, p)
: (int)(*(p)->_ptr++ = (x)))
#define getchar_unlocked()
getc_unlocked(stdin)
#define putchar_unlocked(x) putc_unlocked((x), stdout)

M
M
M
M
M
M
M

#define getc(p)
(--(p)->_cnt < 0 ? _ _filbuf(p)
: (int)*(p)->_ptr++)
#define putc(x, p) (--(p)->_cnt < 0 ? _ _flsbuf(x, p)
: (int)(*(p)->_ptr++ = (x)))
#define getchar()
getc(stdin)
#define putchar(x) putc((x), stdout)

M
M
M
M
M
M

/* Reentrant versions available as functions only */

M

† These macro definitions are moved to Level 2 as of January 1, 1993.
†† The _file member of the FILE struct is moved to Level 2 as of January 1, 1993.

6-78

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 169

NOTE

The macros clearerr, and fileno will be removed as a source interface in a
future release supporting multi-processing. Applications should transition to
the function equivalents of these macros in libc. Binary portability will be supported for existing applications.

CAUTION

The constant _NFILE has been removed. It should still appear in stdio.h,
but may be removed in a future version of the header file. Applications
may not be able to depend on fopen() failing on an attempt to open more
than _NFILE files.

Figure 6-93: <stdlib.h>

typedef struct {
int
quot;
int
rem;
} div_t;
typedef struct {
long quot;
long rem;
} ldiv_t;
typedef unsigned int

size_t;

#define NULL

0

#define EXIT_FAILURE
#define EXIT_SUCCESS
#define RAND_MAX

1
0
32767

extern unsigned char
#define MB_CUR_MAX

_ _ctype[];
(int)_ _ctype[520]

System Data Interfaces

6-79

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 170

Figure 6-94: <stropts.h>, Part 1 of 6

#define SNDZERO
#define SNDPIPE

0x001
0x002

#define RNORM
#define RMSGD
#define RMSGN
#define RMODEMASK
#define RPROTDAT
#define RPROTDIS
#define RPROTNORM

0x000
0x001
0x002
0x003
0x004
0x008
0x010

#define FLUSHR
#define FLUSHW
#define FLUSHRW
#define FLUSHBAND

0x01
0x02
0x03
0x04

6-80

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 171

Figure 6-95: <stropts.h>, Part 2 of 6

#define S_INPUT
#define S_HIPRI
#define S_OUTPUT
#define S_MSG
#define S_ERROR
#define S_HANGUP
#define S_RDNORM
#define S_WRNORM
#define S_RDBAND
#define S_WRBAND
#define S_BANDURG

0x0001
0x0002
0x0004
0x0008
0x0010
0x0020
0x0040
S_OUTPUT
0x0080
0x0100
0x0200

#define RS_HIPRI

0x01

#define MSG_HIPRI
#define MSG_ANY
#define MSG_BAND

0x01
0x02
0x04

#define MORECTL
#define MOREDATA

1
2

#define MUXID_ALL

(-1)

#define ANYMARK
#define LASTMARK

0x01
0x02

System Data Interfaces

6-81

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 172

Figure 6-96: <stropts.h>, Part 3 of 6

#define STR
#define I_NREAD
#define I_PUSH
#define I_POP
#define I_LOOK
#define I_FLUSH
#define I_SRDOPT
#define I_GRDOPT
#define I_STR
#define I_SETSIG
#define I_GETSIG
#define I_FIND
#define I_LINK
#define I_UNLINK
#define I_PEEK
#define I_FDINSERT
#define I_SENDFD
#define I_RECVFD
#define I_SWROPT
#define I_GWROPT
#define I_LIST
#define I_PLINK
#define I_PUNLINK

(’S’<<8)
(STR|01)
(STR|02)
(STR|03)
(STR|04)
(STR|05)
(STR|06)
(STR|07)
(STR|010)
(STR|011)
(STR|012)
(STR|013)
(STR|014)
(STR|015)
(STR|017)
(STR|020)
(STR|021)
(STR|016)
(STR|023)
(STR|024)
(STR|025)
(STR|026)
(STR|027)

6-82

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 173

Figure 6-97: <stropts.h>, Part 4 of 6

#define I_FLUSHBAND
#define I_CKBAND
#define I_GETBAND
#define I_ATMARK
#define I_SETCLTIME
#define I_GETCLTIME
#define I_CANPUT

(STR|034)
(STR|035)
(STR|036)
(STR|037)
(STR|040)
(STR|041)
(STR|042)

System Data Interfaces

6-83

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 174

Figure 6-98: <stropts.h>, Part 5 of 6

struct strioctl {
int
ic_cmd;
int
ic_timout;
int
ic_len;
char *ic_dp;
};
struct strbuf {
int
maxlen;
int
len;
char *buf;
};
struct strpeek {
struct strbuf
struct strbuf
long
};

ctlbuf;
databuf;
flags;

struct strfdinsert {
struct strbuf
struct strbuf
long
int
int
};

ctlbuf;
databuf;
flags;
fildes;
offset;

6-84

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 175

Figure 6-99: <stropts.h>, Part 6 of 6

struct strrecvfd {
int
fd;
uid_t uid;
gid_t gid;
char fill[8];
};
#define FMNAMESZ

8

struct str_mlist {
char l_name[FMNAMESZ+1];
};
struct str_list {
int
struct str_mlist
};

sl_nmods;
*sl_modlist;

struct bandinfo {
unsigned char
int
};

bi_pri;
bi_flag;

System Data Interfaces

6-85

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 176

Figure 6-100: <synch.h> *, Part 1 of 3

#define USYNC_THREAD
#define USYNC_PROCESS

0
1

typedef struct thrq_elt thrq_elt_t;
struct thrq_elt {
thrq_elt_t *thrq_next;
thrq_elt_t *thrq_prev;
};
typedef volatile struct {
lwp_mutex_t m_lmutex;
long
m_type;
lwp_mutex_t m_sync_lock;
thrq_elt_t
m_sleepq;
long
filler;
} mutex_t;
typedef volatile struct {
lwp_cond_t
c_lcond;
long
c_type;
thrq_elt_t
*c_syncq;
lwp_mutex_t c_sync_lock;
} cond_t;

6-86

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 177

Figure 6-101: <synch.h> *, Part 2 of 3

typedef volatile struct {
mutex_t
s_mutex;
cond_t
s_cond;
short
s_count;
short
s_wakecnt;
int
s_type;
} sema_t;
typedef volatile struct rwcv rwcv_t;
struct rwcv {
cond_t rwcv_cond;
rwcv_t *rwcv_next;
char rwcv_rw;
char rwcv_wakeup;
short rwcv_readerwanted;
} ;
typedef volatile struct rwlock rwlock_t;
struct rwlock {
mutex_t
lwp_cond_t
int
short
char
char
short
short
rwcv_t
rwcv_t
long
} ;

rw_mutex;
rw_lwpcond;
rw_type;
rw_readers;
rw_writer;
rw_wrwakeup;
rw_writerwanted;
rw_rdwakecnt;
*rw_cvqhead;
*rw_cvqtail;
pad[4];

System Data Interfaces

6-87

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 178

Figure 6-102: <synch.h> *, Part 3 of 3

typedef volatile struct {
mutex_t
rm_mutex;
pid_t
rm_pid;
thread_t
rm_owner;
int
rm_depth;
long
filler;
} rmutex_t;
typedef volatile struct barrier barrier_t;
struct barrier {
mutex_t
b_lock;
int
b_type;
unsigned int b_count;
unsigned int b_waiting;
unsigned int b_generation;
cond_t
b_cond;
} ;

Figure 6-103: <sys/sysi86.h>

#define SI86FPHW

40

#define FP_NO
#define FP_SW
#define FP_HW
#define FP_287
#define FP_387

0
1
2
2
3

6-88

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 179

Figure 6-104: <termios.h>, Part 1 of 10

#define _POSIX_VDISABLE

0

#define CTRL(c)
#define IBSHIFT
#define NCC
#define NCCS

((c)&037)
16
8
19

typedef unsigned long
typedef unsigned char
typedef unsigned long

tcflag_t;
cc_t;
speed_t;

struct termios {
tcflag_t
tcflag_t
tcflag_t
tcflag_t
cc_t
};

c_iflag;
c_oflag;
c_cflag;
c_lflag;
c_cc[NCCS];

System Data Interfaces

6-89

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 180

Figure 6-105: <termios.h>, Part 2 of 10

#define VINTR
#define VQUIT
#define VERASE
#define VKILL
#define VEOF
#define VEOL
#define VEOL2
#define VMIN
#define VTIME
#define VSWTCH
#define VSTART
#define VSTOP
#define VSUSP
#define VDSUSP
#define VREPRINT
#define VDISCARD
#define VWERASE
#define VLNEXT

0
1
2
3
4
5
6
4
5
7
8
9
10
11
12
13
14
15

6-90

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 181

Figure 6-106: <termios.h>, Part 3 of 10

#define CNUL
#define CDEL
#define CESC
#define CINTR
#define CQUIT
#define CERASE
#define CKILL
#define CEOT
#define CEOL
#define CEOL2
#define CEOF
#define CSTART
#define CSTOP
#define CSWTCH
#define CNSWTCH
#define CSUSP
#define CDSUSP
#define CRPRNT
#define CFLUSH
#define CWERASE
#define CLNEXT

0
0177
’\\’
0177
034
’#’
’@’
04
0
0
04
021
023
032
0
CTRL(’z’)
CTRL(’y’)
CTRL(’r’)
CTRL(’o’)
CTRL(’w’)
CTRL(’v’)

System Data Interfaces

6-91

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 182

Figure 6-107: <termios.h>, Part 4 of 10

#define IGNBRK
#define BRKINT
#define IGNPAR
#define PARMRK
#define INPCK
#define ISTRIP
#define INLCR
#define IGNCR
#define ICRNL
#define IUCLC
#define IXON
#define IXANY
#define IXOFF
#define IMAXBEL
#define DOSMODE

0000001
0000002
0000004
0000010
0000020
0000040
0000100
0000200
0000400
0001000
0002000
0004000
0010000
0020000
0100000

6-92

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 183

Figure 6-108: <termios.h>, Part 5 of 10

#define OPOST
#define OLCUC
#define ONLCR
#define OCRNL
#define ONOCR
#define ONLRET
#define OFILL
#define OFDEL
#define NLDLY
#define NL0
#define NL1
#define CRDLY
#define CR0
#define CR1
#define CR2
#define CR3
#define TABDLY

0000001
0000002
0000004
0000010
0000020
0000040
0000100
0000200
0000400
0
0000400
0003000
0
0001000
0002000
0003000
0014000

System Data Interfaces

6-93

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 184

Figure 6-109: <termios.h>, Part 6 of 10

#define TAB0
#define TAB1
#define TAB2
#define TAB3
#define XTABS
#define BSDLY
#define BS0
#define BS1
#define VTDLY
#define VT0
#define VT1
#define FFDLY
#define FF0
#define FF1
#define PAGEOUT
#define WRAP

0
0004000
0010000
0014000
0014000
0020000
0
0020000
0040000
0
0040000
0100000
0
0100000
0200000
0400000

6-94

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 185

Figure 6-110: <termios.h>, Part 7 of 10

#define CBAUD
#define CSIZE
#define CS5
#define CS6
#define CS7
#define CS8
#define CSTOPB
#define CREAD
#define PARENB
#define PARODD
#define HUPCL
#define CLOCAL
#define RCV1EN
#define XMT1EN
#define LOBLK
#define XCLUDE
#define CIBAUD
#define PAREXT

0000017
0000060
0
0000020
0000040
0000060
0000100
0000200
0000400
0001000
0002000
0004000
0010000
0020000
0040000
0100000
03600000
04000000

System Data Interfaces

6-95

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 186

Figure 6-111: <termios.h>, Part 8 of 10

#define ISIG
#define ICANON
#define XCASE
#define ECHO
#define ECHOE
#define ECHOK
#define ECHONL
#define NOFLSH
#define TOSTOP
#define ECHOCTL
#define ECHOPRT
#define ECHOKE
#define DEFECHO
#define FLUSHO
#define PENDIN
#define IEXTEN

0000001
0000002
0000004
0000010
0000020
0000040
0000100
0000200
0000400
0001000
0002000
0004000
0010000
0020000
0040000
0100000

6-96

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 187

Figure 6-112: <termios.h>, Part 9 of 10

#define TIOC

(’T’<<8)

#define TCGETA
#define TCSETA
#define TCSETAW
#define TCSETAF
#define TCSBRK
#define TCXONC
#define TCFLSH

(TIOC|1)
(TIOC|2)
(TIOC|3)
(TIOC|4)
(TIOC|5)
(TIOC|6)
(TIOC|7)

#define TIOCGWINSZ
#define TIOCSWINSZ

(TIOC|104)
(TIOC|103)

#define TCGETS
#define TCSETS
#define TCSANOW
#define TCSETSW
#define TCSADRAIN
#define TCSETSF
#define TCSAFLUSH

(TIOC|13)
(TIOC|14)
((’T’<<8)|14)
(TIOC|15)
((’T’<<8)|15)
(TIOC|16)
((’T’<<8)|16)

System Data Interfaces

6-97

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 188

Figure 6-113: <termios.h>, Part 10 of 10

#define TCIFLUSH
#define TCOFLUSH
#define TCIOFLUSH

0
1
2

#define TCOOFF
#define TCOON
#define TCIOFF
#define TCION

0
1
2
3

#define B0
#define B50
#define B75
#define B110
#define B134
#define B150
#define B200
#define B300
#define B600
#define B1200
#define B1800
#define B2400
#define B4800
#define B9600
#define B19200
#define B38400

0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

struct winsize {
unsigned short
unsigned short
unsigned short
unsigned short
};

ws_row;
ws_col;
ws_xpixel;
ws_ypixel;

6-98

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 189

Figure 6-114: <thread.h> *, Part 1 of 2

#define THR_SUSPENDED 0x1
#define THR_BOUND
0x2
#define THR_INCR_CONC 0x4
#define THR_DETACHED 0x8
#define THR_DAEMON
0x10
#define SCHED_TS
1
#define SCHED_OTHER
1
#define SCHED_FIFO
2
#define SCHED_RR
3
typedef

id_t

thread_t;

#define POLICY_PARAM_SZ

PC_CLPARMSZ

System Data Interfaces

6-99

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 190

Figure 6-115: <thread.h> *, Part 2 of 2

typedef struct {
id_t policy;
long policy_params[POLICY_PARAM_SZ];
} sched_param_t;
struct ts_param {
int
prio;
};
struct fifo_param {
int
prio;
};
struct rr_param {
int
prio;
};
typedef unsigned int thread_key_t;

Figure 6-116: <sys/ticlts.h>

#define TCL_BADADDR
1
#define TCL_BADOPT
2
#define TCL_NOPEER
3
#define TCL_PEERBADSTATE 4
#define TCL_DEFAULTADDRSZ 4

6-100

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 191

Figure 6-117: <sys/ticots.h>

#define TCO_NOPEER
#define TCO_PEERNOROOMONQ
#define TCO_PEERBADSTATE
#define TCO_PEERINITIATED
#define TCO_PROVIDERINITIATED
#define TCO_DEFAULTADDRSZ

ECONNREFUSED
ECONNREFUSED
ECONNREFUSED
ECONNRESET
ECONNABORTED
4

Figure 6-118: <sys/ticotsord.h>

#define TCOO_NOPEER
#define TCOO_PEERNOROOMONQ
#define TCOO_PEERBADSTATE
#define TCOO_PEERINITIATED
#define TCOO_PROVIDERINITIATED
#define TCOO_DEFAULTADDRSZ

NOTE

1
2
3
4
5
4

The sys/tihdr.h and sys/timod.h headers previously included in this document
were unneccessary as they did not contain user level information and have
therefore been removed from this document.

System Data Interfaces

M

6-101

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 192

Figure 6-119: <time.h> *

struct timespec {
time_t
long
} ;

tv_sec;
tv_nsec;

6-102

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 193

Figure 6-120: <sys/time.h>

typedef long clock_t;
typedef long time_t;
typedef unsigned int size_t;

M

typedef struct timespec {
time_t
tv_sec;
long
tv_nsec;
} timestruc_t;

M
M
M
M

#define CLOCKS_PER_SEC
struct tm {
int
int
int
int
int
int
int
int
int
};

1000000

tm_sec;
tm_min;
tm_hour;
tm_mday;
tm_mon;
tm_year;
tm_wday;
tm_yday;
tm_isdst;

extern char *tzname[2];
#define CLK_TCK

_sysconf(3)

extern long timezone;
extern int daylight;

System Data Interfaces

6-103

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 194

Figure 6-121: <sys/times.h>

struct tms {
clock_t
clock_t
clock_t
clock_t
};

NOTE

tms_utime;
tms_stime;
tms_cutime;
tms_cstime;

This edition introduces the xti.h header which contains the same information
as the current tiuser.h. The new xti.h header is a superset of the previous
edition’s tiuser.h.

M
M
M

tiuser.h has been moved to Level 2 and will be removed in future editions of
the ABI. In the future xti.h should be used as a replacement for tiuser.h.

6-104

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 195

Figure 6-122: <tiuser.h>, Error Return Values

#define TBADADDR
#define TBADOPT
#define TACCES
#define TBADF
#define TNOADDR
#define TOUTSTATE
#define TBADSEQ
#define TSYSERR
#define TLOOK
#define TBADDATA
#define TBUFOVFLW
#define TFLOW
#define TNODATA
#define TNODIS
#define TNOUDERR
#define TBADFLAG
#define TNOREL
#define TNOTSUPPORT
#define TSTATECHNG
#define TNOSTRUCTYPE
#define TBADNAME
#define TBADQLEN
#define TADDRBUSY
#define TINDOUT
#define TPROVMISMATCH
#define TRESQLEN
#define TRESADDR
#define TQFULL
#define TPROTO

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29

System Data Interfaces

M
M
M
M
M
M
M
M
M
M

6-105

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 196

Figure 6-123: <tiuser.h>, Event Bitmasks

#define T_LISTEN
#define T_CONNECT
#define T_DATA
#define T_EXDATA
#define T_DISCONNECT
#define T_ERROR
#define T_UDERR
#define T_ORDREL
#define T_GODATA
#define T_GOEXDATA
#define T_EVENTS

0x0001
0x0002
0x0004
0x0008
0x0010
0x0020
0x0040
0x0080
0x0100
0x0200
0x03ff

M
M
M

Figure 6-124: <tiuser.h>, Flags

#define T_MORE
#define T_EXPEDITED
#define T_NEGOTIATE
#define T_CHECK
#define T_DEFAULT
#define T_SUCCESS
#define T_FAILURE

0x001
0x002
0x004
0x008
0x010
0x020
0x040

6-106

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 197

Figure 6-125: <tiuser.h>, Service Types

#define T_COTS
#define T_COTS_ORD
#define T_CLTS

01
02
03

Figure 6-126: <tiuser.h>, Values for flags field in t_info structure

#define T_SENDZERO

M

0x0000001

System Data Interfaces

6-107

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 198

Figure 6-127: <tiuser.h>, Transport Interface Data Structures, 1 of 2

struct t_info {
long addr;
long options;
long tsdu;
long etsdu;
long connect;
long discon;
long servtype;
long flags;
};

NOTE

M

struct netbuf {
unsigned int
unsigned int
char
};

maxlen;
len;
*buf;

struct t_bind {
struct netbuf
unsigned
};

addr;
qlen;

struct t_optmgmt {
struct netbuf
long
};

opt;
flags;

Applications invoking TLI binary interfaces to t_open or t_getinfo will see the
t_info structure without the flags member. Those applications invoking the XTI
versions of t_open or t_getinfo will see the t_info structure with the flags
member.

6-108

M
M

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 199

Figure 6-128: <tiuser.h>, Transport Interface Data Structures, 2 of 2

struct t_discon {
struct netbuf
int
int
};

udata;
reason;
sequence;

struct t_call {
struct netbuf
struct netbuf
struct netbuf
int
};

addr;
opt;
udata;
sequence;

struct t_unitdata {
struct netbuf
struct netbuf
struct netbuf
};

addr;
opt;
udata;

struct t_uderr {
struct netbuf
struct netbuf
long
};

addr;
opt;
error;

System Data Interfaces

6-109

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 200

Figure 6-129: <tiuser.h>, Structure Types

#define T_BIND
#define T_OPTMGMT
#define T_CALL
#define T_DIS
#define T_UNITDATA
#define T_UDERROR
#define T_INFO

1
2
3
4
5
6
7

Figure 6-130: <tiuser.h>, Fields of Structures

#define T_ADDR
#define T_OPT
#define T_UDATA
#define T_ALL

NOTE

0x01
0x02
0x04
0xffff

M

Differences between XTI and TLI have forced the value of T_ALL to change.
The previous edition’s T_ALL value will not produce the same results as the
new T_ALL.

6-110

M

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 201

Figure 6-131: <tiuser.h>, Transport Interface States

#define T_UNINIT
#define T_UNBND
#define T_IDLE
#define T_OUTCON
#define T_INCON
#define T_DATAXFER
#define T_OUTREL
#define T_INREL
#define T_FAKE
#define T_NOSTATES

0
1
2
3
4
5
6
7
8
9

System Data Interfaces

6-111

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 202

Figure 6-132: <tiuser.h>, User-level Events

#define T_OPEN
#define T_BIND
#define T_OPTMGMT
#define T_UNBIND
#define T_CLOSE
#define T_SNDUDATA
#define T_RCVUDATA
#define T_RCVUDERR
#define T_CONNECT1
#define T_CONNECT2
#define T_RCVCONNECT
#define T_LISTN
#define T_ACCEPT1
#define T_ACCEPT2
#define T_ACCEPT3
#define T_SND
#define T_RCV
#define T_SNDDIS1
#define T_SNDDIS2
#define T_RCVDIS1
#define T_RCVDIS2
#define T_RCVDIS3
#define T_SNDREL
#define T_RCVREL
#define T_PASSCON
#define T_NOEVENTS

0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25

6-112

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 203

Figure 6-133: <tspriocntl.h> *

typedef struct tsparms {
short ts_uprilim;
short ts_upri;
} tsparms_t;

typedef struct tsinfo {
short ts_maxupri;
} tsinfo_t;
#define

TS_NOCHANGE

-32768

System Data Interfaces

6-113

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 204

Figure 6-134: <sys/types.h>

typedef unsigned char
typedef unsigned short
typedef unsigned int
typedef unsigned long

uchar_t;
ushort_t;
uint_t;
ulong_t;

typedef char *
typedef long
typedef long
typedef long
typedef int
typedef ulong_t
typedef long
typedef uid_t
typedef ulong_t
typedef ulong_t
typedef ulong_t
typedef long
typedef uint_t
typedef long
typedef long

caddr_t;
daddr_t;
off_t;
id_t;
key_t;
mode_t;
uid_t;
gid_t;
nlink_t;
dev_t;
ino_t;
pid_t;
size_t;
time_t;
clock_t;

typedef unsigned short
typedef unsigned long

ushort;
ulong;

typedef unsigned char
typedef unsigned short
typedef unsigned int
typedef unsigned long

u_char;
u_short;
u_int;
u_long;

6-114

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 205

Figure 6-135: <ucontext.h>, Part 1 of 2

typedef int
#define NGREG
typedef greg_t

greg_t;
19
gregset_t[NGREG];

#define SS
#define UESP
#define EFL
#define CS
#define EIP
#define ERR
#define TRAPNO
#define EAX
#define ECX
#define EDX
#define EBX
#define ESP
#define EBP
#define ESI
#define EDI
#define DS
#define ES
#define FS
#define GS

18
17
16
15
14
13
12
11
10
9
8
7
6
5
4
3
2
1
0

System Data Interfaces

6-115

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 206

Figure 6-136: <ucontext.h>, Part 2 of 2

typedef struct fpregset {
union {
struct fpchip_state {
int
state[27];
int
status;
} fpchip_state;
struct fp_emul_space {
char fp_emul[246];
char fp_epad[2];
} fp_emul_space;
int
f_fpregs[62];
} fp_reg_set;
long f_wregs[33];
} fpregset_t;
typedef struct {
gregset_t
fpregset_t
} mcontext_t;

gregs;
fpregs;

typedef struct ucontext {
u_long
uc_flags;
struct ucontext
*uc_link;
sigset_t
uc_sigmask;
stack_t
uc_stack;
mcontext_t
uc_mcontext;
long
uc_filler[5];
} ucontext_t;

6-116

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 207

Figure 6-137: <sys/uio.h>

typedef struct iovec {
caddr_t
iov_base;
int
iov_len;
} iovec_t;

Figure 6-138: <ulimit.h>

#define UL_GETFSIZE
#define UL_SETFSIZE

1
2

Figure 6-139: <unistd.h>, Part 1 of 2

#define R_OK
#define W_OK
#define X_OK
#define F_OK

4
2
1
0

#define F_ULOCK
#define F_LOCK
#define F_TLOCK
#define F_TEST

0
1
2
3

#define SEEK_SET
#define SEEK_CUR
#define SEEK_END

0
1
2

#define _SC_ARG_MAX
#define _SC_CHILD_MAX
#define _SC_CLK_TCK

1
2
3

System Data Interfaces

6-117

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 208

Figure 6-139: <unistd.h>, Part 1 of 2 (continued )

#define _SC_NGROUPS_MAX
#define _SC_OPEN_MAX
#define _SC_JOB_CONTROL
#define _SC_SAVED_IDS
#define _SC_VERSION
#define _SC_PASS_MAX
#define _SC_LOGNAME_MAX
#define _SC_PAGESIZE
#define _SC_XOPEN_VERSION

4
5
6
7
8
9
10
11
12

#define _CS_PATH
#define _CS_HOSTNAME
#define _CS_RELEASE
#define _CS_VERSION
#define _CS_MACHINE
#define _CS_ARCHITECTURE
#define _CS_HW_SERIAL
#define _CS_HW_PROVIDER
#define _CS_SRPC_DOMAIN
#define _CS_SYSNAME

1
2
3
4
5
6
7
8
9
11

6-118

M
M
M
M
M
M
M
M
M
M

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 209

Figure 6-140: <unistd.h>, Part 2 of 2

#define _PC_LINK_MAX
#define _PC_MAX_CANON
#define _PC_MAX_INPUT
#define _PC_NAME_MAX
#define _PC_PATH_MAX
#define _PC_PIPE_BUF
#define _PC_NO_TRUNC
#define _PC_VDISABLE
#define _PC_CHOWN_RESTRICTED

1
2
3
4
5
6
7
8
9

#define _POSIX_JOB_CONTROL
#define _POSIX_SAVED_IDS
#define _POSIX_VDISABLE

1
1
0

#define _POSIX_VERSION
#define _XOPEN_VERSION

*
*

/* starred values vary and should be
retrieved using sysconf() or pathconf() */
#define STDIN_FILENO
#define STDOUT_FILENO
#define STDERR_FILENO

0
1
2

Figure 6-141: <utime.h>

struct utimbuf {
time_t
time_t
};

actime;
modtime;

System Data Interfaces

6-119

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 210

Figure 6-142: <sys/utsname.h>

#define SYS_NMLN

257

struct utsname {
char sysname[SYS_NMLN];
char nodename[SYS_NMLN];
char release[SYS_NMLN];
char version[SYS_NMLN];
char machine[SYS_NMLN];
};

6-120

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 211

Figure 6-143: <wait.h>

#define WEXITED
#define WTRAPPED
#define WSTOPPED
#define WCONTINUED
#define WUNTRACED
#define WNOHANG
#define WNOWAIT

0001
0002
0004
0010
0004
0100
0200

#define WCONTFLG
#define WCOREFLG

0177777
0200

#define WWORD(stat)

((int)((stat))&0177777)

#define WSTOPFLG
0177
#define WSIGMASK
0177
#define WLOBYTE(stat) ((int)((stat)&0377))
#define WHIBYTE(stat) ((int)(((stat)>>8)&0377))
#define WIFEXITED(stat)
#define WIFSIGNALED(stat)
#define WIFSTOPPED(stat)

(WLOBYTE(stat)==0)
(WLOBYTE(stat)>0&&WHIBYTE(stat)==0)
(WLOBYTE(stat)==WSTOPFLG&&WHIBYTE(stat)!=0)

#define WIFCONTINUED(stat)

(WWORD(stat)==WCONTFLG)

#define WEXITSTATUS(stat)
#define WTERMSIG(stat)
#define WSTOPSIG(stat)

WHIBYTE(stat)
(WLOBYTE(stat)&WSIGMASK)
WHIBYTE(stat)

#define WCOREDUMP(stat)

((stat)&WCOREFLG)

System Data Interfaces

6-121

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 212

Figure 6-144: <wchar.h>

typedef long wchar_t;
typedef unsigned int
typedef long wint_t;
typedef struct
{
wchar_t
wchar_t
} mbstate_t;

size_t;

;
;

#define NULL 0
#define WEOF (-1)
#define WCHAR_MAX

2147483647

#define WCHAR_MIN

(-2147483647-1)

#define mbrlen(x, n, p)

mbrtowc((wchar_t *)0, x, n, p)

6-122

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 213

Figure 6-145: <wctype.h> *, Part 1 of 3

typedef long
wint_t;
typedef unsigned long
wctype_t;
#define WEOF (-1)
#define
#define
#define
#define
#define
#define
#define
#define

_U
_L
_N
_S
_P
_C
_B
_X

01
02
04
010
020
040
0100
0200

#define
#define
#define
#define
#define
#define
#define
#define
#define
#define
#define
#define
#define
#define
#define
#define
#define
#define
#define
#define
#define

_E1
_E2
_E3
_E4
_E5
_E6
_E7
_E8
_E9
_E10
_E11
_E12
_E13
_E14
_E15
_E16
_E17
_E18
_E19
_E20
_E21

0x00000100
0x00000200
0x00000400
0x00000800
0x00001000
0x00002000
0x00004000
0x00008000
0x00010000
0x00020000
0x00040000
0x00080000
0x00100000
0x00200000
0x00400000
0x00800000
0x01000000
0x02000000
0x04000000
0x08000000
0x10000000

System Data Interfaces

6-123

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 214

Figure 6-146: <wctype.h> *, Part 2 of 3

#define _PD_ALNUM
#define _PD_ALPHA
#define _PD_BLANK
#define _PD_CNTRL
#define _PD_DIGIT
#define _PD_GRAPH

(_U | _L | _N)
(_U | _L)
(_B)
(_C)
(_N)
(_P | _U | _L | _N | _E1 |
_E2 | _E5 | _E6)
#define _PD_LOWER (_L)
#define _PD_PRINT (_P | _U | _L | _N | _B |
_E1 | _E2 | _E5 | _E6)
#define _PD_PUNCT (_P)
#define _PD_SPACE (_S)
#define _PD_UPPER (_U)
#define _PD_XDIGIT (_X)
#define iswalnum(c)
#define iswalpha(c)
#define iswcntrl(c)
#define iswdigit(c)
#define iswgraph(c)
#define iswlower(c)
#define iswprint(c)
#define iswpunct(c)
#define iswspace(c)
#define iswupper(c)
#define iswxdigit(c)
#define towlower(c)
#define towupper(c)
#define isphonogram(c)
#define isideogram(c)
#define isenglish(c)
#define isnumber(c)
#define isspecial(c)

__isw(c, _PD_ALNUM)
__isw(c, _PD_ALPHA)
__isw(c, _PD_CNTRL)
__isw(c, _PD_DIGIT)
__isw(c, _PD_GRAPH)
__isw(c, _PD_LOWER)
__isw(c, _PD_PRINT)
__isw(c, _PD_PUNCT)
__isw(c, _PD_SPACE)
__isw(c, _PD_UPPER)
__isw(c, _PD_XDIGIT)
__tow(c, _PD_UPPER)
__tow(c, _PD_LOWER)
__isx(c, _E1)
__isx(c, _E2)
__isx(c, _E3)
__isx(c, _E4)
__isx(c, _E5)

6-124

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 215

Figure 6-147: <wctype.h> *, Part 3 of 3

#define iscodeset0(c)
#define iscodeset1(c)
#define iscodeset2(c)
#define iscodeset3(c)

(((c) & ˜(wchar_t)0xff) == 0)
(((c) >> 28) == 0x3)
(((c) >> 28) == 0x1)
(((c) >> 28) == 0x2)

inline int __isw(wint_t c, wctype_t t){
if (c > 255)
return (__iswctype(c, t));
return (1 + __ctype)[c] & t ;
}
inline int __isx(wint_t c, wctype_t t){
return (c > 255 && __iswctype(c, t));
}
inline wint_t __tow(wint_t c, wctype_t t){
if (c > 255)
return (__trwctype(c, t));
if ((1 + __ctype)[c] & t )
return (258 + __ctype)[c];
return (c);
}

NOTE

The construction inline is a syntactic extension to ANSI C and may not be
supported by all C compilers. The intended semantics are to behave like regular preprocessor function like macros except parameter names are local and
expressions giving their initial values are evaluated exactly once.

System Data Interfaces

M
M

6-125

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 216

Figure 6-148: <wordexp.h> *

#define WRDE_APPEND
#define WRDE_DOOFFS
#define WRDE_NOCMD
#define WRDE_REUSE
#define WRDE_SHOWERR
#define WRDE_UNDEF

0001
0002
0004
0010
0020
0040

M
M
M
M
M
M

#define WRDE_NOSYS
#define WRDE_BADCHAR
#define WRDE_BADVAL
#define WRDE_CMDSUB
#define WRDE_NOSPACE
#define WRDE_SYNTAX

(-1)
(-2)
(-3)
(-4)
(-5)
(-6)

M
M
M
M
M
M
M
M
M
M
M
M

typedef struct
{
size_t we_wordc;
char **we_wordv;
size_t we_offs;
} wordexp_t;

6-126

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 217

X Window Data Definitions
NOTE

This section is new to the Third Edition of this document, but will not be marked with
the "G" diff-mark.

This section contains standard data definitions that describe system data for the
optional X Window System libraries listed in the Generic ABI. These data
definitions are referred to by their names in angle brackets: <name.h> and
<sys/name.h>. Included in these data definitions are macro definitions and structure definitions. While an ABI-conforming system may provide X11 and X Toolkit
Intrinsics interfaces, it need not contain the actual data definitions referenced here.
Programmers should observe that the sources of the structures defined in these
data definitions are defined in SVID or the appropriate X Consortium documentation (see chapter 10 in the Generic ABI).

System Data Interfaces

6-127

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 218

Figure 6-149: <X11/Atom.h>, Part 1 of 3

#define XA_PRIMARY
#define XA_SECONDARY
#define XA_ARC
#define XA_ATOM
#define XA_BITMAP
#define XA_CARDINAL
#define XA_COLORMAP
#define XA_CURSOR
#define XA_CUT_BUFFER0
#define XA_CUT_BUFFER1
#define XA_CUT_BUFFER2
#define XA_CUT_BUFFER3
#define XA_CUT_BUFFER4
#define XA_CUT_BUFFER5
#define XA_CUT_BUFFER6
#define XA_CUT_BUFFER7
#define XA_DRAWABLE
#define XA_FONT
#define XA_INTEGER
#define XA_PIXMAP
#define XA_POINT
#define XA_RECTANGLE
#define XA_RESOURCE_MANAGER
#define XA_RGB_COLOR_MAP
#define XA_RGB_BEST_MAP
#define XA_RGB_BLUE_MAP
#define XA_RGB_DEFAULT_MAP
#define XA_RGB_GRAY_MAP
#define XA_RGB_GREEN_MAP
#define XA_RGB_RED_MAP
#define XA_STRING
#define XA_VISUALID

((Atom) 1)
((Atom) 2)
((Atom) 3)
((Atom) 4)
((Atom) 5)
((Atom) 6)
((Atom) 7)
((Atom) 8)
((Atom) 9)
((Atom) 10)
((Atom) 11)
((Atom) 12)
((Atom) 13)
((Atom) 14)
((Atom) 15)
((Atom) 16)
((Atom) 17)
((Atom) 18)
((Atom) 19)
((Atom) 20)
((Atom) 21)
((Atom) 22)
((Atom) 23)
((Atom) 24)
((Atom) 25)
((Atom) 26)
((Atom) 27)
((Atom) 28)
((Atom) 29)
((Atom) 30)
((Atom) 31)
((Atom) 32)

6-128

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 219

Figure 6-150: <X11/Atom.h>, Part 2 of 3

#define XA_WINDOW
#define XA_WM_COMMAND
#define XA_WM_HINTS
#define XA_WM_CLIENT_MACHINE
#define XA_WM_ICON_NAME
#define XA_WM_ICON_SIZE
#define XA_WM_NAME
#define XA_WM_NORMAL_HINTS
#define XA_WM_SIZE_HINTS
#define XA_WM_ZOOM_HINTS
#define XA_MIN_SPACE
#define XA_NORM_SPACE
#define XA_MAX_SPACE
#define XA_END_SPACE
#define XA_SUPERSCRIPT_X
#define XA_SUPERSCRIPT_Y
#define XA_SUBSCRIPT_X
#define XA_SUBSCRIPT_Y
#define XA_UNDERLINE_POSITION
#define XA_UNDERLINE_THICKNESS
#define XA_STRIKEOUT_ASCENT
#define XA_STRIKEOUT_DESCENT
#define XA_ITALIC_ANGLE
#define XA_X_HEIGHT
#define XA_QUAD_WIDTH
#define XA_WEIGHT
#define XA_POINT_SIZE
#define XA_RESOLUTION
#define XA_COPYRIGHT
#define XA_NOTICE
#define XA_FONT_NAME
#define XA_FAMILY_NAME

((Atom) 33)
((Atom) 34)
((Atom) 35)
((Atom) 36)
((Atom) 37)
((Atom) 38)
((Atom) 39)
((Atom) 40)
((Atom) 41)
((Atom) 42)
((Atom) 43)
((Atom) 44)
((Atom) 45)
((Atom) 46)
((Atom) 47)
((Atom) 48)
((Atom) 49)
((Atom) 50)
((Atom) 51)
((Atom) 52)
((Atom) 53)
((Atom) 54)
((Atom) 55)
((Atom) 56)
((Atom) 57)
((Atom) 58)
((Atom) 59)
((Atom) 60)
((Atom) 61)
((Atom) 62)
((Atom) 63)
((Atom) 64)

System Data Interfaces

6-129

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 220

Figure 6-151: <X11/Atom.h>, Part 3 of 3

#define XA_FULL_NAME
#define XA_CAP_HEIGHT
#define XA_WM_CLASS
#define XA_WM_TRANSIENT_FOR
#define XA_LAST_PREDEFINED

((Atom) 65)
((Atom) 66)
((Atom) 67)
((Atom) 68)
((Atom) 68)

6-130

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 221

Figure 6-152: <X11/Composite.h>

extern WidgetClass compositeWidgetClass;

Figure 6-153: <X11/Constraint.h>

extern WidgetClass constraintWidgetClass;

Figure 6-154: <X11/Core.h>

extern WidgetClass coreWidgetClass;

System Data Interfaces

6-131

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 222

Figure 6-155: <X11/cursorfont.h>, Part 1 of 3

#define XC_num_glyphs
#define XC_X_cursor
#define XC_arrow
#define XC_based_arrow_down
#define XC_based_arrow_up
#define XC_boat
#define XC_bogosity
#define XC_bottom_left_corner
#define XC_bottom_right_corner
#define XC_bottom_side
#define XC_bottom_tee
#define XC_box_spiral
#define XC_center_ptr
#define XC_circle
#define XC_clock
#define XC_coffee_mug
#define XC_cross
#define XC_cross_reverse
#define XC_crosshair
#define XC_diamond_cross
#define XC_dot
#define XC_dotbox
#define XC_double_arrow
#define XC_draft_large
#define XC_draft_small
#define XC_draped_box
#define XC_exchange
#define XC_fleur
#define XC_gobbler
#define XC_gumby
#define XC_hand1
#define XC_hand2

6-132

154
0
2
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32
34
36
38
40
42
44
46
48
50
52
54
56
58
60

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 223

Figure 6-156: <X11/cursorfont.h>, Part 2 of 3

#define XC_heart
#define XC_icon
#define XC_iron_cross
#define XC_left_ptr
#define XC_left_side
#define XC_left_tee
#define XC_leftbutton
#define XC_ll_angle
#define XC_lr_angle
#define XC_man
#define XC_middlebutton
#define XC_mouse
#define XC_pencil
#define XC_pirate
#define XC_plus
#define XC_question_arrow
#define XC_right_ptr
#define XC_right_side
#define XC_right_tee
#define XC_rightbutton
#define XC_rtl_logo
#define XC_sailboat
#define XC_sb_down_arrow
#define XC_sb_h_double_arrow
#define XC_sb_left_arrow
#define XC_sb_right_arrow
#define XC_sb_up_arrow
#define XC_sb_v_double_arrow
#define XC_shuttle
#define XC_sizing
#define XC_spider
#define XC_spraycan

System Data Interfaces

62
64
66
68
70
72
74
76
78
80
82
84
86
88
90
92
94
96
98
100
102
104
106
108
110
112
114
116
118
120
122
124

6-133

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 224

Figure 6-157: <X11/cursorfont.h>, Part 3 of 3

#define XC_star
#define XC_target
#define XC_tcross
#define XC_top_left_arrow
#define XC_top_left_corner
#define XC_top_right_corner
#define XC_top_side
#define XC_top_tee
#define XC_trek
#define XC_ul_angle
#define XC_umbrella
#define XC_ur_angle
#define XC_watch
#define XC_xterm

6-134

126
128
130
132
134
136
138
140
142
144
146
148
150
152

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 225

Figure 6-158: <X11/Intrinsic.h>, Part 1 of 6

typedef char *String;
#define XtNumber(arr)\
((Cardinal) (sizeof(arr) / sizeof(arr[0])))
typedef void
typedef Widget
typedef void
typedef void
typedef XtActionsRec

*Widget;
*WidgetList;
*CompositeWidget;
*WidgetClass;
*XtActionList;

typedef void
*XtAppContext;
typedef unsigned long
XtValueMask;
typedef unsigned long
XtIntervalId;
typedef unsigned long
XtInputId;
typedef unsigned long
XtWorkProcId;
typedef unsigned int
XtGeometryMask;
typedef unsigned long
XtGCMask;
typedef unsigned long
Pixel;
typedef int
XtCacheType;
#define
XtCacheNone
0x001
#define
XtCacheAll
0x002
#define
XtCacheByDisplay
0x003
#define
XtCacheRefCount
0x100
typedef char
typedef long
typedef unsigned char

Boolean;
XtArgVal;
XtEnum;

typedef unsigned int
typedef unsigned short
typedef short

Cardinal;
Dimension;
Position;

typedef void

*XtPointer;

System Data Interfaces

6-135

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 226

Figure 6-159: <X11/Intrinsic.h>, Part 2 of 6

typedef void
typedef void
typedef unsigned int

*XtTranslations;
*XtAccelerators;
Modifiers;

#define XtCWQueryOnly
#define XtSMDontChange

(1 << 7)
5

typedef void *XtCacheRef;
typedef void *XtActionHookId;
typedef unsigned long
EventMask;
typedef enum {XtListHead, XtListTail } XtListPosition;
typedef unsigned long
XtInputMask;
typedef struct {
String
string;
XtActionProc proc;
} XtActionsRec;
typedef enum {
XtAddress,
XtBaseOffset,
XtImmediate,
XtResourceString,
XtResourceQuark,
XtWidgetBaseOffset,
XtProcedureArg
} XtAddressMode;
typedef struct {
XtAddressMode
address_mode;
XtPointer
address_id;
Cardinal
size;
} XtConvertArgRec, *XtConvertArgList;

6-136

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 227

Figure 6-160: <X11/Intrinsic.h>, Part 3 of 6

#define XtInputNoneMask
#define XtInputReadMask
#define XtInputWriteMask
#define XtInputExceptMask

0L
(1L<<0)
(1L<<1)
(1L<<2)

typedef struct {
XtGeometryMask request_mode;
Position
x, y;
Dimension
width, height, border_width;
Widget sibling;
} XtWidgetGeometry;
typedef struct {
String
XtArgVal
} Arg, *ArgList;

name;
value;

typedef XtPointer

XtVarArgsList;

typedef struct {
XtCallbackProc
callback;
XtPointer
closure;
} XtCallbackRec, *XtCallbackList;
typedef enum {
XtCallbackNoList,
XtCallbackHasNone,
XtCallbackHasSome
} XtCallbackStatus;
typedef struct {
Widget
shell_widget;
Widget
enable_widget;
} XtPopdownIDRec, *XtPopdownID;

System Data Interfaces

6-137

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 228

Figure 6-161: <X11/Intrinsic.h>, Part 4 of 6

typedef enum {
XtGeometryYes,
XtGeometryNo,
XtGeometryAlmost,
XtGeometryDone
} XtGeometryResult;
typedef enum {
XtGrabNone,
XtGrabNonexclusive,
XtGrabExclusive
} XtGrabKind;
typedef struct {
String
resource_name;
String
resource_class;
String
resource_type;
Cardinal
resource_size;
Cardinal
resource_offset;
String
default_type;
XtPointer
default_addr;
} XtResource, *XtResourceList;
typedef struct {
char
match;
String
substitution;
} SubstitutionRec, *Substitution;
typedef Boolean
typedef XtPointer

(*XtFilePredicate);
XtRequestId;

extern XtConvertArgRec const colorConvertArgs[];
extern XtConvertArgRec const screenConvertArg[];

6-138

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 229

Figure 6-162: <X11/Intrinsic.h>, Part 5 of 6

#define XtAllEvents ((EventMask) -1L)
#define XtIMXEvent
1
#define XtIMTimer
2
#define XtIMAlternateInput
4
#define XtIMAll (XtIMXEvent | XtIMTimer | XtIMAlternateInput)
#define XtOffsetOf(s_type,field) XtOffset(s_type*,field)
#define XtNew(type) ((type *) XtMalloc((unsigned) sizeof(type)))
#define XT_CONVERT_FAIL
(Atom)0x80000001
#define XtIsRectObj(object) \
(_XtCheckSubclassFlag(object,(XtEnum)0x02))
#define XtIsWidget(object) \
(_XtCheckSubclassFlag(object,(XtEnum)0x04))
#define XtIsComposite(widget) \
(_XtCheckSubclassFlag(widget,(XtEnum)0x08))
#define XtIsConstraint(widget) \
(_XtCheckSubclassFlag(widget,(XtEnum)0x10))
#define XtIsShell(widget) \
(_XtCheckSubclassFlag(widget,(XtEnum)0x20))
#define XtIsOverrideShell(widget) \
(_XtIsSubclassOf(widget,(WidgetClass)overrideShellWidgetClass,\
(WidgetClass)shellWidgetClass, (XtEnum)0x20))
#define XtIsWMShell(widget) \
(_XtCheckSubclassFlag(widget,(XtEnum)0x40))
#define XtIsVendorShell(widget)
\
(_XtIsSubclassOf(widget,(WidgetClass)vendorShellWidgetClass,\
(WidgetClass)wmShellWidgetClass,(XtEnum)0x40))
#define XtIsTransientShell(widget) \
(_XtIsSubclassOf(widget,(WidgetClass)transientShellWidgetClass,\
(WidgetClass)wmShellWidgetClass, (XtEnum)0x40))
#define XtIsTopLevelShell(widget)\
(_XtCheckSubclassFlag(widget, (XtEnum)0x80))
#define XtIsApplicationShell(widget)\
(_XtIsSubclassOf(widget,(WidgetClass)applicationShellWidgetClass,\
(WidgetClass)topLevelShellWidgetClass, (XtEnum)0x80))

System Data Interfaces

6-139

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 230

Figure 6-163: <X11/Intrinsic.h>, Part 6 of 6

#define XtSetArg(arg,n,d)\
((void)( (arg).name = (n), (arg).value = (XtArgVal)(d) ))
#define XtOffset(p_type,field)\
((Cardinal) (((char *) (&(((p_type)NULL)->field))) - ((char *) NULL)))
#define XtVaNestedList
"XtVaNestedList"
#define XtVaTypedArg
"XtVaTypedArg"
#define XtUnspecifiedPixmap ((Pixmap)2)
#define XtUnspecifiedShellInt
(-1)
#define XtUnspecifiedWindow ((Window)2)
#define XtUnspecifiedWindowGroup ((Window)3)
#define XtDefaultForeground "XtDefaultForeground"
#define XtDefaultBackground "XtDefaultBackground"
#define XtDefaultFont
"XtDefaultFont"
#define XtDefaultFontSet
"XtDefaultFontSet"

Figure 6-164: <X11/Object.h>

extern WidgetClass objectClass;

Figure 6-165: <X11/RectObj.h>

extern WidgetClass rectObjClass;

6-140

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 231

Figure 6-166: <X11/extensions/shape.h>*

#define ShapeSet
#define ShapeUnion
#define ShapeIntersect
#define ShapeSubtract
#define ShapeInvert

0
1
2
3
4

#define ShapeBounding
#define ShapeClip

0
1

#define ShapeNotifyMask
#define ShapeNotify

(1L << 0)
0

Figure 6-167: <X11/Shell.h>

extern WidgetClass shellWidgetClass;
extern WidgetClass overrideShellWidgetClass;
extern WidgetClass wmShellWidgetClass;
extern WidgetClass transientShellWidgetClass;
extern WidgetClass topLevelShellWidgetClass;
extern WidgetClass applicationShellWidgetClass;

Figure 6-168: <X11/Vendor.h>

extern WidgetClass vendorShellWidgetClass;

System Data Interfaces

6-141

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 232

Figure 6-169: <X11/X.h>, Part 1 of 12

typedef unsigned long XID;
typedef XID Window;
typedef XID Drawable;
typedef XID Font;
typedef XID Pixmap;
typedef XID Cursor;
typedef XID Colormap;
typedef XID GContext;
typedef XID KeySym;
typedef unsigned long Atom;
typedef unsigned long VisualID;
typedef unsigned long Time;
typedef unsigned char KeyCode;
#define AllTemporary
#define AnyButton
#define AnyKey
#define AnyPropertyType
#define CopyFromParent
#define CurrentTime
#define InputFocus
#define NoEventMask
#define None
#define NoSymbol
#define ParentRelative
#define PointerWindow
#define PointerRoot

0L
0L
0L
0L
0L
0L
1L
0L
0L
0L
1L
0L
1L

6-142

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 233

Figure 6-170: <X11/X.h>, Part 2 of 12

#define KeyPressMask
(1L<<0)
#define KeyReleaseMask
(1L<<1)
#define ButtonPressMask
(1L<<2)
#define ButtonReleaseMask
(1L<<3)
#define EnterWindowMask
(1L<<4)
#define LeaveWindowMask
(1L<<5)
#define PointerMotionMask
(1L<<6)
#define PointerMotionHintMask
(1L<<7)
#define Button1MotionMask
(1L<<8)
#define Button2MotionMask
(1L<<9)
#define Button3MotionMask
(1L<<10)
#define Button4MotionMask
(1L<<11)
#define Button5MotionMask
(1L<<12)
#define ButtonMotionMask
(1L<<13)
#define KeymapStateMask
(1L<<14)
#define ExposureMask
(1L<<15)
#define VisibilityChangeMask
(1L<<16)
#define StructureNotifyMask
(1L<<17)
#define ResizeRedirectMask
(1L<<18)
#define SubstructureNotifyMask (1L<<19)
#define SubstructureRedirectMask (1L<<20)
#define FocusChangeMask
(1L<<21)
#define PropertyChangeMask
(1L<<22)
#define ColormapChangeMask
(1L<<23)
#define OwnerGrabButtonMask
(1L<<24)

System Data Interfaces

6-143

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 234

Figure 6-171: <X11/X.h>, Part 3 of 12

#define KeyPress
2
#define KeyRelease
3
#define ButtonPress
4
#define ButtonRelease
5
#define MotionNotify
6
#define EnterNotify
7
#define LeaveNotify
8
#define FocusIn
9
#define FocusOut
10
#define KeymapNotify
11
#define Expose
12
#define GraphicsExpose
13
#define NoExpose
14
#define VisibilityNotify
15
#define CreateNotify
16
#define DestroyNotify
17
#define UnmapNotify
18
#define MapNotify
19
#define MapRequest
20
#define ReparentNotify
21
#define ConfigureNotify
22
#define ConfigureRequest
23
#define GravityNotify
24
#define ResizeRequest
25
#define CirculateNotify
26
#define CirculateRequest
27
#define PropertyNotify
28
#define SelectionClear
29
#define SelectionRequest
30
#define SelectionNotify
31
#define ColormapNotify
32
#define ClientMessage
33
#define MappingNotify
34
#define LASTEvent
35
/* must be bigger than any event # */

6-144

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 235

Figure 6-172: <X11/X.h>, Part 4 of 12

#define ShiftMask
#define LockMask
#define ControlMask
#define Mod1Mask
#define Mod2Mask
#define Mod3Mask
#define Mod4Mask
#define Mod5Mask

(1<<0)
(1<<1)
(1<<2)
(1<<3)
(1<<4)
(1<<5)
(1<<6)
(1<<7)

#define Button1Mask
#define Button2Mask
#define Button3Mask
#define Button4Mask
#define Button5Mask
#define AnyModifier

(1<<8)
(1<<9)
(1<<10)
(1<<11)
(1<<12)
(1<<15)

#define Button1
#define Button2
#define Button3
#define Button4
#define Button5

1
2
3
4
5

#define NotifyNormal
#define NotifyGrab
#define NotifyUngrab
#define NotifyWhileGrabbed
#define NotifyHint
#define NotifyAncestor
#define NotifyVirtual
#define NotifyInferior
#define NotifyNonlinear
#define NotifyNonlinearVirtual
#define NotifyPointer
#define NotifyPointerRoot
#define NotifyDetailNone

0
1
2
3
1
0
1
2
3
4
5
6
7

System Data Interfaces

6-145

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 236

Figure 6-173: <X11/X.h>, Part 5 of 12

#define VisibilityUnobscured
#define VisibilityPartiallyObscured
#define VisibilityFullyObscured

0
1
2

#define PlaceOnTop
#define PlaceOnBottom

0
1

#define PropertyNewValue
#define PropertyDelete

0
1

#define ColormapUninstalled
#define ColormapInstalled

0
1

#define GrabModeSync
#define GrabModeAsync

0
1

#define GrabSuccess
#define AlreadyGrabbed
#define GrabInvalidTime
#define GrabNotViewable
#define GrabFrozen

0
1
2
3
4

#define AsyncPointer
#define SyncPointer
#define ReplayPointer
#define AsyncKeyboard
#define SyncKeyboard
#define ReplayKeyboard
#define AsyncBoth
#define SyncBoth

0
1
2
3
4
5
6
7

#define RevertToNone
#define RevertToPointerRoot
#define RevertToParent

(int)None
(int)PointerRoot
2

6-146

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 237

Figure 6-174: <X11/X.h>, Part 6 of 12

#define Success
0
#define BadRequest
1
#define BadValue
2
#define BadWindow
3
#define BadPixmap
4
#define BadAtom
5
#define BadCursor
6
#define BadFont
7
#define BadMatch
8
#define BadDrawable
9
#define BadAccess
10
#define BadAlloc
11
#define BadColor
12
#define BadGC
13
#define BadIDChoice
14
#define BadName
15
#define BadLength
16
#define BadImplementation 17
#define InputOutput
#define InputOnly

1
2

#define CWBackPixmap
(1L<<0)
#define CWBackPixel
(1L<<1)
#define CWBorderPixmap
(1L<<2)
#define CWBorderPixel
(1L<<3)
#define CWBitGravity
(1L<<4)
#define CWWinGravity
(1L<<5)
#define CWBackingStore
(1L<<6)
#define CWBackingPlanes
(1L<<7)
#define CWBackingPixel
(1L<<8)
#define CWOverrideRedirect (1L<<9)
#define CWSaveUnder
(1L<<10)
#define CWEventMask
(1L<<11)
#define CWDontPropagate
(1L<<12)
#define CWColormap
(1L<<13)
#define CWCursor
(1L<<14)

System Data Interfaces

6-147

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 238

Figure 6-175: <X11/X.h>, Part 7 of 12

#define CWX
#define CWY
#define CWWidth
#define CWHeight
#define CWBorderWidth
#define CWSibling
#define CWStackMode

(1<<0)
(1<<1)
(1<<2)
(1<<3)
(1<<4)
(1<<5)
(1<<6)

#define ForgetGravity
#define NorthWestGravity
#define NorthGravity
#define NorthEastGravity
#define WestGravity
#define CenterGravity
#define EastGravity
#define SouthWestGravity
#define SouthGravity
#define SouthEastGravity
#define StaticGravity
#define UnmapGravity

0
1
2
3
4
5
6
7
8
9
10
0

#define NotUseful
#define WhenMapped
#define Always

0
1
2

#define IsUnmapped
#define IsUnviewable
#define IsViewable

0
1
2

#define SetModeInsert
#define SetModeDelete

0
1

#define DestroyAll
#define RetainPermanent
#define RetainTemporary

0
1
2

6-148

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 239

Figure 6-176: <X11/X.h>, Part 8 of 12

#define Above
#define Below
#define TopIf
#define BottomIf
#define Opposite
#define RaiseLowest
#define LowerHighest
#define PropModeReplace
#define PropModePrepend
#define PropModeAppend

0
1
2
3
4
0
1
0
1
2

#define GXclear
#define GXand
#define GXandReverse
#define GXcopy
#define GXandInverted
#define GXnoop
#define GXxor
#define GXor
#define GXnor
#define GXequiv
#define GXinvert
#define GXorReverse
#define GXcopyInverted
#define GXorInverted
#define GXnand
#define GXset

0x0
0x1
0x2
0x3
0x4
0x5
0x6
0x7
0x8
0x9
0xa
0xb
0xc
0xd
0xe
0xf

#define LineSolid
#define LineOnOffDash
#define LineDoubleDash
#define CapNotLast
#define CapButt
#define CapRound
#define CapProjecting

0
1
2
0
1
2
3

System Data Interfaces

6-149

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 240

Figure 6-177: <X11/X.h>, Part 9 of 12

#define JoinMiter
#define JoinRound
#define JoinBevel

0
1
2

#define FillSolid
0
#define FillTiled
1
#define FillStippled
2
#define FillOpaqueStippled 3
#define EvenOddRule
#define WindingRule

0
1

#define ClipByChildren
#define IncludeInferiors

0
1

#define Unsorted
#define YSorted
#define YXSorted
#define YXBanded

0
1
2
3

#define CoordModeOrigin
0
#define CoordModePrevious 1
#define Complex
#define Nonconvex
#define Convex

0
1
2

#define ArcChord
#define ArcPieSlice

0
1

6-150

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 241

Figure 6-178: <X11/X.h>, Part 10 of 12

#define GCFunction
#define GCPlaneMask
#define GCForeground
#define GCBackground
#define GCLineWidth
#define GCLineStyle
#define GCCapStyle
#define GCJoinStyle
#define GCFillStyle
#define GCFillRule
#define GCTile
#define GCStipple
#define GCTileStipXOrigin
#define GCTileStipYOrigin
#define GCFont
#define GCSubwindowMode
#define GCGraphicsExposures
#define GCClipXOrigin
#define GCClipYOrigin
#define GCClipMask
#define GCDashOffset
#define GCDashList
#define GCArcMode

(1L<<0)
(1L<<1)
(1L<<2)
(1L<<3)
(1L<<4)
(1L<<5)
(1L<<6)
(1L<<7)
(1L<<8)
(1L<<9)
(1L<<10)
(1L<<11)
(1L<<12)
(1L<<13)
(1L<<14)
(1L<<15)
(1L<<16)
(1L<<17)
(1L<<18)
(1L<<19)
(1L<<20)
(1L<<21)
(1L<<22)

#define FontLeftToRight
#define FontRightToLeft

0
1

#define XYBitmap
#define XYPixmap
#define ZPixmap

0
1
2

#define AllocNone
#define AllocAll

0
1

#define DoRed
#define DoGreen
#define DoBlue

(1<<0)
(1<<1)
(1<<2)

System Data Interfaces

6-151

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 242

Figure 6-179: <X11/X.h>, Part 11 of 12

#define CursorShape
#define TileShape
#define StippleShape

0
1
2

#define AutoRepeatModeOff
#define AutoRepeatModeOn
#define AutoRepeatModeDefault

0
1
2

#define LedModeOff
#define LedModeOn

0
1

#define KBKeyClickPercent
#define KBBellPercent
#define KBBellPitch
#define KBBellDuration
#define KBLed
#define KBLedMode
#define KBKey
#define KBAutoRepeatMode

(1L<<0)
(1L<<1)
(1L<<2)
(1L<<3)
(1L<<4)
(1L<<5)
(1L<<6)
(1L<<7)

#define MappingSuccess
#define MappingBusy
#define MappingFailed

0
1
2

#define MappingModifier
#define MappingKeyboard
#define MappingPointer
#define DontPreferBlanking
#define PreferBlanking
#define DefaultBlanking

0
1
2
0
1
2

#define DontAllowExposures
#define AllowExposures
#define DefaultExposures

0
1
2

6-152

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 243

Figure 6-180: <X11/X.h>, Part 12 of 12

#define ScreenSaverReset 0
#define ScreenSaverActive 1
#define EnableAccess
#define DisableAccess
#define StaticGray
#define GrayScale

1
0
0
1

#define StaticColor
#define PseudoColor
#define TrueColor
#define DirectColor

2
3
4
5

#define LSBFirst
#define MSBFirst

0
1

System Data Interfaces

6-153

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 244

Figure 6-181: <X11/Xcms.h>, Part 1 of 5

#define XcmsFailure
#define XcmsSuccess
#define XcmsSuccessWithCompression

0
1
2

#define XcmsUndefinedFormat
#define XcmsCIEXYZFormat
#define XcmsCIEuvYFormat
#define XcmsCIExyYFormat
#define XcmsCIELabFormat
#define XcmsCIELuvFormat
#define XcmsTekHVCFormat
#define XcmsRGBFormat
#define XcmsRGBiFormat

(XcmsColorFormat)0x00000000
(XcmsColorFormat)0x00000001
(XcmsColorFormat)0x00000002
(XcmsColorFormat)0x00000003
(XcmsColorFormat)0x00000004
(XcmsColorFormat)0x00000005
(XcmsColorFormat)0x00000006
(XcmsColorFormat)0x80000000
(XcmsColorFormat)0x80000001

#define XcmsInitNone
#define XcmsInitSuccess

0x00
0x01

typedef unsigned int XcmsColorFormat;
typedef double XcmsFloat;
typedef struct {
unsigned short red;
unsigned short green;
unsigned short blue;
} XcmsRGB;

6-154

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 245

Figure 6-182: <X11/Xcms.h>, Part 2 of 5

typedef struct {
XcmsFloat red;
XcmsFloat green;
XcmsFloat blue;
} XcmsRGBi;
typedef struct {
XcmsFloat X;
XcmsFloat Y;
XcmsFloat Z;
} XcmsCIEXYZ;
typedef struct {
XcmsFloat u_prime;
XcmsFloat v_prime;
XcmsFloat Y;
} XcmsCIEuvY;
typedef struct {
XcmsFloat x;
XcmsFloat y;
XcmsFloat Y;
} XcmsCIExyY;
typedef struct {
XcmsFloat L_star;
XcmsFloat a_star;
XcmsFloat b_star;
} XcmsCIELab;

System Data Interfaces

6-155

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 246

Figure 6-183: <X11/Xcms.h>, Part 3 of 5

typedef struct {
XcmsFloat L_star;
XcmsFloat u_star;
XcmsFloat v_star;
} XcmsCIELuv;
typedef struct {
XcmsFloat H;
XcmsFloat V;
XcmsFloat C;
} XcmsTekHVC;
typedef struct {
XcmsFloat pad0;
XcmsFloat pad1;
XcmsFloat pad2;
XcmsFloat pad3;
} XcmsPad;

6-156

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 247

Figure 6-184: <X11/Xcms.h>, Part 4 of 5

typedef struct {
union {
XcmsRGB
RGB;
XcmsRGBi
RGBi;
XcmsCIEXYZ
CIEXYZ;
XcmsCIEuvY
CIEuvY;
XcmsCIExyY
CIExyY;
XcmsCIELab
CIELab;
XcmsCIELuv
CIELuv;
XcmsTekHVC
TekHVC;
XcmsPad
Pad;
}
spec;
unsigned longpixel;
XcmsColorFormat
format;
} XcmsColor;
typedef struct {
XcmsColor
XPointer
XPointer
unsigned char
char
} XcmsPerScrnInfo;

screenWhitePt;
functionSet;
screenData;
state;
pad[3];

typedef void *XcmsCCC;
typedef Status (*XcmsConversionProc)();
typedef XcmsConversionProc *XcmsFuncListPtr;

System Data Interfaces

6-157

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 248

Figure 6-185: <X11/Xcms.h>, Part 5 of 5

typedef struct {
char
XcmsColorFormat
XcmsParseStringProc
XcmsFuncListPtr
XcmsFuncListPtr
int
} XcmsColorSpace;

*prefix;
id;
parseString;
to_CIEXYZ;
from_CIEXYZ;
inverse_flag;

typedef struct {
XcmsColorSpace
XcmsScreenInitProc
XcmsScreenFreeProc
} XcmsFunctionSet;

**DDColorSpaces;
screenInitProc;
screenFreeProc;

6-158

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 249

Figure 6-186: <X11/Xlib.h>, Part 1 of 27

typedef void *XPointer;
#define Bool
#define Status
#define True
#define False
#define QueuedAlready
#define QueuedAfterReading
#define QueuedAfterFlush

int
int
1
0
0
1
2

#define AllPlanes

((unsigned long)˜0L)

Figure 6-187: <X11/Xlib.h>, Part 2 of 27

typdef void XExtData;
typdef void XExtCodes;
typedef struct {
int depth;
int bits_per_pixel;
int scanline_pad;
} XPixmapFormatValues;

System Data Interfaces

6-159

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 250

Figure 6-188: <X11/Xlib.h>, Part 3 of 27

typedef struct {
int function;
unsigned long plane_mask;
unsigned long foreground;
unsigned long background;
int line_width;
int line_style;
int cap_style;
int join_style;
int fill_style;
int fill_rule;
int arc_mode;
Pixmap tile;
Pixmap stipple;
int ts_x_origin;
int ts_y_origin;
Font font;
int subwindow_mode;
Bool graphics_exposures;
int clip_x_origin;
int clip_y_origin;
Pixmap clip_mask;
int dash_offset;
char dashes;
} XGCValues;
typedef void *GC;
typedef struct _dummy Visual;

6-160

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 251

Figure 6-189: <X11/Xlib.h>, Part 4 of 27

typedef struct _dummy Screen;
typedef struct {
Pixmap background_pixmap;
unsigned long background_pixel;
Pixmap border_pixmap;
unsigned long border_pixel;
int bit_gravity;
int win_gravity;
int backing_store;
unsigned long backing_planes;
unsigned long backing_pixel;
Bool save_under;
long event_mask;
long do_not_propagate_mask;
Bool override_redirect;
Colormap colormap;
Cursor cursor;
} XSetWindowAttributes;

System Data Interfaces

6-161

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 252

Figure 6-190: <X11/Xlib.h>, Part 5 of 27

typedef struct _dummy ScreenFormat;
typedef struct {
int x, y;
int width, height;
int border_width;
int depth;
Visual *visual;
Window root;
int class;
int bit_gravity;
int win_gravity;
int backing_store;
unsigned long backing_planes;
unsigned long backing_pixel;
Bool save_under;
Colormap colormap;
Bool map_installed;
int map_state;
long all_event_masks;
long your_event_mask;
long do_not_propagate_mask;
Bool override_redirect;
Screen *screen;
} XWindowAttributes;

6-162

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 253

Figure 6-191: <X11/Xlib.h>, Part 6 of 27

typedef struct {
int family;
int length;
char *address;
} XHostAddress;
typedef struct _XImage {
int width, height;
int xoffset;
int format;
char *data;
int byte_order;
int bitmap_unit;
int bitmap_bit_order;
int bitmap_pad;
int depth;
int bytes_per_line;
int bits_per_pixel;
unsigned long red_mask;
unsigned long green_mask;
unsigned long blue_mask;
XPointer obdata;
struct funcs {
struct _XImage *(*create_image)();
int (*destroy_image)();
unsigned long (*get_pixel)();
int (*put_pixel)();
struct _XImage *(*sub_image)();
int (*add_pixel)();
} f;
} XImage;

System Data Interfaces

6-163

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 254

Figure 6-192: <X11/Xlib.h>, Part 7 of 27

typedef struct {
int x, y;
int width, height;
int border_width;
Window sibling;
int stack_mode;
} XWindowChanges;
typedef struct {
unsigned long pixel;
unsigned short red, green, blue;
char flags;
char pad;
} XColor;
typedef struct {
short x1, y1, x2, y2;
} XSegment;
typedef struct {
short x, y;
} XPoint;
typedef struct {
short x, y;
unsigned short width, height;
} XRectangle;
typedef struct {
short x, y;
unsigned short width, height;
short angle1, angle2;
} XArc;

6-164

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 255

Figure 6-193: <X11/Xlib.h>, Part 8 of 27

typedef struct {
int key_click_percent;
int bell_percent;
int bell_pitch;
int bell_duration;
int led;
int led_mode;
int key;
int auto_repeat_mode;
} XKeyboardControl;
typedef struct {
int key_click_percent;
int bell_percent;
unsigned int bell_pitch, bell_duration;
unsigned long led_mask;
int global_auto_repeat;
char auto_repeats[32];
} XKeyboardState;
typedef struct {
Time time;
short x, y;
} XTimeCoord;
typedef struct {
int
max_keypermod;
KeyCode
*modifiermap;
} XModifierKeymap;
typedef struct _dummy Display;

System Data Interfaces

6-165

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 256

Figure 6-194: <X11/Xlib.h>, Part 9 of 27

typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window window;
Window root;
Window subwindow;
Time time;
int x, y;
int x_root, y_root;
unsigned int state;
unsigned int keycode;
Bool same_screen;
} XKeyEvent;
typedef XKeyEvent XKeyPressedEvent;
typedef XKeyEvent XKeyReleasedEvent;
typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window window;
Window root;
Window subwindow;
Time time;
int x, y;
int x_root, y_root;
unsigned int state;
unsigned int button;
Bool same_screen;
} XButtonEvent;
typedef XButtonEvent XButtonPressedEvent;
typedef XButtonEvent XButtonReleasedEvent;

6-166

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 257

Figure 6-195: <X11/Xlib.h>, Part 10 of 27

typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window window;
Window root;
Window subwindow;
Time time;
int x, y;
int x_root, y_root;
unsigned int state;
char is_hint;
Bool same_screen;
} XMotionEvent;
typedef XMotionEvent XPointerMovedEvent;
typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window window;
Window root;
Window subwindow;
Time time;
int x, y;
int x_root, y_root;
int mode;
int detail;
Bool same_screen;
Bool focus;
unsigned int state;
} XCrossingEvent;

System Data Interfaces

6-167

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 258

Figure 6-196: <X11/Xlib.h>, Part 11 of 27

typedef XCrossingEvent XEnterWindowEvent;
typedef XCrossingEvent XLeaveWindowEvent;
typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window window;
int mode;
int detail;
} XFocusChangeEvent;
typedef XFocusChangeEvent XFocusInEvent;
typedef XFocusChangeEvent XFocusOutEvent;
typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window window;
char key_vector[32];
} XKeymapEvent;
typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window window;
int x, y;
int width, height;
int count;
} XExposeEvent;

6-168

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 259

Figure 6-197: <X11/Xlib.h>, Part 12 of 27

typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Drawable drawable;
int x, y;
int width, height;
int count;
int major_code;
int minor_code;
} XGraphicsExposeEvent;
typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Drawable drawable;
int major_code;
int minor_code;
} XNoExposeEvent;
typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window window;
int state;
} XVisibilityEvent;

System Data Interfaces

6-169

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 260

Figure 6-198: <X11/Xlib.h>, Part 13 of 27

typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window parent;
Window window;
int x, y;
int width, height;
int border_width;
Bool override_redirect;
} XCreateWindowEvent;
typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window event;
Window window;
} XDestroyWindowEvent;
typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window event;
Window window;
Bool from_configure;
} XUnmapEvent;

6-170

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 261

Figure 6-199: <X11/Xlib.h>, Part 14 of 27

typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window event;
Window window;
Bool override_redirect;
} XMapEvent;
typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window parent;
Window window;
} XMapRequestEvent;
typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window event;
Window window;
Window parent;
int x, y;
Bool override_redirect;
} XReparentEvent;

System Data Interfaces

6-171

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 262

Figure 6-200: <X11/Xlib.h>, Part 15 of 27

typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window event;
Window window;
int x, y;
int width, height;
int border_width;
Window above;
Bool override_redirect;
} XConfigureEvent;
typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window event;
Window window;
int x, y;
} XGravityEvent;
typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window window;
int width, height;
} XResizeRequestEvent;

6-172

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 263

Figure 6-201: <X11/Xlib.h>, Part 16 of 27

typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window parent;
Window window;
int x, y;
int width, height;
int border_width;
Window above;
int detail;
unsigned long value_mask;
} XConfigureRequestEvent;
typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window event;
Window window;
int place;
} XCirculateEvent;
typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window parent;
Window window;
int place;
} XCirculateRequestEvent;

System Data Interfaces

6-173

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 264

Figure 6-202: <X11/Xlib.h>, Part 17 of 27

typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window window;
Atom atom;
Time time;
int state;
} XPropertyEvent;
typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window window;
Atom selection;
Time time;
} XSelectionClearEvent;
typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window owner;
Window requestor;
Atom selection;
Atom target;
Atom property;
Time time;
} XSelectionRequestEvent;

6-174

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 265

Figure 6-203: <X11/Xlib.h>, Part 18 of 27

typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window requestor;
Atom selection;
Atom target;
Atom property;
Time time;
} XSelectionEvent;
typedef struct {
int type;
Display *display;
XID resourceid;
unsigned long serial;
unsigned char error_code;
unsigned char request_code;
unsigned char minor_code;
} XErrorEvent;
typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window window;
Atom message_type;
int format;
union {
char b[20];
short s[10];
long l[5];
} data;
} XClientMessageEvent;

System Data Interfaces

6-175

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 266

Figure 6-204: <X11/Xlib.h>, Part 19 of 27

typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window window;
Colormap colormap;
Bool new;
int state;
} XColormapEvent;
typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window window;
int request;
int first_keycode;
int count;
} XMappingEvent;
typedef struct {
int type;
unsigned long serial;
Bool send_event;
Display *display;
Window window;
} XAnyEvent;

6-176

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 267

Figure 6-205: <X11/Xlib.h>, Part 20 of 27

typedef union _XEvent {
int
XAnyEvent
XKeyEvent
XButtonEvent
XMotionEvent
XCrossingEvent
XFocusChangeEvent
XExposeEvent
XGraphicsExposeEvent
XNoExposeEvent
XVisibilityEvent
XCreateWindowEvent
XDestroyWindowEvent
XUnmapEvent
XMapEvent
XMapRequestEvent
XReparentEvent
XConfigureEvent
XGravityEvent
XResizeRequestEvent
XConfigureRequestEvent
XCirculateEvent
XCirculateRequestEvent
XPropertyEvent
XSelectionClearEvent
XSelectionRequestEvent
XSelectionEvent
XColormapEvent
XClientMessageEvent
XMappingEvent
XErrorEvent
XKeymapEvent
long
} XEvent;

type;
xany;
xkey;
xbutton;
xmotion;
xcrossing;
xfocus;
xexpose;
xgraphicsexpose;
xnoexpose;
xvisibility;
xcreatewindow;
xdestroywindow;
xunmap;
xmap;
xmaprequest;
xreparent;
xconfigure;
xgravity;
xresizerequest;
xconfigurerequest;
xcirculate;
xcirculaterequest;
xproperty;
xselectionclear;
xselectionrequest;
xselection;
xcolormap;
xclient;
xmapping;
xerror;
xkeymap;
pad[24];

System Data Interfaces

6-177

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 268

Figure 6-206: <X11/Xlib.h>, Part 21 of 27

typedef struct {
short lbearing;
short rbearing;
short width;
short ascent;
short descent;
unsigned short attributes;
} XCharStruct;
typedef struct {
Atom name;
unsigned long card32;
} XFontProp;
typedef struct {
XExtData
Font
unsigned
unsigned
unsigned
unsigned
unsigned
Bool
unsigned
int
XFontProp
XCharStruct
XCharStruct
XCharStruct
int
int
} XFontStruct;

*ext_data;
fid;
direction;
min_char_or_byte2;
max_char_or_byte2;
min_byte1;
max_byte1;
all_chars_exist;
default_char;
n_properties;
*properties;
min_bounds;
max_bounds;
*per_char;
ascent;
descent;

6-178

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 269

Figure 6-207: <X11/Xlib.h>, Part 22 of 27

typedef struct {
char *chars;
int nchars;
int delta;
Font font;
} XTextItem;
typedef struct {
unsigned char byte1;
unsigned char byte2;
} XChar2b;
typedef struct {
XChar2b *chars;
int nchars;
int delta;
Font font;
} XTextItem16;
typedef union {
Display *display;
GC gc;
Visual *visual;
Screen *screen;
ScreenFormat *pixmap_format;
XFontStruct *font;
} XEDataObject;
typedef struct {
XRectangle
max_ink_extent;
XRectangle
max_logical_extent;
} XFontSetExtents;
typedef struct _dummy XFontSet;

System Data Interfaces

6-179

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 270

Figure 6-208: <X11/Xlib.h>, Part 23 of 27

typedef struct {
char
int
int
XFontSet
} XmbTextItem;

*chars;
nchars;
delta;
*font_set;

typedef struct {
wchar_t
int
int
XFontSet
} XwcTextItem;

*chars;
nchars;
delta;
font_set;

typedef void (*XIMProc)();
typedef void *XIM;
typedef void *XIC;
typedef unsigned long XIMStyle;
typedef struct {
unsigned short count_styles;
XIMStyle *supported_styles;
} XIMStyles;
#define XIMPreeditArea
#define XIMPreeditCallbacks
#define XIMPreeditPosition
#define XIMPreeditNothing
#define XIMPreeditNone
#define XIMStatusArea
#define XIMStatusCallbacks
#define XIMStatusNothing
#define XIMStatusNone

0x0001L
0x0002L
0x0004L
0x0008L
0x0010L
0x0100L
0x0200L
0x0400L
0x0800L

6-180

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 271

Figure 6-209: <X11/Xlib.h>, Part 24 of 27

#define XNVaNestedList
#define XNQueryInputStyle
#define XNClientWindow
#define XNInputStyle
#define XNFocusWindow
#define XNResourceName
#define XNResourceClass
#define XNGeometryCallback
#define XNFilterEvents
#define XNPreeditStartCallback
#define XNPreeditDoneCallback
#define XNPreeditDrawCallback
#define XNPreeditCaretCallback
#define XNPreeditAttributes
#define XNStatusStartCallback
#define XNStatusDoneCallback
#define XNStatusDrawCallback
#define XNStatusAttributes
#define XNArea
#define XNAreaNeeded
#define XNSpotLocation
#define XNColormap
#define XNStdColormap
#define XNForeground
#define XNBackground
#define XNBackgroundPixmap
#define XNFontSet
#define XNLineSpace
#define XNCursor

"XNVaNestedList"
"queryInputStyle"
"clientWindow"
"inputStyle"
"focusWindow"
"resourceName"
"resourceClass"
"geometryCallback"
"filterEvents"
"preeditStartCallback"
"preeditDoneCallback"
"preeditDrawCallback"
"preeditCaretCallback"
"preeditAttributes"
"statusStartCallback"
"statusDoneCallback"
"statusDrawCallback"
"statusAttributes"
"area"
"areaNeeded"
"spotLocation"
"colorMap"
"stdColorMap"
"foreground"
"background"
"backgroundPixmap"
"fontSet"
"lineSpace"
"cursor"

System Data Interfaces

6-181

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 272

Figure 6-210: <X11/Xlib.h>, Part 25 of 27

#define XBufferOverflow
#define XLookupNone
#define XLookupChars
#define XLookupKeySym
#define XLookupBoth

-1
1
2
3
4

typedef XPointer XVaNestedList;
typedef struct {
XPointer client_data;
XIMProc callback;
} XIMCallback;
typedef unsigned long XIMFeedback;
#define XIMReverse
#define XIMUnderline
#define XIMHighlight
#define XIMPrimary
#define XIMSecondary
#define XIMTertiary

1
(1<<1)
(1<<2)
(1<<5)
(1<<6)
(1<<7)

typedef struct _XIMText {
unsigned short length;
XIMFeedback *feedback;
Bool encoding_is_wchar;
union {
char *multi_byte;
wchar_t *wide_char;
} string;
} XIMText;

6-182

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 273

Figure 6-211: <X11/Xlib.h>, Part 26 of 27

typedef struct _XIMPreeditDrawCallbackStruct {
int caret;
int chg_first;
int chg_length;
XIMText *text;
} XIMPreeditDrawCallbackStruct;
typedef enum {
XIMForwardChar, XIMBackwardChar,
XIMForwardWord, XIMBackwardWord,
XIMCaretUp, XIMCaretDown,
XIMNextLine, XIMPreviousLine,
XIMLineStart, XIMLineEnd,
XIMAbsolutePosition,
XIMDontChange
} XIMCaretDirection;
typedef enum {
XIMIsInvisible,
XIMIsPrimary,
XIMIsSecondary
} XIMCaretStyle;
typedef struct _XIMPreeditCaretCallbackStruct {
int position;
XIMCaretDirection direction;
XIMCaretStyle style;
} XIMPreeditCaretCallbackStruct;

System Data Interfaces

6-183

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 274

Figure 6-212: <X11/Xlib.h>, Part 27 of 27

typedef enum {
XIMTextType,
XIMBitmapType
} XIMStatusDataType;
typedef struct _XIMStatusDrawCallbackStruct {
XIMStatusDataType type;
union {
XIMText *text;
Pixmap bitmap;
} data;
} XIMStatusDrawCallbackStruct;

6-184

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 275

Figure 6-213: <X11/Xresource.h>, Part 1 of 2

typedef int
#define NULLQUARK

XrmQuark, *XrmQuarkList;
((XrmQuark) 0)

typedef enum {XrmBindTightly, XrmBindLoosely} \
XrmBinding, *XrmBindingList;
typedef XrmQuark
typedef XrmQuarkList
typedef XrmQuark
typedef XrmQuarkList
typedef XrmQuark

XrmName;
XrmNameList;
XrmClass;
XrmClassList;
XrmRepresentation;

#define XrmStringToName(string)
XrmStringToQuark(string)
#define XrmStringToNameList(str, name)
XrmStringToQuarkList(str, name)
#define XrmStringToClass(class)
XrmStringToQuark(class)
#define XrmStringToClassList(str,class)
XrmStringToQuarkList(str, class)
#define XrmStringToRepresentation(string) XrmStringToQuark(string)
typedef struct {
unsigned int
XPointer
} XrmValue, *XrmValuePtr;

size;
addr;

typedef void
typedef XrmHashBucket
typedef XrmHashTable
typedef void

*XrmHashBucket;
*XrmHashTable;
XrmSearchList[];
*XrmDatabase;

#define XrmEnumAllLevels
#define XrmEnumOneLevel

0
1

System Data Interfaces

6-185

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 276

Figure 6-214: <X11/Xresource.h>, Part 2 of 2

typedef enum {
XrmoptionNoArg,
XrmoptionIsArg,
XrmoptionStickyArg,
XrmoptionSepArg,
XrmoptionResArg,
XrmoptionSkipArg,
XrmoptionSkipLine,
XrmoptionSkipNArgs
} XrmOptionKind;
typedef struct {
char
*option;
char
*specifier;
XrmOptionKind
argKind;
XPointer
value;
} XrmOptionDescRec, *XrmOptionDescList;

6-186

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 277

Figure 6-215: <X11/Xutil.h>, Part 1 of 5

#define NoValue
0x0000
#define XValue 0x0001
#define YValue 0x0002
#define WidthValue
0x0004
#define HeightValue 0x0008
#define AllValues
0x000F
#define XNegative
0x0010
#define YNegative
0x0020
typedef struct {
long flags;
int x, y;
int width, height;
int min_width, min_height;
int max_width, max_height;
int width_inc, height_inc;
struct {
int x;
int y;
} min_aspect, max_aspect;
int base_width, base_height;
int win_gravity;
} XSizeHints;
#define USPosition
(1L << 0)
#define USSize (1L << 1)
#define PPosition
(1L << 2)
#define PSize
(1L << 3)
#define PMinSize
(1L << 4)
#define PMaxSize
(1L << 5)
#define PResizeInc
(1L << 6)
#define PAspect
(1L << 7)
#define PBaseSize
(1L << 8)
#define PWinGravity (1L << 9)
#define PAllHints (PPosition|PSize|PMinSize|PMaxSize|PResizeInc|PAspect)

System Data Interfaces

6-187

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 278

Figure 6-216: <X11/Xutil.h>, Part 2 of 5

typedef struct {
long
flags;
Bool
input;
int
initial_state;
Pixmap icon_pixmap;
Window icon_window;
int
icon_x, icon_y;
Pixmap icon_mask;
XID
window_group;
} XWMHints;
#define InputHint
(1L << 0)
#define StateHint
(1L << 1)
#define IconPixmapHint
(1L << 2)
#define IconWindowHint
(1L << 3)
#define IconPositionHint
(1L << 4)
#define IconMaskHint (1L << 5)
#define WindowGroupHint
(1L << 6)
#define AllHints (InputHint|StateHint|
IconPixmapHint|IconWindowHint|
IconPositionHint|IconMaskHint|WindowGroupHint)
#define WithdrawnState
#define NormalState
#define IconicState

0
1
3

typedef struct {
unsigned char
Atom
int
unsigned long
} XTextProperty;

*value;
encoding;
format;
nitems;

#define XNoMemory
#define XLocaleNotSupported -2
#define XConverterNotFound

-1
-3

6-188

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 279

Figure 6-217: <X11/Xutil.h>, Part 3 of 5

typedef int XContext;
typedef enum {
XStringStyle,
XCompoundTextStyle,
XTextStyle,
XStdICCTextStyle
} XICCEncodingStyle;
typedef struct {
int min_width, min_height;
int max_width, max_height;
int width_inc, height_inc;
} XIconSize;
typedef struct {
char *res_name;
char *res_class;
} XClassHint;
#define XDestroyImage(ximage)
((*((ximage)->f.destroy_image))((ximage)))
#define XGetPixel(ximage, x, y)
((*((ximage)->f.get_pixel))((ximage), (x), (y)))
#define XPutPixel(ximage, x, y, pixel)
((*((ximage)->f.put_pixel))((ximage), (x), (y), (pixel)))
#define XSubImage(ximage, x, y, width, height)
((*((ximage)->f.sub_image))((ximage), (x), (y), (width), (height)))
#define XAddPixel(ximage, value)
((*((ximage)->f.add_pixel))((ximage), (value)))
typedef struct _XComposeStatus {
XPointer compose_ptr;
int chars_matched;
} XComposeStatus;

System Data Interfaces

6-189

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 280

Figure 6-218: <X11/Xutil.h>, Part 4 of 5

#define IsKeypadKey(keysym)
(((unsigned)(keysym) >= XK_KP_Space) && \
((unsigned)(keysym) <= XK_KP_Equal))
#define IsCursorKey(keysym)
(((unsigned)(keysym) >= XK_Home) && \
((unsigned)(keysym) < XK_Select))
#define IsPFKey(keysym)
(((unsigned)(keysym) >= XK_KP_F1) && \
((unsigned)(keysym) <= XK_KP_F4))
#define IsFunctionKey(keysym)
(((unsigned)(keysym) >= XK_F1) && ((unsigned)(keysym) <= XK_F35))
#define IsMiscFunctionKey(keysym)
(((unsigned)(keysym) >= XK_Select) && \
((unsigned)(keysym) <= XK_Break))
#define IsModifierKey(keysym)
((((unsigned)(keysym) >= XK_Shift_L) && \
((unsigned)(keysym) <= XK_Hyper_R))
|| ((unsigned)(keysym) == XK_Mode_switch)
|| ((unsigned)(keysym) == XK_Num_Lock))
typedef void *Region;
#define RectangleOut 0
#define RectangleIn
#define RectanglePart 2

1

typedef struct {
Visual *visual;
VisualID visualid;
int
screen;
int
depth;
int
class;
unsigned long red_mask;
unsigned long green_mask;
unsigned long blue_mask;
int
colormap_size;
int
bits_per_rgb;
} XVisualInfo;

6-190

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 281

Figure 6-219: <X11/Xutil.h>, Part 5 of 5

#define VisualNoMask
0x0
#define VisualIDMask
0x1
#define VisualScreenMask
#define VisualDepthMask
#define VisualClassMask
#define VisualRedMaskMask
#define VisualGreenMaskMask 0x20
#define VisualBlueMaskMask
#define VisualColormapSizeMask
#define VisualBitsPerRGBMask 0x100
#define VisualAllMask
0x1FF
typedef struct {
Colormap
unsigned long
unsigned long
unsigned long
unsigned long
unsigned long
unsigned long
unsigned long
VisualID
XID
} XStandardColormap;

0x2
0x4
0x8
0x10
0x40
0x80

colormap;
red_max;
red_mult;
green_max;
green_mult;
blue_max;
blue_mult;
base_pixel;
visualid;
killid;

#define ReleaseByFreeingColormap ((XID) 1L)
#define BitmapSuccess
0
#define BitmapOpenFailed
1
#define BitmapFileInvalid
2
#define BitmapNoMemory
3
#define XCSUCCESS
0
#define XCNOMEM
1
#define XCNOENT
2
#define XUniqueContext()
((XContext) XrmUniqueQuark())

System Data Interfaces

M

6-191

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 282

Motif 1.2 Data Definitions
This section contains standard data definitions that describe system data for the
optional Motif 1.2 libraries. These data definitions are referred to by their names
in angle brackets: <name.h> and <sys/name.h>. Included in these data definitions
are macro definitions and structure definitions. While an ABI-conforming system
may provide Motif 1.2 interfaces, it need not contain the actual data definitions
referenced here. Programmers should observe that the sources of the structures
defined in these data definitions are defined in SVID or the appropriate Motif
documentation (see chapter 10 in the Generic ABI).

6-192

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 283

Figure 6-220: <Xm/ArrowB.h>*

typedef struct _XmArrowButtonClassRec * XmArrowButtonWidgetClass;
typedef struct _XmArrowButtonRec
* XmArrowButtonWidget;

Figure 6-221: <Xm/ArrowBG.h>*

typedef struct _XmArrowButtonGadgetClassRec * XmArrowButtonGadgetClass;
typedef struct _XmArrowButtonGadgetRec
* XmArrowButtonGadget;

Figure 6-222: <Xm/BulletinB.h>*

typedef struct _XmBulletinBoardClassRec * XmBulletinBoardWidgetClass;
typedef struct _XmBulletinBoardRec
* XmBulletinBoardWidget;

Figure 6-223: <Xm/CascadeB.h>*

typedef struct _XmCascadeButtonRec
* XmCascadeButtonWidget;
typedef struct _XmCascadeButtonClassRec * XmCascadeButtonWidgetClass;

System Data Interfaces

6-193

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 284

Figure 6-224: <Xm/CascadeBG.h>*

typedef struct _XmCascadeButtonGadgetClassRec
typedef struct _XmCascadeButtonGadgetRec
typedef struct _XmCascadeButtonGCacheObjRec

* XmCascadeButtonGadgetClass;
* XmCascadeButtonGadget;
* XmCascadeButtonGCacheObject;

Figure 6-225: <Xm/Command.h>*

typedef struct _XmCommandClassRec * XmCommandWidgetClass;
typedef struct _XmCommandRec
* XmCommandWidget;

6-194

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 285

Figure 6-226: <Xm/CutPaste.h>*

#define XmClipboardFail
#define XmClipboardSuccess
#define XmClipboardTruncate
#define XmClipboardLocked
#define XmClipboardBadFormat
#define XmClipboardNoData
#define ClipboardFail

0
1
2
4
5
6
0

#define ClipboardSuccess
#define ClipboardTruncate
#define ClipboardLocked
#define ClipboardBadFormat
#define ClipboardNoData

1
2
4
5
6

typedef struct {
long DataId;
long PrivateId;
} XmClipboardPendingRec, *XmClipboardPendingList;

Figure 6-227: <Xm/DialogS.h>*

typedef struct _XmDialogShellClassRec
typedef struct _XmDialogShellRec

* XmDialogShellWidgetClass;
* XmDialogShellWidget;

System Data Interfaces

6-195

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 286

Figure 6-228: <Xm/Display.h>*

enum {
XmDRAG_NONE,
XmDRAG_DROP_ONLY,
XmDRAG_PREFER_PREREGISTER,
XmDRAG_PREREGISTER,
XmDRAG_PREFER_DYNAMIC,
XmDRAG_DYNAMIC,
XmDRAG_PREFER_RECEIVER
};
typedef struct _XmDisplayRec *XmDisplay;
typedef struct _XmDisplayClassRec *XmDisplayClass;

6-196

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 287

Figure 6-229: <Xm/DragC.h>*, Part 1 of 4

#define XmDROP_MOVE
#define XmDROP_COPY
#define XmDROP_LINK

(1L << 0)
(1L << 1)
(1L << 2)

#define XmHELP
typedef unsigned int

XmID;

2

#define _XA_MOTIF_DROP "_MOTIF_DROP"
#define _XA_DRAG_FAILURE "_MOTIF_DRAG_FAILURE"
#define _XA_DRAG_SUCCESS "_MOTIF_DRAG_SUCCESS"
enum{

XmTOP_LEVEL_ENTER,
XmDRAG_MOTION,
XmDROP_SITE_LEAVE,
XmDROP_FINISH,
XmOPERATION_CHANGED
} ;

XmTOP_LEVEL_LEAVE,
XmDROP_SITE_ENTER,
XmDROP_START,
XmDRAG_DROP_FINISH,

enum{

XmDROP,
XmDROP_CANCEL,
} ;

XmDROP_HELP,
XmDROP_INTERRUPT

System Data Interfaces

6-197

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 288

Figure 6-230: <Xm/DragC.h>*, Part 2 of 4

#define XmDROP_NOOP

0L

enum{

XmBLEND_ALL,
XmBLEND_JUST_SOURCE,
} ;

XmBLEND_STATE_SOURCE,
XmBLEND_NONE

enum{

XmDROP_FAILURE,
} ;

XmDROP_SUCCESS

enum{

XmCR_TOP_LEVEL_ENTER,
XmCR_DRAG_MOTION,
XmCR_DROP_SITE_LEAVE,
XmCR_DROP_FINISH,
XmCR_OPERATION_CHANGED,
_XmNUMBER_DND_CB_REASONS
} ;

XmCR_TOP_LEVEL_LEAVE,
XmCR_DROP_SITE_ENTER,
XmCR_DROP_START,
XmCR_DRAG_DROP_FINISH,

typedef struct _XmDragContextClassRec
typedef struct _XmDragContextRec

*XmDragContextClass;
*XmDragContext;

typedef struct _XmAnyICCCallbackStruct{
int
reason;
XEvent
*event;
Time
timeStamp;
}XmAnyICCCallbackStruct, *XmAnyICCCallback;
typedef struct _XmTopLevelEnterCallbackStruct{
int
reason;
XEvent
*event;
Time
timeStamp;
Screen
*screen;
Window
window;
Position
x, y;
unsigned char
dragProtocolStyle;
Atom
iccHandle;
}XmTopLevelEnterCallbackStruct, *XmTopLevelEnterCallback;

6-198

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 289

Figure 6-231: <Xm/DragC.h>*, Part 3 of 4

typedef struct _XmTopLevelLeaveCallbackStruct{
int
reason;
XEvent
*event;
Time
timeStamp;
Screen
*screen;
Window
window;
}XmTopLevelLeaveCallbackStruct, *XmTopLevelLeaveCallback;
typedef struct _XmDropSiteEnterCallbackStruct{
int
reason;
XEvent
*event;
Time
timeStamp;
unsigned char
operation;
unsigned char
operations;
unsigned char
dropSiteStatus;
Position
x, y;
}XmDropSiteEnterCallbackStruct, *XmDropSiteEnterCallback;
typedef struct _XmDropSiteLeaveCallbackStruct{
int
reason;
XEvent
*event;
Time
timeStamp;
}XmDropSiteLeaveCallbackStruct, *XmDropSiteLeaveCallback;
typedef struct _XmDragMotionCallbackStruct{
int
reason;
XEvent
*event;
Time
timeStamp;
unsigned char
operation;
unsigned char
operations;
unsigned char
dropSiteStatus;
Position
x, y;
}XmDragMotionCallbackStruct, *XmDragMotionCallback;

System Data Interfaces

6-199

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 290

Figure 6-232: <Xm/DragC.h>*, Part 4 of 4

typedef struct _XmOperationChangedCallbackStruct{
int
reason;
XEvent
*event;
Time
timeStamp;
unsigned char
operation;
unsigned char
operations;
unsigned char
dropSiteStatus;
}XmOperationChangedCallbackStruct, *XmOperationChangedCallback;
typedef struct _XmDropStartCallbackStruct{
int
reason;
XEvent
*event;
Time
timeStamp;
unsigned char
operation;
unsigned char
operations;
unsigned char
dropSiteStatus;
unsigned char
dropAction;
Position
x, y;
Window
window;
Atom
iccHandle;
}XmDropStartCallbackStruct, *XmDropStartCallback;
typedef struct _XmDropFinishCallbackStruct{
int
reason;
XEvent
*event;
Time
timeStamp;
unsigned char
operation;
unsigned char
operations;
unsigned char
dropSiteStatus;
unsigned char
dropAction;
unsigned char
completionStatus;
}XmDropFinishCallbackStruct, *XmDropFinishCallback;
typedef struct _XmDragDropFinishCallbackStruct{
int
reason;
XEvent
*event;
Time
timeStamp;
}XmDragDropFinishCallbackStruct, *XmDragDropFinishCallback;

6-200

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 291

Figure 6-233: <Xm/DragIcon.h>*

enum {
XmATTACH_NORTH_WEST,
XmATTACH_NORTH,
XmATTACH_NORTH_EAST,
XmATTACH_EAST,
XmATTACH_SOUTH_EAST,
XmATTACH_SOUTH,
XmATTACH_SOUTH_WEST,
XmATTACH_WEST,
XmATTACH_CENTER,
XmATTACH_HOT
};
typedef struct _XmDragIconRec *XmDragIconObject;
typedef struct _XmDragIconClassRec *XmDragIconObjectClass;

Figure 6-234: <Xm/DragOverS.h>*

typedef struct _XmDragOverShellRec
typedef struct _XmDragOverShellClassRec

System Data Interfaces

*XmDragOverShellWidget;
*XmDragOverShellWidgetClass;

6-201

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 292

Figure 6-235: <Xm/DrawingA.h>*

typedef struct _XmDrawingAreaClassRec * XmDrawingAreaWidgetClass;
typedef struct _XmDrawingAreaRec
* XmDrawingAreaWidget;

Figure 6-236: <Xm/DrawnB.h>*

typedef struct _XmDrawnButtonClassRec *XmDrawnButtonWidgetClass;
typedef struct _XmDrawnButtonRec
*XmDrawnButtonWidget;

6-202

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 293

Figure 6-237: <Xm/DropSMgr.h>*, Part 1 of 2

#define XmCR_DROP_SITE_LEAVE_MESSAGE
#define XmCR_DROP_SITE_ENTER_MESSAGE
#define XmCR_DROP_SITE_MOTION_MESSAGE
#define XmCR_DROP_MESSAGE

1
2
3
4

#define XmNO_DROP_SITE
#define XmINVALID_DROP_SITE
#define XmVALID_DROP_SITE

1
2
3

enum { XmDRAG_UNDER_NONE, XmDRAG_UNDER_PIXMAP,
XmDRAG_UNDER_SHADOW_IN, XmDRAG_UNDER_SHADOW_OUT,
XmDRAG_UNDER_HIGHLIGHT };
enum { XmDROP_SITE_SIMPLE, XmDROP_SITE_COMPOSITE,
XmDROP_SITE_SIMPLE_CLIP_ONLY = 128,
XmDROP_SITE_COMPOSITE_CLIP_ONLY };
enum { XmABOVE, XmBELOW };
enum { XmDROP_SITE_ACTIVE, XmDROP_SITE_INACTIVE };
typedef struct _XmDragProcCallbackStruct {
int
reason;
XEvent *
event;
Time
timeStamp;
Widget
dragContext;
Position
x, y;
unsigned char
dropSiteStatus;
unsigned char
operation;
unsigned char
operations;
Boolean
animate;
} XmDragProcCallbackStruct, * XmDragProcCallback;

System Data Interfaces

6-203

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 294

Figure 6-238: <Xm/DropSMgr.h>*, Part 2 of 2

typedef struct _XmDropProcCallbackStruct {
int
reason;
XEvent *
event;
Time
timeStamp;
Widget
dragContext;
Position
x, y;
unsigned char
dropSiteStatus;
unsigned char
operation;
unsigned char
operations;
unsigned char
dropAction;
} XmDropProcCallbackStruct, * XmDropProcCallback;
typedef struct _XmDropSiteVisualsRec {
Pixel
background;
Pixel
foreground;
Pixel
topShadowColor;
Pixmap
topShadowPixmap;
Pixel
bottomShadowColor;
Pixmap
bottomShadowPixmap;
Dimension
shadowThickness;
Pixel
highlightColor;
Pixmap
highlightPixmap;
Dimension
highlightThickness;
Dimension
borderWidth;
} XmDropSiteVisualsRec, * XmDropSiteVisuals;
typedef struct _XmDropSiteManagerClassRec *XmDropSiteManagerObjectClass;
typedef struct _XmDropSiteManagerRec *XmDropSiteManagerObject;

6-204

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 295

Figure 6-239: <Xm/DropTrans.h>*

#define XmTRANSFER_FAILURE 0
#define XmTRANSFER_SUCCESS 1
typedef struct _XmDropTransferClassRec * XmDropTransferObjectClass;
typedef struct _XmDropTransferRec
* XmDropTransferObject;

typedef struct _XmDropTransferEntryRec {
XtPointer
client_data;
Atom
target;
} XmDropTransferEntryRec, * XmDropTransferEntry;

Figure 6-240: <Xm/FileSB.h>*

typedef struct _XmFileSelectionBoxClassRec * XmFileSelectionBoxWidgetClass;
typedef struct _XmFileSelectionBoxRec
* XmFileSelectionBoxWidget;

Figure 6-241: <Xm/Form.h>*

typedef struct _XmFormClassRec * XmFormWidgetClass;
typedef struct _XmFormRec
* XmFormWidget;

System Data Interfaces

6-205

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 296

Figure 6-242: <Xm/Frame.h>*

typedef struct _XmFrameClassRec * XmFrameWidgetClass;
typedef struct _XmFrameRec
* XmFrameWidget;

Figure 6-243: <Xm/Label.h>*

typedef struct _XmLabelClassRec
typedef struct _XmLabelRec

* XmLabelWidgetClass;
* XmLabelWidget;

Figure 6-244: <Xm/LabelG.h>*

typedef struct _XmLabelGadgetClassRec * XmLabelGadgetClass;
typedef struct _XmLabelGadgetRec
* XmLabelGadget;
typedef struct _XmLabelGCacheObjRec
* XmLabelGCacheObject;

6-206

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 297

Figure 6-245: <Xm/List.h>*

#define XmINITIAL
#define XmADDITION
#define XmMODIFICATION

0
1
2

typedef struct _XmListClassRec * XmListWidgetClass;
typedef struct _XmListRec
* XmListWidget;

Figure 6-246: <Xm/MainW.h>*

typedef struct _XmMainWindowClassRec * XmMainWindowWidgetClass;
typedef struct _XmMainWindowRec
* XmMainWindowWidget;

Figure 6-247: <Xm/MenuShell.h>*

typedef struct _XmMenuShellClassRec
typedef struct _XmMenuShellWidgetRec

* XmMenuShellWidgetClass;
* XmMenuShellWidget;

System Data Interfaces

6-207

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 298

Figure 6-248: <Xm/MessageB.h>*

typedef struct _XmMessageBoxClassRec * XmMessageBoxWidgetClass;
typedef struct _XmMessageBoxRec
* XmMessageBoxWidget;

6-208

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 299

Figure 6-249: <Mrm/MrmPublic.h>*, Part 1 of 3

#define MrmSUCCESS
#define MrmCREATE_NEW
#define MrmINDEX_RETRY
#define MrmINDEX_GT
#define MrmINDEX_LT
#define MrmPARTIAL_SUCCESS

1
3
5
7
9
11

#define MrmFAILURE
#define MrmNOT_FOUND
#define MrmEXISTS
#define MrmNUL_GROUP
#define MrmNUL_TYPE
#define MrmWRONG_GROUP
#define MrmWRONG_TYPE
#define MrmOUT_OF_RANGE
#define MrmBAD_RECORD
#define MrmNULL_DATA
#define MrmBAD_DATA_INDEX
#define MrmBAD_ORDER
#define MrmBAD_CONTEXT
#define MrmNOT_VALID
#define MrmBAD_BTREE
#define MrmBAD_WIDGET_REC
#define MrmBAD_CLASS_TYPE
#define MrmNO_CLASS_NAME
#define MrmTOO_MANY
#define MrmBAD_IF_MODULE
#define MrmNULL_DESC
#define MrmOUT_OF_BOUNDS
#define MrmBAD_COMPRESS
#define MrmBAD_ARG_TYPE
#define MrmNOT_IMP
#define MrmNULL_INDEX
#define MrmBAD_KEY_TYPE
#define MrmBAD_CALLBACK

0
2
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32
34
36
38
40
42
44
46
48
50
52
54

System Data Interfaces

6-209

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 300

Figure 6-250: <Mrm/MrmPublic.h>*, Part 2 of 3

#define MrmNULL_ROUTINE
#define MrmVEC_TOO_BIG
#define MrmBAD_HIERARCHY
#define MrmBAD_CLASS_CODE
#define MrmDISPLAY_NOT_OPENED
#define MrmEOF
#define MrmUNRESOLVED_REFS
#define MrmNcreateCallback
#define MrmCR_CREATE

56
58
60
62
63
64
65
"createCallback"
XmCR_CREATE

#define MrmwcUnknown

1

#define MrmRtypeMin
#define MrmRtypeInteger
#define MrmRtypeBoolean
#define MrmRtypeChar8
#define MrmRtypeChar8Vector
#define MrmRtypeCString
#define MrmRtypeCStringVector
#define MrmRtypeFloat
#define MrmRtypeCallback
#define MrmRtypePixmapImage
#define MrmRtypePixmapDDIF
#define MrmRtypeResource
#define MrmRtypeNull
#define MrmRtypeAddrName
#define MrmRtypeIconImage
#define MrmRtypeFont
#define MrmRtypeFontList
#define MrmRtypeColor
#define MrmRtypeColorTable
#define MrmRtypeAny
#define MrmRtypeTransTable
#define MrmRtypeClassRecName
#define MrmRtypeIntegerVector

1
1
2
3
4
5
6
7
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23

6-210

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 301

Figure 6-251: <Mrm/MrmPublic.h>*, Part 3 of 3

#define MrmRtypeXBitmapFile
24
#define MrmRtypeCountedVector
25
#define MrmRtypeKeysym
26
#define MrmRtypeSingleFloat
27
#define MrmRtypeWideCharacter
28
#define MrmRtypeFontSet
29
#define MrmRtypeMax
30
typedef short int
MrmCode ;
typedef unsigned char
MrmSCode ;
typedef unsigned short int
MrmOffset ;
typedef short int
MrmType ;
typedef unsigned short int
MrmSize ;
typedef short int
MrmCount ;
typedef unsigned char
MrmFlag ;
typedef long int
MrmResource_id ;
typedef short int
MrmGroup ;
#define MrmMaxResourceSize
65535
#define MrmOsOpenParamVersion
1
typedef struct {
Cardinal
version;
char
*default_fname;
union {
unsigned long
related_nam;
Boolean
clobber_flg;
} nam_flg;
Display
*display;
} MrmOsOpenParam, *MrmOsOpenParamPtr ;
typedef struct MrmHierarchyDescStruct *MrmHierarchy;
typedef struct {
String
name ;
XtPointer
value ;
} MRMRegisterArg, MrmRegisterArg, *MrmRegisterArglist ;
#define URMwcUnknown

1

System Data Interfaces

6-211

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 302

Figure 6-252: <Xm/MwmUtil.h>*, Part 1 of 3

typedef struct
{
long
flags;
long
functions;
long
decorations;
int
input_mode;
long
status;
} MotifWmHints;
typedef MotifWmHints

MwmHints;

#define MWM_HINTS_FUNCTIONS
#define MWM_HINTS_DECORATIONS
#define MWM_HINTS_INPUT_MODE
#define MWM_HINTS_STATUS

(1L << 0)
(1L << 1)
(1L << 2)
(1L << 3)

#define MWM_FUNC_ALL
#define MWM_FUNC_RESIZE
#define MWM_FUNC_MOVE
#define MWM_FUNC_MINIMIZE
#define MWM_FUNC_MAXIMIZE
#define MWM_FUNC_CLOSE

(1L << 0)
(1L << 1)
(1L << 2)
(1L << 3)
(1L << 4)
(1L << 5)

#define MWM_DECOR_ALL
#define MWM_DECOR_BORDER
#define MWM_DECOR_RESIZEH
#define MWM_DECOR_TITLE
#define MWM_DECOR_MENU
#define MWM_DECOR_MINIMIZE
#define MWM_DECOR_MAXIMIZE

(1L << 0)
(1L << 1)
(1L << 2)
(1L << 3)
(1L << 4)
(1L << 5)
(1L << 6)

#define MWM_INPUT_MODELESS
#define MWM_INPUT_PRIMARY_APPLICATION_MODAL
#define MWM_INPUT_SYSTEM_MODAL
#define MWM_INPUT_FULL_APPLICATION_MODAL

6-212

0
1
2
3

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 303

Figure 6-253: <Xm/MwmUtil.h>*, Part 2 of 3

#define MWM_TEAROFF_WINDOW
(1L << 0)
#define MWM_INPUT_APPLICATION_MODAL
MWM_INPUT_PRIMARY_APPLICATION_MODAL
typedef struct
{
long
Window
} MotifWmInfo;

flags;
wm_window;

typedef MotifWmInfo

MwmInfo;

#define MWM_INFO_STARTUP_STANDARD
#define MWM_INFO_STARTUP_CUSTOM

(1L << 0)
(1L << 1)

typedef struct
{
CARD32
flags;
CARD32
functions;
CARD32
decorations;
INT32
inputMode;
CARD32
status;
} PropMotifWmHints;
typedef PropMotifWmHints

PropMwmHints;

#define PROP_MOTIF_WM_HINTS_ELEMENTS
#define PROP_MWM_HINTS_ELEMENTS

5
PROP_MOTIF_WM_HINTS_ELEMENTS

#define _XA_MOTIF_WM_HINTS
#define _XA_MWM_HINTS

"_MOTIF_WM_HINTS"
_XA_MOTIF_WM_HINTS

#define _XA_MOTIF_WM_MESSAGES
#define _XA_MWM_MESSAGES

"_MOTIF_WM_MESSAGES"
_XA_MOTIF_WM_MESSAGES

#define _XA_MOTIF_WM_OFFSET

"_MOTIF_WM_OFFSET"

System Data Interfaces

6-213

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 304

Figure 6-254: <Xm/MwmUtil.h>*, Part 3 of 3

#define _XA_MOTIF_WM_MENU
#define _XA_MWM_MENU

"_MOTIF_WM_MENU"
_XA_MOTIF_WM_MENU

typedef struct
{
CARD32 flags;
CARD32 wmWindow;
} PropMotifWmInfo;
typedef PropMotifWmInfo PropMwmInfo;
#define PROP_MOTIF_WM_INFO_ELEMENTS
#define PROP_MWM_INFO_ELEMENTS

2
PROP_MOTIF_WM_INFO_ELEMENTS

#define _XA_MOTIF_WM_INFO
#define _XA_MWM_INFO

"_MOTIF_WM_INFO"
_XA_MOTIF_WM_INFO

#define _XA_MOTIF_BINDINGS

"_MOTIF_BINDINGS"

Figure 6-255: <Xm/PanedW.h>*

typedef struct _XmPanedWindowClassRec
typedef struct _XmPanedWindowRec

*XmPanedWindowWidgetClass;
*XmPanedWindowWidget;

6-214

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 305

Figure 6-256: <Xm/PushB.h>*

typedef struct _XmPushButtonClassRec *XmPushButtonWidgetClass;
typedef struct _XmPushButtonRec
*XmPushButtonWidget;

Figure 6-257: <Xm/PushBG.h>*

typedef struct _XmPushButtonGadgetClassRec
typedef struct _XmPushButtonGadgetRec
typedef struct _XmPushButtonGCacheObjRec

*XmPushButtonGadgetClass;
*XmPushButtonGadget;
*XmPushButtonGCacheObject;

Figure 6-258: <Xm/RepType.h>*

#define XmREP_TYPE_INVALID

0x1FFF

typedef unsigned short XmRepTypeId ;
typedef struct
{
String rep_type_name ;
String *value_names ;
unsigned char *values ;
unsigned char num_values ;
Boolean reverse_installed ;
XmRepTypeId rep_type_id ;
}XmRepTypeEntryRec, *XmRepTypeEntry, XmRepTypeListRec, *XmRepTypeList ;

System Data Interfaces

6-215

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 306

Figure 6-259: <Xm/RowColumn.h>*

typedef struct _XmRowColumnClassRec * XmRowColumnWidgetClass;
typedef struct _XmRowColumnRec
* XmRowColumnWidget;

Figure 6-260: <Xm/Scale.h>*

typedef struct _XmScaleClassRec * XmScaleWidgetClass;
typedef struct _XmScaleRec
* XmScaleWidget;

Figure 6-261: <Xm/Screen.h>*

typedef struct _XmScreenRec
*XmScreen;
typedef struct _XmScreenClassRec *XmScreenClass;

Figure 6-262: <Xm/ScrollBar.h>*

typedef struct _XmScrollBarClassRec * XmScrollBarWidgetClass;
typedef struct _XmScrollBarRec
* XmScrollBarWidget;

6-216

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 307

Figure 6-263: <Xm/ScrolledW.h>*

typedef struct _XmScrolledWindowClassRec * XmScrolledWindowWidgetClass;
typedef struct _XmScrolledWindowRec
* XmScrolledWindowWidget;

Figure 6-264: <Xm/SelectioB.h>*

typedef struct _XmSelectionBoxClassRec * XmSelectionBoxWidgetClass;
typedef struct _XmSelectionBoxRec
* XmSelectionBoxWidget;

Figure 6-265: <Xm/SeparatoG.h>*

typedef struct _XmSeparatorGadgetClassRec * XmSeparatorGadgetClass;
typedef struct _XmSeparatorGadgetRec
* XmSeparatorGadget;
typedef struct _XmSeparatorGCacheObjRec
* XmSeparatorGCacheObject;

Figure 6-266: <Xm/Separator.h>*

typedef struct _XmSeparatorClassRec * XmSeparatorWidgetClass;
typedef struct _XmSeparatorRec
* XmSeparatorWidget;

System Data Interfaces

6-217

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 308

Figure 6-267: <Xm/Text.h>*

typedef struct _XmTextSourceRec *XmTextSource;
typedef struct _XmTextClassRec *XmTextWidgetClass;
typedef struct _XmTextRec
*XmTextWidget;

Figure 6-268: <Xm/TextF.h>*

typedef struct _XmTextFieldClassRec *XmTextFieldWidgetClass;
typedef struct _XmTextFieldRec
*XmTextFieldWidget;

Figure 6-269: <Xm/ToggleB.h>*

typedef struct _XmToggleButtonClassRec *XmToggleButtonWidgetClass;
typedef struct _XmToggleButtonRec
*XmToggleButtonWidget;

Figure 6-270: <Xm/ToggleBG.h>*

typedef struct _XmToggleButtonGadgetClassRec
typedef struct _XmToggleButtonGadgetRec
typedef struct _XmToggleButtonGCacheObjRec

6-218

*XmToggleButtonGadgetClass;
*XmToggleButtonGadget;
*XmToggleButtonGCacheObject;

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 309

Figure 6-271: <Xm/VendorS.h>*

typedef struct _XmVendorShellRec
*XmVendorShellWidget;
typedef struct _XmVendorShellClassRec *XmVendorShellWidgetClass;

Figure 6-272: <Xm/VirtKeys.h>*, Part 1 of 2

#define _OSF_Keysyms
#define osfXK_BackSpace
#define osfXK_Insert
#define osfXK_Delete
#define osfXK_Copy
#define osfXK_Cut
#define osfXK_Paste

0x1004FF08
0x1004FF63
0x1004FFFF
0x1004FF02
0x1004FF03
0x1004FF04

#define osfXK_AddMode
#define osfXK_PrimaryPaste
#define osfXK_QuickPaste

0x1004FF31
0x1004FF32
0x1004FF33

#define osfXK_PageLeft
#define osfXK_PageUp
#define osfXK_PageDown
#define osfXK_PageRight

0x1004FF40
0x1004FF41
0x1004FF42
0x1004FF43

System Data Interfaces

6-219

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 310

Figure 6-273: <Xm/VirtKeys.h>*, Part 2 of 2

#define osfXK_EndLine
#define osfXK_BeginLine

0x1004FF57
0x1004FF58

#define osfXK_Activate
#define osfXK_MenuBar

0x1004FF44
0x1004FF45

#define osfXK_Clear
#define osfXK_Cancel
#define osfXK_Help
#define osfXK_Menu
#define osfXK_Select
#define osfXK_Undo

0x1004FF0B
0x1004FF69
0x1004FF6A
0x1004FF67
0x1004FF60
0x1004FF65

#define osfXK_Left
#define osfXK_Up
#define osfXK_Right
#define osfXK_Down

0x1004FF51
0x1004FF52
0x1004FF53
0x1004FF54

6-220

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 311

Figure 6-274: <Xm/Xm.h>*, Part 1 of 14

#define XmUNSPECIFIED_PIXMAP

2

#define XmSTRING_OS_CHARSET
#define XmFALLBACK_CHARSET

XmSTRING_ISO8859_1
XmSTRING_ISO8859_1

#define XmDEFAULT_FONT
#define XmDEFAULT_BACKGROUND
#define XmDEFAULT_DARK_THRESHOLD
#define XmDEFAULT_LIGHT_THRESHOLD
#define XmDEFAULT_FOREGROUND_THRESHOLD

_XmSDEFAULT_FONT
_XmSDEFAULT_BACKGROUND
20
90
70

typedef enum{ XmFONT_IS_FONT, XmFONT_IS_FONTSET } XmFontType;
enum{

XmSTRING_DIRECTION_L_TO_R,
} ;
#define XmSTRING_DIRECTION_DEFAULT

XmSTRING_DIRECTION_R_TO_L
((XmStringDirection) 255)

typedef unsigned char * XmString;
typedef XmString *
XmStringTable;
typedef char *
XmStringCharSet;
typedef unsigned char
XmStringComponentType;
typedef unsigned char
XmStringDirection;
typedef struct _XmFontListRec
*XmFontListEntry;
typedef struct _XmFontListRec
*XmFontList;
typedef struct __XmStringContextRec *_XmStringContext;
typedef struct __XmStringRec
*_XmString;
typedef struct _XmtStringContextRec *XmStringContext;
typedef struct _XmFontListContextRec *XmFontContext;
enum{

XmSTRING_COMPONENT_UNKNOWN,
XmSTRING_COMPONENT_TEXT,
XmSTRING_COMPONENT_SEPARATOR,
} ;

XmSTRING_COMPONENT_CHARSET,
XmSTRING_COMPONENT_DIRECTION,
XmSTRING_COMPONENT_LOCALE_TEXT

System Data Interfaces

6-221

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 312

Figure 6-275: <Xm/Xm.h>*, Part 2 of 14

#define XmSTRING_COMPONENT_END
#define XmSTRING_COMPONENT_USER_BEGIN
#define XmSTRING_COMPONENT_USER_END

((XmStringComponentType) 126)
((XmStringComponentType) 128)
((XmStringComponentType) 255)

typedef struct _XmPrimitiveClassRec * XmPrimitiveWidgetClass;
typedef struct _XmPrimitiveRec
* XmPrimitiveWidget;
typedef struct _XmGadgetClassRec * XmGadgetClass;
typedef struct _XmGadgetRec
* XmGadget;
typedef struct _XmManagerClassRec * XmManagerWidgetClass;
typedef struct _XmManagerRec
* XmManagerWidget;
enum{

XmCHANGE_ALL,
XmCHANGE_WIDTH,
} ;

XmCHANGE_NONE,
XmCHANGE_HEIGHT

enum{

XmPIXELS,
Xm1000TH_INCHES,
Xm100TH_FONT_UNITS
} ;

Xm100TH_MILLIMETERS,
Xm100TH_POINTS,

enum{

XmDESTROY,
XmDO_NOTHING
} ;

XmUNMAP,

enum{

XmEXPLICIT,
} ;

XmPOINTER

enum{

XmNONE,
XmSTICKY_TAB_GROUP,
} ;

XmTAB_GROUP,
XmEXCLUSIVE_TAB_GROUP

#define XmDYNAMIC_DEFAULT_TAB_GROUP

((XmNavigationType) 255)

6-222

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 313

Figure 6-276: <Xm/Xm.h>*, Part 3 of 14

enum{

XmBELL = 1
} ;

enum{

XmNO_ORIENTATION,
XmHORIZONTAL
} ;

XmVERTICAL,

enum{

XmWORK_AREA,
XmMENU_PULLDOWN,
XmMENU_OPTION
} ;

XmMENU_BAR,
XmMENU_POPUP,

enum{

XmNO_PACKING,
XmPACK_COLUMN,
} ;

XmPACK_TIGHT,
XmPACK_NONE

enum{

XmALIGNMENT_CONTENTS_TOP = 3,
XmALIGNMENT_CONTENTS_BOTTOM
} ;

enum{

XmTEAR_OFF_ENABLED,
} ;

XmTEAR_OFF_DISABLED

enum{

XmUNPOST,
} ;

XmUNPOST_AND_REPLAY

enum{

XmLAST_POSITION = -1,
} ;

XmFIRST_POSITION

enum{

XmALIGNMENT_BEGINNING,
XmALIGNMENT_END
} ;

XmALIGNMENT_CENTER,

System Data Interfaces

6-223

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 314

Figure 6-277: <Xm/Xm.h>*, Part 4 of 14

enum{

XmALIGNMENT_BASELINE_TOP,
XmALIGNMENT_BASELINE_BOTTOM = 2, XmALIGNMENT_WIDGET_TOP,
XmALIGNMENT_WIDGET_BOTTOM
} ;

enum{

XmFRAME_GENERIC_CHILD,
XmFRAME_TITLE_CHILD
} ;

XmFRAME_WORKAREA_CHILD,

enum{

XmN_OF_MANY = 1,
} ;

XmONE_OF_MANY

enum{

XmATTACH_NONE,
XmATTACH_OPPOSITE_FORM,
XmATTACH_OPPOSITE_WIDGET,
XmATTACH_SELF
} ;

XmATTACH_FORM,
XmATTACH_WIDGET,
XmATTACH_POSITION,

enum{

XmRESIZE_NONE,
XmRESIZE_ANY
} ;

XmRESIZE_GROW,

6-224

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 315

Figure 6-278: <Xm/Xm.h>*, Part 5 of 15

enum{

XmCR_NONE,
XmCR_VALUE_CHANGED,
XmCR_DECREMENT,
XmCR_PAGE_DECREMENT,
XmCR_TO_BOTTOM,
XmCR_ACTIVATE,
XmCR_DISARM,
XmCR_UNMAP,
XmCR_LOSING_FOCUS,
XmCR_MOVING_INSERT_CURSOR,
XmCR_SINGLE_SELECT,
XmCR_EXTENDED_SELECT,
XmCR_DEFAULT_ACTION,
XmCR_CLIPBOARD_DATA_DELETE,
XmCR_OK,
XmCR_APPLY = 34,
XmCR_COMMAND_ENTERED,
XmCR_EXPOSE,
XmCR_INPUT,
XmCR_LOSE_PRIMARY,
XmCR_TEAR_OFF_ACTIVATE,
XmCR_OBSCURED_TRAVERSAL
} ;

XmCR_HELP,
XmCR_INCREMENT,
XmCR_PAGE_INCREMENT,
XmCR_TO_TOP,
XmCR_DRAG,
XmCR_ARM,
XmCR_MAP = 16,
XmCR_FOCUS,
XmCR_MODIFYING_TEXT_VALUE,
XmCR_EXECUTE,
XmCR_MULTIPLE_SELECT,
XmCR_BROWSE_SELECT,
XmCR_CLIPBOARD_DATA_REQUEST,
XmCR_CASCADING,
XmCR_CANCEL,
XmCR_NO_MATCH,
XmCR_COMMAND_CHANGED,
XmCR_RESIZE,
XmCR_GAIN_PRIMARY,
XmCR_CREATE,
XmCR_TEAR_OFF_DEACTIVATE,

typedef struct
{
int
reason;
XEvent *event;
} XmAnyCallbackStruct;
typedef struct
{
int
reason;
XEvent *event;
int
click_count;
} XmArrowButtonCallbackStruct;

System Data Interfaces

6-225

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 316

Figure 6-279: <Xm/Xm.h>*, Part 6 of 14

typedef struct
{
int
reason;
XEvent *event;
Window window;
} XmDrawingAreaCallbackStruct;
typedef struct
{
int
reason;
XEvent *event;
Window window;
int
click_count;
} XmDrawnButtonCallbackStruct;
typedef struct
{
int
reason;
XEvent *event;
int
click_count;
} XmPushButtonCallbackStruct;
typedef struct
{
int
reason;
XEvent *event;
Widget widget;
char
*data;
char
*callbackstruct;
} XmRowColumnCallbackStruct;

6-226

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 317

Figure 6-280: <Xm/Xm.h>*, Part 7 of 14

typedef struct
{
int reason;
XEvent * event;
int value;
int pixel;
} XmScrollBarCallbackStruct;
typedef struct
{
int reason;
XEvent * event;
int set;
} XmToggleButtonCallbackStruct;
typedef struct
{
int
reason;
XEvent
*event;
XmString item;
int
item_length;
int
item_position;
XmString *selected_items;
int
selected_item_count;
int
*selected_item_positions;
char
selection_type;
} XmListCallbackStruct;
typedef struct
{
int reason;
XEvent
*event;
XmString
value;
int
length;
} XmSelectionBoxCallbackStruct;

System Data Interfaces

6-227

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 318

Figure 6-281: <Xm/Xm.h>*, Part 8 of 14

typedef struct
{
int reason;
XEvent
*event;
XmString
value;
int
length;
} XmCommandCallbackStruct;
typedef struct
{
int
reason;
XEvent
*event;
XmString
value;
int
length;
XmString
mask;
int
mask_length;
XmString
dir ;
int
dir_length ;
XmString
pattern ;
int
pattern_length ;
} XmFileSelectionBoxCallbackStruct;
typedef struct
{
int reason;
XEvent * event;
int value;
} XmScaleCallbackStruct;
enum{

XmMULTICLICK_DISCARD,
} ;

XmMULTICLICK_KEEP

enum{

XmSHADOW_IN = 7,
} ;

XmSHADOW_OUT

6-228

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 319

Figure 6-282: <Xm/Xm.h>*, Part 9 of 14

enum{

XmARROW_UP,
XmARROW_LEFT,
} ;

XmARROW_DOWN,
XmARROW_RIGHT

enum{

XmNO_LINE,
XmDOUBLE_LINE,
XmDOUBLE_DASHED_LINE,
XmSHADOW_ETCHED_OUT,
XmSHADOW_ETCHED_OUT_DASH,
} ;

XmSINGLE_LINE,
XmSINGLE_DASHED_LINE,
XmSHADOW_ETCHED_IN,
XmSHADOW_ETCHED_IN_DASH,
XmINVALID_SEPARATOR_TYPE

enum{

XmPIXMAP = 1,
} ;

XmSTRING

enum{

XmWINDOW,
XmCURSOR = 2
} ;

enum{

XmMAX_ON_TOP,
XmMAX_ON_LEFT,
} ;

XmMAX_ON_BOTTOM,
XmMAX_ON_RIGHT

enum{

XmSINGLE_SELECT,
XmEXTENDED_SELECT,
} ;

XmMULTIPLE_SELECT,
XmBROWSE_SELECT

enum{

XmSTATIC,
} ;

XmDYNAMIC

enum{

XmVARIABLE,
XmRESIZE_IF_POSSIBLE
} ;

XmCONSTANT,

enum{

XmAUTOMATIC,
} ;

XmAPPLICATION_DEFINED

System Data Interfaces

6-229

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 320

Figure 6-283: <Xm/Xm.h>*, Part 10 of 14

enum{ XmAS_NEEDED = 1
} ;
#define SW_TOP
#define SW_BOTTOM
#define SW_LEFT
#define SW_RIGHT

1
0
2
0

#define XmTOP_LEFT
#define XmBOTTOM_LEFT
#define XmTOP_RIGHT
#define XmBOTTOM_RIGHT

(SW_TOP | SW_LEFT)
(SW_BOTTOM | SW_LEFT)
(SW_TOP | SW_RIGHT)
(SW_BOTTOM | SW_RIGHT)

enum{

XmCOMMAND_ABOVE_WORKSPACE,
} ;

XmCOMMAND_BELOW_WORKSPACE

enum{

XmMULTI_LINE_EDIT,
} ;

XmSINGLE_LINE_EDIT

typedef enum{
XmTEXT_FORWARD,
XmTEXT_BACKWARD
} XmTextDirection;
typedef long XmTextPosition;
typedef Atom XmTextFormat;
#define XmFMT_8_BIT
#define XmFMT_16_BIT

((XmTextFormat) XA_STRING)
((XmTextFormat) 2)

#define FMT8BIT
#define FMT16BIT

XmFMT_8_BIT
XmFMT_16_BIT

6-230

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 321

Figure 6-284: <Xm/Xm.h>*, Part 11 of 14

typedef enum{
XmSELECT_POSITION,
XmSELECT_WORD,
XmSELECT_ALL,
} XmTextScanType ;

XmSELECT_WHITESPACE,
XmSELECT_LINE,
XmSELECT_PARAGRAPH

typedef enum{
XmHIGHLIGHT_NORMAL,
XmHIGHLIGHT_SECONDARY_SELECTED
} XmHighlightMode ;

XmHIGHLIGHT_SELECTED,

typedef struct {
char *ptr;
int length;
XmTextFormat format;
} XmTextBlockRec, *XmTextBlock;
typedef struct
{
int reason;
XEvent *event;
Boolean doit;
long currInsert, newInsert;
long startPos, endPos;
XmTextBlock text;
} XmTextVerifyCallbackStruct, *XmTextVerifyPtr;
typedef struct {
wchar_t *wcsptr;
int length;
} XmTextBlockRecWcs, *XmTextBlockWcs;

System Data Interfaces

6-231

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 322

Figure 6-285: <Xm/Xm.h>*, Part 12 of 14

typedef struct
{
int reason;
XEvent *event;
Boolean doit;
long currInsert, newInsert;
long startPos, endPos;
XmTextBlockWcs text;
} XmTextVerifyCallbackStructWcs, *XmTextVerifyPtrWcs;
#define XmTextGetTopPosition
#define XmTextSetTopPosition
#define XmCOPY_FAILED
#define XmCOPY_SUCCEEDED
#define XmCOPY_TRUNCATED
enum{

XmTextGetTopCharacter
XmTextSetTopCharacter
0
1
2

XmDIALOG_NONE,
XmDIALOG_CANCEL_BUTTON,
XmDIALOG_OK_BUTTON,
XmDIALOG_FILTER_TEXT,
XmDIALOG_LIST,
XmDIALOG_MESSAGE_LABEL,
XmDIALOG_SYMBOL_LABEL,
XmDIALOG_SEPARATOR,
XmDIALOG_DIR_LIST_LABEL
} ;

XmDIALOG_APPLY_BUTTON,
XmDIALOG_DEFAULT_BUTTON,
XmDIALOG_FILTER_LABEL,
XmDIALOG_HELP_BUTTON,
XmDIALOG_LIST_LABEL,
XmDIALOG_SELECTION_LABEL,
XmDIALOG_TEXT,
XmDIALOG_DIR_LIST,

#define XmDIALOG_HISTORY_LIST
#define XmDIALOG_PROMPT_LABEL
#define XmDIALOG_VALUE_TEXT
#define XmDIALOG_COMMAND_TEXT
#define XmDIALOG_FILE_LIST
#define XmDIALOG_FILE_LIST_LABEL

XmDIALOG_LIST
XmDIALOG_SELECTION_LABEL
XmDIALOG_TEXT
XmDIALOG_TEXT
XmDIALOG_LIST
XmDIALOG_LIST_LABEL

6-232

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 323

Figure 6-286: <Xm/Xm.h>*, Part 13 of 14

enum{

XmDIALOG_MODELESS,
XmDIALOG_PRIMARY_APPLICATION_MODAL,
XmDIALOG_FULL_APPLICATION_MODAL,XmDIALOG_SYSTEM_MODAL
} ;

#define XmDIALOG_APPLICATION_MODAL

XmDIALOG_PRIMARY_APPLICATION_MODAL

enum{

XmPLACE_ABOVE_SELECTION,

XmPLACE_TOP,
XmPLACE_BELOW_SELECTION
} ;

#define XmFILE_DIRECTORY (1 << 0)
#define XmFILE_REGULAR
(1 << 1)
#define XmFILE_ANY_TYPE (XmFILE_DIRECTORY | XmFILE_REGULAR)
enum{

XmDIALOG_WORK_AREA,
XmDIALOG_SELECTION,
XmDIALOG_FILE_SELECTION
} ;

XmDIALOG_PROMPT,
XmDIALOG_COMMAND,

enum{

XmDIALOG_TEMPLATE,
XmDIALOG_INFORMATION,
XmDIALOG_QUESTION,
XmDIALOG_WORKING
} ;

XmDIALOG_ERROR,
XmDIALOG_MESSAGE,
XmDIALOG_WARNING,

typedef enum{
XmVISIBILITY_UNOBSCURED,
XmVISIBILITY_FULLY_OBSCURED
} XmVisibility ;
typedef enum{
XmTRAVERSE_CURRENT,
XmTRAVERSE_PREV,
XmTRAVERSE_NEXT_TAB_GROUP,
XmTRAVERSE_UP,
XmTRAVERSE_LEFT,
} XmTraversalDirection ;

XmVISIBILITY_PARTIALLY_OBSCURED,

XmTRAVERSE_NEXT,
XmTRAVERSE_HOME,
XmTRAVERSE_PREV_TAB_GROUP,
XmTRAVERSE_DOWN,
XmTRAVERSE_RIGHT

System Data Interfaces

6-233

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 324

Figure 6-287: <Xm/Xm.h>*, Part 14 of 14

typedef struct _XmTraverseObscuredCallbackStruct
{
int
reason ;
XEvent *
event ;
Widget
traversal_destination ;
XmTraversalDirection
direction ;
} XmTraverseObscuredCallbackStruct ;
typedef unsigned char
XmNavigationType;
typedef unsigned char XmButtonType;
typedef XmButtonType * XmButtonTypeTable;
typedef KeySym * XmKeySymTable;
typedef XmStringCharSet * XmStringCharSetTable;
enum{

XmPUSHBUTTON = 1,
XmRADIOBUTTON,
XmSEPARATOR,
XmTITLE
} ;
#define XmCHECKBUTTON

XmTOGGLEBUTTON,
XmCASCADEBUTTON,
XmDOUBLE_SEPARATOR,

XmTOGGLEBUTTON

typedef struct _XmSecondaryResourceDataRec{
XmResourceBaseProc base_proc;
XtPointer
client_data;
String
name;
String
res_class;
XtResourceList
resources;
Cardinal
num_resources;
}XmSecondaryResourceDataRec, *XmSecondaryResourceData;
typedef long XmOffset;
typedef XmOffset *XmOffsetPtr;

6-234

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 325

Figure 6-288: <Xm/XmStrDefs.h>*, Part 1 of 34

#define XmS ""
#define XmCAccelerator "Accelerator"
#define XmCAcceleratorText "AcceleratorText"
#define XmCAdjustLast "AdjustLast"
#define XmCAdjustMargin "AdjustMargin"
#define XmCAlignment "Alignment"
#define XmCAllowOverlap "AllowOverlap"
#define XmCAnimationMask "AnimationMask"
#define XmCAnimationPixmap "AnimationPixmap"
#define XmCAnimationPixmapDepth "AnimationPixmapDepth"
#define XmCAnimationStyle "AnimationStyle"
#define XmCApplyLabelString "ApplyLabelString"
#define XmCArmCallback "ArmCallback"
#define XmCArmColor "ArmColor"
#define XmCArmPixmap "ArmPixmap"
#define XmCArrowDirection "ArrowDirection"
#define XmCAttachment "Attachment"
#define XmCAudibleWarning "AudibleWarning"
#define XmCAutoShowCursorPosition "AutoShowCursorPosition"
#define XmCAutoUnmanage "AutoUnmanage"
#define XmCAutomaticSelection "AutomaticSelection"
#define XmCAvailability "Availability"
#define XmCBackgroundPixmap "BackgroundPixmap"
#define XmCBlendModel "BlendModel"
#define XmCBlinkRate "BlinkRate"
#define XmCBottomShadowColor "BottomShadowColor"
#define XmCBottomShadowPixmap "BottomShadowPixmap"
#define XmCButtonAcceleratorText "ButtonAcceleratorText"
#define XmCButtonAccelerators "ButtonAccelerators"
#define XmCButtonCount "ButtonCount"
#define XmCButtonFontList "ButtonFontList"
#define XmCButtonMnemonicCharSets "ButtonMnemonicCharSets"
#define XmCButtonMnemonics "ButtonMnemonics"
#define XmCButtonSet "ButtonSet"
#define XmCButtonType "ButtonType"

System Data Interfaces

6-235

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 326

Figure 6-289: <Xm/XmStrDefs.h>*, Part 2 of 34

#define XmCButtons "Buttons"
#define XmCCancelLabelString "CancelLabelString"
#define XmCChildHorizontalAlignment "ChildHorizontalAlignment"
#define XmCChildHorizontalSpacing "ChildHorizontalSpacing"
#define XmCChildPlacement "ChildPlacement"
#define XmCChildType "ChildType"
#define XmCChildVerticalAlignment "ChildVerticalAlignment"
#define XmCChildren "Children"
#define XmCClientData "ClientData"
#define XmCClipWindow "ClipWindow"
#define XmCColumns "Columns"
#define XmCCommandWindow "CommandWindow"
#define XmCCommandWindowLocation "CommandWindowLocation"
#define XmCConvertProc "ConvertProc"
#define XmCCursorBackground "CursorBackground"
#define XmCCursorForeground "CursorForeground"
#define XmCCursorPosition "CursorPosition"
#define XmCCursorPositionVisible "CursorPositionVisible"
#define XmCDarkThreshold "DarkThreshold"
#define XmCDecimalPoints "DecimalPoints"
#define XmCDefaultButtonShadowThickness "DefaultButtonShadowThickness"
#define XmCDefaultButtonType "DefaultButtonType"
#define XmCDefaultCopyCursorIcon "DefaultCopyCursorIcon"
#define XmCDefaultFontList "DefaultFontList"
#define XmCDefaultInvalidCursorIcon "DefaultInvalidCursorIcon"
#define XmCDefaultLinkCursorIcon "DefaultLinkCursorIcon"
#define XmCDefaultMoveCursorIcon "DefaultMoveCursorIcon"
#define XmCDefaultNoneCursorIcon "DefaultNoneCursorIcon"
#define XmCDefaultPosition "DefaultPosition"
#define XmCDefaultSourceCursorIcon "DefaultSourceCursorIcon"
#define XmCDefaultValidCursorIcon "DefaultValidCursorIcon"
#define XmCDeleteResponse "DeleteResponse"
#define XmCDesktopParent "DesktopParent"
#define XmCDialogStyle "DialogStyle"
#define XmCDialogTitle "DialogTitle"

6-236

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 327

Figure 6-290: <Xm/XmStrDefs.h>*, Part 3 of 34

#define XmCDialogType "DialogType"
#define XmCDirListItemCount "DirListItemCount"
#define XmCDirListItems "DirListItems"
#define XmCDirListLabelString "DirListLabelString"
#define XmCDirMask "DirMask"
#define XmCDirSearchProc "DirSearchProc"
#define XmCDirSpec "DirSpec"
#define XmCDirectory "Directory"
#define XmCDirectoryValid "DirectoryValid"
#define XmCDisarmCallback "DisarmCallback"
#define XmCDoubleClickInterval "DoubleClickInterval"
#define XmCDragContextClass "DragContextClass"
#define XmCDragDropFinishCallback "DragDropFinishCallback"
#define XmCDragIconClass "DragIconClass"
#define XmCDragInitiatorProtocolStyle "DragInitiatorProtocolStyle"
#define XmCDragMotionCallback "DragMotionCallback"
#define XmCDragOperations "DragOperations"
#define XmCDragOverMode "DragOverMode"
#define XmCDragProc "DragProc"
#define XmCDragReceiverProtocolStyle "DragReceiverProtocolStyle"
#define XmCDropProc "DropProc"
#define XmCDropRectangles "DropRectangles"
#define XmCDropSiteActivity "DropSiteActivity"
#define XmCDropSiteEnterCallback "DropSiteEnterCallback"
#define XmCDropSiteLeaveCallback "DropSiteLeaveCallback"
#define XmCDropSiteManagerClass "DropSiteManagerClass"
#define XmCDropSiteOperations "DropSiteOperations"
#define XmCDropSiteType "DropSiteType"
#define XmCDropStartCallback "DropStartCallback"
#define XmCDropTransferClass "DropTransferClass"
#define XmCDropTransfers "DropTransfers"
#define XmCEditable "Editable"
#define XmCEntryBorder "EntryBorder"
#define XmCEntryClass "EntryClass"
#define XmCExportTargets "ExportTargets"

System Data Interfaces

6-237

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 328

Figure 6-291: <Xm/XmStrDefs.h>*, Part 4 of 34

#define XmCExposeCallback "ExposeCallback"
#define XmCExtensionType "ExtensionType"
#define XmCFileListItemCount "FileListItemCount"
#define XmCFileListItems "FileListItems"
#define XmCFileListLabelString "FileListLabelString"
#define XmCFileSearchProc "FileSearchProc"
#define XmCFileTypeMask "FileTypeMask"
#define XmCFillOnArm "FillOnArm"
#define XmCFillOnSelect "FillOnSelect"
#define XmCFilterLabelString "FilterLabelString"
#define XmCFontList "FontList"
#define XmCForegroundThreshold "ForegroundThreshold"
#define XmCHelpLabelString "HelpLabelString"
#define XmCHighlightColor "HighlightColor"
#define XmCHighlightOnEnter "HighlightOnEnter"
#define XmCHighlightPixmap "HighlightPixmap"
#define XmCHighlightThickness "HighlightThickness"
#define XmCHorizontalFontUnit "HorizontalFontUnit"
#define XmCHorizontalScrollBar "HorizontalScrollBar"
#define XmCHot "Hot"
#define XmCICCHandle "ICCHandle"
#define XmCImportTargets "ImportTargets"
#define XmCIncrement "Increment"
#define XmCIncremental "Incremental"
#define XmCIndicatorOn "IndicatorOn"
#define XmCIndicatorSize "IndicatorSize"
#define XmCIndicatorType "IndicatorType"
#define XmCInitialDelay "InitialDelay"
#define XmCInitialFocus "InitialFocus"
#define XmCInputCreate "InputCreate"
#define XmCInputMethod "InputMethod"
#define XmCInvalidCursorForeground "InvalidCursorForeground"
#define XmCIsAligned "IsAligned"
#define XmCIsHomogeneous "IsHomogeneous"
#define XmCItemCount "ItemCount"

6-238

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 329

Figure 6-292: <Xm/XmStrDefs.h>*, Part 5 of 34

#define XmCItems "Items"
#define XmCKeyboardFocusPolicy "KeyboardFocusPolicy"
#define XmCLabelFontList "LabelFontList"
#define XmCLabelInsensitivePixmap "LabelInsensitivePixmap"
#define XmCLabelPixmap "LabelPixmap"
#define XmCLabelString "LabelString"
#define XmCLabelType "LabelType"
#define XmCLightThreshold "LightThreshold"
#define XmCListLabelString "ListLabelString"
#define XmCListMarginHeight "ListMarginHeight"
#define XmCListMarginWidth "ListMarginWidth"
#define XmCListSizePolicy "ListSizePolicy"
#define XmCListSpacing "ListSpacing"
#define XmCListUpdated "ListUpdated"
#define XmCLogicalParent "LogicalParent"
#define XmCMainWindowMarginHeight "MainWindowMarginHeight"
#define XmCMainWindowMarginWidth "MainWindowMarginWidth"
#define XmCMappingDelay "MappingDelay"
#define XmCMarginBottom "MarginBottom"
#define XmCMarginHeight "MarginHeight"
#define XmCMarginLeft "MarginLeft"
#define XmCMarginRight "MarginRight"
#define XmCMarginTop "MarginTop"
#define XmCMarginWidth "MarginWidth"
#define XmCMask "Mask"
#define XmCMaxItems "MaxItems"
#define XmCMaxLength "MaxLength"
#define XmCMaxValue "MaxValue"
#define XmCMaximum "Maximum"
#define XmCMenuBar "MenuBar"
#define XmCMenuPost "MenuPost"
#define XmCMenuWidget "MenuWidget"
#define XmCMessageProc "MessageProc"
#define XmCMessageWindow "MessageWindow"
#define XmCMinimizeButtons "MinimizeButtons"

System Data Interfaces

6-239

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 330

Figure 6-293: <Xm/XmStrDefs.h>*, Part 6 of 34

#define XmCMinimum "Minimum"
#define XmCMnemonic "Mnemonic"
#define XmCMnemonicCharSet "MnemonicCharSet"
#define XmCMoveOpaque "MoveOpaque"
#define XmCMultiClick "MultiClick"
#define XmCMustMatch "MustMatch"
#define XmCMwmDecorations "MwmDecorations"
#define XmCMwmFunctions "MwmFunctions"
#define XmCMwmInputMode "MwmInputMode"
#define XmCMwmMenu "MwmMenu"
#define XmCMwmMessages "MwmMessages"
#define XmCNavigationType "NavigationType"
#define XmCNeedsMotion "NeedsMotion"
#define XmCNoMatchString "NoMatchString"
#define XmCNoResize "NoResize"
#define XmCNoneCursorForeground "NoneCursorForeground"
#define XmCNotifyProc "NotifyProc"
#define XmCNumChildren "NumChildren"
#define XmCNumColumns "NumColumns"
#define XmCNumDropRectangles "NumDropRectangles"
#define XmCNumDropTransfers "NumDropTransfers"
#define XmCNumExportTargets "NumExportTargets"
#define XmCNumImportTargets "NumImportTargets"
#define XmCOffset "Offset"
#define XmCOkLabelString "OkLabelString"
#define XmCOperationChangedCallback "OperationChangedCallback"
#define XmCOperationCursorIcon "OperationCursorIcon"
#define XmCOptionLabel "OptionLabel"
#define XmCOptionMnemonic "OptionMnemonic"
#define XmCOutputCreate "OutputCreate"
#define XmCPacking "Packing"
#define XmCPageIncrement "PageIncrement"
#define XmCPaneMaximum "PaneMaximum"
#define XmCPaneMinimum "PaneMinimum"
#define XmCPattern "Pattern"

6-240

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 331

Figure 6-294: <Xm/XmStrDefs.h>*, Part 7 of 34

#define XmCPendingDelete "PendingDelete"
#define XmCPopupEnabled "PopupEnabled"
#define XmCPositionIndex "PositionIndex"
#define XmCPostFromButton "PostFromButton"
#define XmCPostFromCount "PostFromCount"
#define XmCPostFromList "PostFromList"
#define XmCPreeditType "PreeditType"
#define XmCProcessingDirection "ProcessingDirection"
#define XmCPromptString "PromptString"
#define XmCProtocolCallback "ProtocolCallback"
#define XmCPushButtonEnabled "PushButtonEnabled"
#define XmCQualifySearchDataProc "QualifySearchDataProc"
#define XmCRadioAlwaysOne "RadioAlwaysOne"
#define XmCRadioBehavior "RadioBehavior"
#define XmCRecomputeSize "RecomputeSize"
#define XmCRectangles "Rectangles"
#define XmCRepeatDelay "RepeatDelay"
#define XmCResizeCallback "ResizeCallback"
#define XmCResizeHeight "ResizeHeight"
#define XmCResizePolicy "ResizePolicy"
#define XmCResizeWidth "ResizeWidth"
#define XmCRowColumnType "RowColumnType"
#define XmCRows "Rows"
#define XmCRubberPositioning "RubberPositioning"
#define XmCSashHeight "SashHeight"
#define XmCSashIndent "SashIndent"
#define XmCSashWidth "SashWidth"
#define XmCScaleHeight "ScaleHeight"
#define XmCScaleMultiple "ScaleMultiple"
#define XmCScaleWidth "ScaleWidth"
#define XmCScroll "Scroll"
#define XmCScrollBarDisplayPolicy "ScrollBarDisplayPolicy"
#define XmCScrollBarPlacement "ScrollBarPlacement"
#define XmCScrollSide "ScrollSide"
#define XmCScrolledWindowMarginHeight "ScrolledWindowMarginHeight"

System Data Interfaces

6-241

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 332

Figure 6-295: <Xm/XmStrDefs.h>*, Part 8 of 34

#define XmCScrolledWindowMarginWidth "ScrolledWindowMarginWidth"
#define XmCScrollingPolicy "ScrollingPolicy"
#define XmCSelectColor "SelectColor"
#define XmCSelectInsensitivePixmap "SelectInsensitivePixmap"
#define XmCSelectPixmap "SelectPixmap"
#define XmCSelectThreshold "SelectThreshold"
#define XmCSelectedItemCount "SelectedItemCount"
#define XmCSelectedItems "SelectedItems"
#define XmCSelectionArrayCount "SelectionArrayCount"
#define XmCSelectionLabelString "SelectionLabelString"
#define XmCSelectionPolicy "SelectionPolicy"
#define XmCSeparatorOn "SeparatorOn"
#define XmCSeparatorType "SeparatorType"
#define XmCSet "Set"
#define XmCShadowThickness "ShadowThickness"
#define XmCShadowType "ShadowType"
#define XmCShellUnitType "ShellUnitType"
#define XmCShowArrows "ShowArrows"
#define XmCShowAsDefault "ShowAsDefault"
#define XmCShowSeparator "ShowSeparator"
#define XmCShowValue "ShowValue"
#define XmCSimpleCheckBox "SimpleCheckBox"
#define XmCSimpleMenuBar "SimpleMenuBar"
#define XmCSimpleOptionMenu "SimpleOptionMenu"
#define XmCSimplePopupMenu "SimplePopupMenu"
#define XmCSimplePulldownMenu "SimplePulldownMenu"
#define XmCSimpleRadioBox "SimpleRadioBox"
#define XmCSizePolicy "SizePolicy"
#define XmCSliderSize "SliderSize"
#define XmCSource "Source"
#define XmCSourceCursorIcon "SourceCursorIcon"
#define XmCSourceIsExternal "SourceIsExternal"
#define XmCSourcePixmapIcon "SourcePixmapIcon"
#define XmCSourceWidget "SourceWidget"
#define XmCSourceWindow "SourceWindow"

6-242

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 333

Figure 6-296: <Xm/XmStrDefs.h>*, Part 9 of 34

#define XmCSpacing "Spacing"
#define XmCStartTime "StartTime"
#define XmCStateCursorIcon "StateCursorIcon"
#define XmCStringDirection "StringDirection"
#define XmCTearOffModel "TearOffModel"
#define XmCTextFontList "TextFontList"
#define XmCTextString "TextString"
#define XmCTextValue "TextValue"
#define XmCTitleString "TitleString"
#define XmCTopCharacter "TopCharacter"
#define XmCTopItemPosition "TopItemPosition"
#define XmCTopLevelEnterCallback "TopLevelEnterCallback"
#define XmCTopLevelLeaveCallback "TopLevelLeaveCallback"
#define XmCTopShadowColor "TopShadowColor"
#define XmCTopShadowPixmap "TopShadowPixmap"
#define XmCTransferProc "TransferProc"
#define XmCTransferStatus "TransferStatus"
#define XmCTraversalOn "TraversalOn"
#define XmCTraversalType "TraversalType"
#define XmCTreeUpdateProc "TreeUpdateProc"
#define XmCTroughColor "TroughColor"
#define XmCUnitType "UnitType"
#define XmCUnpostBehavior "UnpostBehavior"
#define XmCUnselectPixmap "UnselectPixmap"
#define XmCUpdateSliderSize "UpdateSliderSize"
#define XmCUseAsyncGeometry "UseAsyncGeometry"
#define XmCUserData "UserData"
#define XmCValidCursorForeground "ValidCursorForeground"
#define XmCValueChangedCallback "ValueChangedCallback"
#define XmCValueWcs "ValueWcs"
#define XmCVerifyBell "VerifyBell"
#define XmCVerticalAlignment "VerticalAlignment"
#define XmCVerticalFontUnit "VerticalFontUnit"
#define XmCVerticalScrollBar "VerticalScrollBar"

System Data Interfaces

6-243

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 334

Figure 6-297: <Xm/XmStrDefs.h>*, Part 10 of 34

#define XmCVisibleItemCount "VisibleItemCount"
#define XmCVisibleWhenOff "VisibleWhenOff"
#define XmCVisualPolicy "VisualPolicy"
#define XmCWhichButton "WhichButton"
#define XmCWordWrap "WordWrap"
#define XmCWorkWindow "WorkWindow"
#define XmCXmString "XmString"
#define XmNaccelerator "accelerator"
#define XmNacceleratorText "acceleratorText"
#define XmNactivateCallback "activateCallback"
#define XmNadjustLast "adjustLast"
#define XmNadjustMargin "adjustMargin"
#define XmNalignment "alignment"
#define XmNallowOverlap "allowOverlap"
#define XmNallowResize "allowResize"
#define XmNanimationMask "animationMask"
#define XmNanimationPixmap "animationPixmap"
#define XmNanimationPixmapDepth "animationPixmapDepth"
#define XmNanimationStyle "animationStyle"
#define XmNapplyCallback "applyCallback"
#define XmNapplyLabelString "applyLabelString"
#define XmNarmCallback "armCallback"
#define XmNarmColor "armColor"
#define XmNarmPixmap "armPixmap"
#define XmNarrowDirection "arrowDirection"
#define XmNattachment "attachment"
#define XmNaudibleWarning "audibleWarning"
#define XmNautoShowCursorPosition "autoShowCursorPosition"
#define XmNautoUnmanage "autoUnmanage"
#define XmNautomaticSelection "automaticSelection"
#define XmNavailability "availability"
#define XmNblendModel "blendModel"
#define XmNblinkRate "blinkRate"
#define XmNbottomAttachment "bottomAttachment"
#define XmNbottomOffset "bottomOffset"

6-244

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 335

Figure 6-298: <Xm/XmStrDefs.h>*, Part 11 of 34

#define XmNbottomPosition "bottomPosition"
#define XmNbottomShadowColor "bottomShadowColor"
#define XmNbottomShadowPixmap "bottomShadowPixmap"
#define XmNbottomWidget "bottomWidget"
#define XmNbrowseSelectionCallback "browseSelectionCallback"
#define XmNbuttonAcceleratorText "buttonAcceleratorText"
#define XmNbuttonAccelerators "buttonAccelerators"
#define XmNbuttonCount "buttonCount"
#define XmNbuttonFontList "buttonFontList"
#define XmNbuttonMnemonicCharSets "buttonMnemonicCharSets"
#define XmNbuttonMnemonics "buttonMnemonics"
#define XmNbuttonSet "buttonSet"
#define XmNbuttonType "buttonType"
#define XmNbuttons "buttons"
#define XmNcancelButton "cancelButton"
#define XmNcancelCallback "cancelCallback"
#define XmNcancelLabelString "cancelLabelString"
#define XmNcascadePixmap "cascadePixmap"
#define XmNcascadingCallback "cascadingCallback"
#define XmNchildHorizontalAlignment "childHorizontalAlignment"
#define XmNchildHorizontalSpacing "childHorizontalSpacing"
#define XmNchildPlacement "childPlacement"
#define XmNchildPosition "childPosition"
#define XmNchildType "childType"
#define XmNchildVerticalAlignment "childVerticalAlignment"
#define XmNclientData "clientData"
#define XmNclipWindow "clipWindow"
#define XmNcolumns "columns"
#define XmNcommand "command"
#define XmNcommandChangedCallback "commandChangedCallback"
#define XmNcommandEnteredCallback "commandEnteredCallback"
#define XmNcommandWindow "commandWindow"
#define XmNcommandWindowLocation "commandWindowLocation"
#define XmNconvertProc "convertProc"
#define XmNcursorBackground "cursorBackground"

System Data Interfaces

6-245

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 336

Figure 6-299: <Xm/XmStrDefs.h>*, Part 12 of 34

#define XmNcursorForeground "cursorForeground"
#define XmNcursorPosition "cursorPosition"
#define XmNcursorPositionVisible "cursorPositionVisible"
#define XmNdarkThreshold "darkThreshold"
#define XmNdecimalPoints "decimalPoints"
#define XmNdecrementCallback "decrementCallback"
#define XmNdefaultActionCallback "defaultActionCallback"
#define XmNdefaultButton "defaultButton"
#define XmNdefaultButtonShadowThickness "defaultButtonShadowThickness"
#define XmNdefaultButtonType "defaultButtonType"
#define XmNdefaultCopyCursorIcon "defaultCopyCursorIcon"
#define XmNdefaultFontList "defaultFontList"
#define XmNdefaultInvalidCursorIcon "defaultInvalidCursorIcon"
#define XmNdefaultLinkCursorIcon "defaultLinkCursorIcon"
#define XmNdefaultMoveCursorIcon "defaultMoveCursorIcon"
#define XmNdefaultNoneCursorIcon "defaultNoneCursorIcon"
#define XmNdefaultPosition "defaultPosition"
#define XmNdefaultSourceCursorIcon "defaultSourceCursorIcon"
#define XmNdefaultValidCursorIcon "defaultValidCursorIcon"
#define XmNdeleteResponse "deleteResponse"
#define XmNdesktopParent "desktopParent"
#define XmNdialogStyle "dialogStyle"
#define XmNdialogTitle "dialogTitle"
#define XmNdialogType "dialogType"
#define XmNdirListItemCount "dirListItemCount"
#define XmNdirListItems "dirListItems"
#define XmNdirListLabelString "dirListLabelString"
#define XmNdirMask "dirMask"
#define XmNdirSearchProc "dirSearchProc"
#define XmNdirSpec "dirSpec"
#define XmNdirectory "directory"
#define XmNdirectoryValid "directoryValid"
#define XmNdisarmCallback "disarmCallback"
#define XmNdoubleClickInterval "doubleClickInterval"
#define XmNdragCallback "dragCallback"

6-246

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 337

Figure 6-300: <Xm/XmStrDefs.h>*, Part 13 of 34

#define XmNdragContextClass "dragContextClass"
#define XmNdragDropFinishCallback "dragDropFinishCallback"
#define XmNdragIconClass "dragIconClass"
#define XmNdragInitiatorProtocolStyle "dragInitiatorProtocolStyle"
#define XmNdragMotionCallback "dragMotionCallback"
#define XmNdragOperations "dragOperations"
#define XmNdragOverMode "dragOverMode"
#define XmNdragProc "dragProc"
#define XmNdragReceiverProtocolStyle "dragReceiverProtocolStyle"
#define XmNdropFinishCallback "dropFinishCallback"
#define XmNdropProc "dropProc"
#define XmNdropRectangles "dropRectangles"
#define XmNdropSiteActivity "dropSiteActivity"
#define XmNdropSiteEnterCallback "dropSiteEnterCallback"
#define XmNdropSiteLeaveCallback "dropSiteLeaveCallback"
#define XmNdropSiteManagerClass "dropSiteManagerClass"
#define XmNdropSiteOperations "dropSiteOperations"
#define XmNdropSiteType "dropSiteType"
#define XmNdropStartCallback "dropStartCallback"
#define XmNdropTransferClass "dropTransferClass"
#define XmNdropTransfers "dropTransfers"
#define XmNeditMode "editMode"
#define XmNeditable "editable"
#define XmNentryAlignment "entryAlignment"
#define XmNentryBorder "entryBorder"
#define XmNentryCallback "entryCallback"
#define XmNentryClass "entryClass"
#define XmNentryVerticalAlignment "entryVerticalAlignment"
#define XmNexportTargets "exportTargets"
#define XmNexposeCallback "exposeCallback"
#define XmNextendedSelectionCallback "extendedSelectionCallback"
#define XmNextensionType "extensionType"
#define XmNfileListItemCount "fileListItemCount"
#define XmNfileListItems "fileListItems"
#define XmNfileListLabelString "fileListLabelString"

System Data Interfaces

6-247

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 338

Figure 6-301: <Xm/XmStrDefs.h>*, Part 14 of 34

#define XmNfileSearchProc "fileSearchProc"
#define XmNfileTypeMask "fileTypeMask"
#define XmNfillOnArm "fillOnArm"
#define XmNfillOnSelect "fillOnSelect"
#define XmNfilterLabelString "filterLabelString"
#define XmNfocusCallback "focusCallback"
#define XmNfocusMovedCallback "focusMovedCallback"
#define XmNfocusPolicyChanged "focusPolicyChanged"
#define XmNfontList "fontList"
#define XmNforegroundThreshold "foregroundThreshold"
#define XmNfractionBase "fractionBase"
#define XmNgainPrimaryCallback "gainPrimaryCallback"
#define XmNhelpCallback "helpCallback"
#define XmNhelpLabelString "helpLabelString"
#define XmNhighlightColor "highlightColor"
#define XmNhighlightOnEnter "highlightOnEnter"
#define XmNhighlightPixmap "highlightPixmap"
#define XmNhighlightThickness "highlightThickness"
#define XmNhistoryItemCount "historyItemCount"
#define XmNhistoryItems "historyItems"
#define XmNhistoryMaxItems "historyMaxItems"
#define XmNhistoryVisibleItemCount "historyVisibleItemCount"
#define XmNhorizontalFontUnit "horizontalFontUnit"
#define XmNhorizontalScrollBar "horizontalScrollBar"
#define XmNhorizontalSpacing "horizontalSpacing"
#define XmNhotX "hotX"
#define XmNhotY "hotY"
#define XmNiccHandle "iccHandle"
#define XmNimportTargets "importTargets"
#define XmNincrement "increment"
#define XmNincrementCallback "incrementCallback"
#define XmNincremental "incremental"
#define XmNindicatorOn "indicatorOn"
#define XmNindicatorSize "indicatorSize"
#define XmNindicatorType "indicatorType"

6-248

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 339

Figure 6-302: <Xm/XmStrDefs.h>*, Part 15 of 34

#define XmNinitialDelay "initialDelay"
#define XmNinitialFocus "initialFocus"
#define XmNinputCallback "inputCallback"
#define XmNinputCreate "inputCreate"
#define XmNinputMethod "inputMethod"
#define XmNinvalidCursorForeground "invalidCursorForeground"
#define XmNisAligned "isAligned"
#define XmNisHomogeneous "isHomogeneous"
#define XmNitemCount "itemCount"
#define XmNitems "items"
#define XmNkeyboardFocusPolicy "keyboardFocusPolicy"
#define XmNlabelFontList "labelFontList"
#define XmNlabelInsensitivePixmap "labelInsensitivePixmap"
#define XmNlabelPixmap "labelPixmap"
#define XmNlabelString "labelString"
#define XmNlabelType "labelType"
#define XmNleftAttachment "leftAttachment"
#define XmNleftOffset "leftOffset"
#define XmNleftPosition "leftPosition"
#define XmNleftWidget "leftWidget"
#define XmNlightThreshold "lightThreshold"
#define XmNlineSpace "lineSpace"
#define XmNlistItemCount "listItemCount"
#define XmNlistItems "listItems"
#define XmNlistLabelString "listLabelString"
#define XmNlistMarginHeight "listMarginHeight"
#define XmNlistMarginWidth "listMarginWidth"
#define XmNlistSizePolicy "listSizePolicy"
#define XmNlistSpacing "listSpacing"
#define XmNlistUpdated "listUpdated"
#define XmNlistVisibleItemCount "listVisibleItemCount"
#define XmNlogicalParent "logicalParent"
#define XmNlosePrimaryCallback "losePrimaryCallback"
#define XmNlosingFocusCallback "losingFocusCallback"
#define XmNmainWindowMarginHeight "mainWindowMarginHeight"

System Data Interfaces

6-249

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 340

Figure 6-303: <Xm/XmStrDefs.h>*, Part 16 of 34

#define XmNmainWindowMarginWidth "mainWindowMarginWidth"
#define XmNmapCallback "mapCallback"
#define XmNmappingDelay "mappingDelay"
#define XmNmargin "margin"
#define XmNmarginBottom "marginBottom"
#define XmNmarginHeight "marginHeight"
#define XmNmarginLeft "marginLeft"
#define XmNmarginRight "marginRight"
#define XmNmarginTop "marginTop"
#define XmNmarginWidth "marginWidth"
#define XmNmask "mask"
#define XmNmaxLength "maxLength"
#define XmNmaximum "maximum"
#define XmNmenuAccelerator "menuAccelerator"
#define XmNmenuBar "menuBar"
#define XmNmenuCursor "menuCursor"
#define XmNmenuHelpWidget "menuHelpWidget"
#define XmNmenuHistory "menuHistory"
#define XmNmenuPost "menuPost"
#define XmNmessageAlignment "messageAlignment"
#define XmNmessageProc "messageProc"
#define XmNmessageString "messageString"
#define XmNmessageWindow "messageWindow"
#define XmNminimizeButtons "minimizeButtons"
#define XmNminimum "minimum"
#define XmNmnemonic "mnemonic"
#define XmNmnemonicCharSet "mnemonicCharSet"
#define XmNmodifyVerifyCallback "modifyVerifyCallback"
#define XmNmodifyVerifyCallbackWcs "modifyVerifyCallbackWcs"
#define XmNmotionVerifyCallback "motionVerifyCallback"
#define XmNmoveOpaque "moveOpaque"
#define XmNmultiClick "multiClick"
#define XmNmultipleSelectionCallback "multipleSelectionCallback"
#define XmNmustMatch "mustMatch"
#define XmNmwmDecorations "mwmDecorations"

6-250

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 341

Figure 6-304: <Xm/XmStrDefs.h>*, Part 17 of 34

#define XmNmwmFunctions "mwmFunctions"
#define XmNmwmInputMode "mwmInputMode"
#define XmNmwmMenu "mwmMenu"
#define XmNmwmMessages "mwmMessages"
#define XmNnavigationType "navigationType"
#define XmNneedsMotion "needsMotion"
#define XmNnoMatchCallback "noMatchCallback"
#define XmNnoMatchString "noMatchString"
#define XmNnoResize "noResize"
#define XmNnoneCursorForeground "noneCursorForeground"
#define XmNnotifyProc "notifyProc"
#define XmNnumColumns "numColumns"
#define XmNnumDropRectangles "numDropRectangles"
#define XmNnumDropTransfers "numDropTransfers"
#define XmNnumExportTargets "numExportTargets"
#define XmNnumImportTargets "numImportTargets"
#define XmNnumRectangles "numRectangles"
#define XmNoffsetX "offsetX"
#define XmNoffsetY "offsetY"
#define XmNokCallback "okCallback"
#define XmNokLabelString "okLabelString"
#define XmNoperationChangedCallback "operationChangedCallback"
#define XmNoperationCursorIcon "operationCursorIcon"
#define XmNoptionLabel "optionLabel"
#define XmNoptionMnemonic "optionMnemonic"
#define XmNoutputCreate "outputCreate"
#define XmNpacking "packing"
#define XmNpageDecrementCallback "pageDecrementCallback"
#define XmNpageIncrement "pageIncrement"
#define XmNpageIncrementCallback "pageIncrementCallback"
#define XmNpaneMaximum "paneMaximum"
#define XmNpaneMinimum "paneMinimum"
#define XmNpattern "pattern"
#define XmNpendingDelete "pendingDelete"
#define XmNpopupEnabled "popupEnabled"

System Data Interfaces

6-251

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 342

Figure 6-305: <Xm/XmStrDefs.h>*, Part 18 of 34

#define XmNpositionIndex "positionIndex"
#define XmNpostFromButton "postFromButton"
#define XmNpostFromCount "postFromCount"
#define XmNpostFromList "postFromList"
#define XmNpreeditType "preeditType"
#define XmNprocessingDirection "processingDirection"
#define XmNpromptString "promptString"
#define XmNprotocolCallback "protocolCallback"
#define XmNpushButtonEnabled "pushButtonEnabled"
#define XmNqualifySearchDataProc "qualifySearchDataProc"
#define XmNradioAlwaysOne "radioAlwaysOne"
#define XmNradioBehavior "radioBehavior"
#define XmNrealizeCallback "realizeCallback"
#define XmNrecomputeSize "recomputeSize"
#define XmNrectangles "rectangles"
#define XmNrefigureMode "refigureMode"
#define XmNrepeatDelay "repeatDelay"
#define XmNresizable "resizable"
#define XmNresizeCallback "resizeCallback"
#define XmNresizeHeight "resizeHeight"
#define XmNresizePolicy "resizePolicy"
#define XmNresizeWidth "resizeWidth"
#define XmNrightAttachment "rightAttachment"
#define XmNrightOffset "rightOffset"
#define XmNrightPosition "rightPosition"
#define XmNrightWidget "rightWidget"
#define XmNrowColumnType "rowColumnType"
#define XmNrows "rows"
#define XmNrubberPositioning "rubberPositioning"
#define XmNsashHeight "sashHeight"
#define XmNsashIndent "sashIndent"
#define XmNsashShadowThickness "sashShadowThickness"
#define XmNsashWidth "sashWidth"
#define XmNscaleHeight "scaleHeight"
#define XmNscaleMultiple "scaleMultiple"

6-252

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 343

Figure 6-306: <Xm/XmStrDefs.h>*, Part 19 of 34

#define XmNscaleWidth "scaleWidth"
#define XmNscrollBarDisplayPolicy "scrollBarDisplayPolicy"
#define XmNscrollBarPlacement "scrollBarPlacement"
#define XmNscrollHorizontal "scrollHorizontal"
#define XmNscrollLeftSide "scrollLeftSide"
#define XmNscrollTopSide "scrollTopSide"
#define XmNscrollVertical "scrollVertical"
#define XmNscrolledWindowMarginHeight "scrolledWindowMarginHeight"
#define XmNscrolledWindowMarginWidth "scrolledWindowMarginWidth"
#define XmNscrollingPolicy "scrollingPolicy"
#define XmNselectColor "selectColor"
#define XmNselectInsensitivePixmap "selectInsensitivePixmap"
#define XmNselectPixmap "selectPixmap"
#define XmNselectThreshold "selectThreshold"
#define XmNselectedItemCount "selectedItemCount"
#define XmNselectedItems "selectedItems"
#define XmNselectionArrayCount "selectionArrayCount"
#define XmNselectionLabelString "selectionLabelString"
#define XmNselectionPolicy "selectionPolicy"
#define XmNseparatorOn "separatorOn"
#define XmNseparatorType "separatorType"
#define XmNset "set"
#define XmNshadow "shadow"
#define XmNshadowThickness "shadowThickness"
#define XmNshadowType "shadowType"
#define XmNshellUnitType "shellUnitType"
#define XmNshowArrows "showArrows"
#define XmNshowAsDefault "showAsDefault"
#define XmNshowSeparator "showSeparator"
#define XmNshowValue "showValue"
#define XmNsimpleCallback "simpleCallback"
#define XmNsingleSelectionCallback "singleSelectionCallback"
#define XmNsizePolicy "sizePolicy"
#define XmNskipAdjust "skipAdjust"
#define XmNsliderSize "sliderSize"

System Data Interfaces

6-253

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 344

Figure 6-307: <Xm/XmStrDefs.h>*, Part 20 of 34

#define XmNsource "source"
#define XmNsourceCursorIcon "sourceCursorIcon"
#define XmNsourceIsExternal "sourceIsExternal"
#define XmNsourcePixmapIcon "sourcePixmapIcon"
#define XmNsourceWidget "sourceWidget"
#define XmNsourceWindow "sourceWindow"
#define XmNspacing "spacing"
#define XmNspotLocation "spotLocation"
#define XmNstartTime "startTime"
#define XmNstateCursorIcon "stateCursorIcon"
#define XmNstringDirection "stringDirection"
#define XmNsubMenuId "subMenuId"
#define XmNsymbolPixmap "symbolPixmap"
#define XmNtearOffMenuActivateCallback "tearOffMenuActivateCallback"
#define XmNtearOffMenuDeactivateCallback "tearOffMenuDeactivateCallback"
#define XmNtearOffModel "tearOffModel"
#define XmNtextAccelerators "textAccelerators"
#define XmNtextColumns "textColumns"
#define XmNtextFontList "textFontList"
#define XmNtextString "textString"
#define XmNtextTranslations "textTranslations"
#define XmNtextValue "textValue"
#define XmNtitleString "titleString"
#define XmNtoBottomCallback "toBottomCallback"
#define XmNtoPositionCallback "toPositionCallback"
#define XmNtoTopCallback "toTopCallback"
#define XmNtopAttachment "topAttachment"
#define XmNtopCharacter "topCharacter"
#define XmNtopItemPosition "topItemPosition"
#define XmNtopLevelEnterCallback "topLevelEnterCallback"
#define XmNtopLevelLeaveCallback "topLevelLeaveCallback"
#define XmNtopOffset "topOffset"
#define XmNtopPosition "topPosition"
#define XmNtopShadowColor "topShadowColor"
#define XmNtopShadowPixmap "topShadowPixmap"

6-254

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 345

Figure 6-308: <Xm/XmStrDefs.h>*, Part 21 of 34

#define XmNtopWidget "topWidget"
#define XmNtransferProc "transferProc"
#define XmNtransferStatus "transferStatus"
#define XmNtraversalCallback "traversalCallback"
#define XmNtraversalOn "traversalOn"
#define XmNtraversalType "traversalType"
#define XmNtraverseObscuredCallback "traverseObscuredCallback"
#define XmNtreeUpdateProc "treeUpdateProc"
#define XmNtroughColor "troughColor"
#define XmNunitType "unitType"
#define XmNunmapCallback "unmapCallback"
#define XmNunpostBehavior "unpostBehavior"
#define XmNunselectPixmap "unselectPixmap"
#define XmNupdateSliderSize "updateSliderSize"
#define XmNuseAsyncGeometry "useAsyncGeometry"
#define XmNuserData "userData"
#define XmNvalidCursorForeground "validCursorForeground"
#define XmNvalueChangedCallback "valueChangedCallback"
#define XmNvalueWcs "valueWcs"
#define XmNverifyBell "verifyBell"
#define XmNverticalFontUnit "verticalFontUnit"
#define XmNverticalScrollBar "verticalScrollBar"
#define XmNverticalSpacing "verticalSpacing"
#define XmNvisibleItemCount "visibleItemCount"
#define XmNvisibleWhenOff "visibleWhenOff"
#define XmNvisualPolicy "visualPolicy"
#define XmNwhichButton "whichButton"
#define XmNwordWrap "wordWrap"
#define XmNworkWindow "workWindow"
#define XmRAlignment "Alignment"
#define XmRAnimationMask "AnimationMask"
#define XmRAnimationPixmap "AnimationPixmap"
#define XmRAnimationStyle "AnimationStyle"
#define XmRArrowDirection "ArrowDirection"
#define XmRAtomList "AtomList"

System Data Interfaces

6-255

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 346

Figure 6-309: <Xm/XmStrDefs.h>*, Part 22 of 34

#define XmRAttachment "Attachment"
#define XmRAudibleWarning "AudibleWarning"
#define XmRAvailability "Availability"
#define XmRBackgroundPixmap "BackgroundPixmap"
#define XmRBlendModel "BlendModel"
#define XmRBooleanDimension "BooleanDimension"
#define XmRBottomShadowPixmap "BottomShadowPixmap"
#define XmRButtonType "ButtonType"
#define XmRCallbackProc "CallbackProc"
#define XmRChar "Char"
#define XmRCharSetTable "CharSetTable"
#define XmRChildHorizontalAlignment "ChildHorizontalAlignment"
#define XmRChildPlacement "ChildPlacement"
#define XmRChildType "ChildType"
#define XmRChildVerticalAlignment "ChildVerticalAlignment"
#define XmRCommandWindowLocation "CommandWindowLocation"
#define XmRCompoundText "CompoundText"
#define XmRDefaultButtonType "DefaultButtonType"
#define XmRDeleteResponse "DeleteResponse"
#define XmRDialogStyle "DialogStyle"
#define XmRDialogType "DialogType"
#define XmRDoubleClickInterval "DoubleClickInterval"
#define XmRDragInitiatorProtocolStyle "DragInitiatorProtocolStyle"
#define XmRDragReceiverProtocolStyle "DragReceiverProtocolStyle"
#define XmRDropSiteActivity "DropSiteActivity"
#define XmRDropSiteOperations "DropSiteOperations"
#define XmRDropSiteType "DropSiteType"
#define XmRDropTransfers "DropTransfers"
#define XmRExtensionType "ExtensionType"
#define XmRFileTypeMask "FileTypeMask"
#define XmRFontList "FontList"
#define XmRGadgetPixmap "GadgetPixmap"
#define XmRHighlightPixmap "HighlightPixmap"
#define XmRHorizontalDimension "HorizontalDimension"
#define XmRHorizontalInt "HorizontalInt"

6-256

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 347

Figure 6-310: <Xm/XmStrDefs.h>*, Part 23 of 34

#define XmRHorizontalPosition "HorizontalPosition"
#define XmRIconAttachment "IconAttachment"
#define XmRImportTargets "ImportTargets"
#define XmRIndicatorType "IndicatorType"
#define XmRItemCount "ItemCount"
#define XmRItems "Items"
#define XmRKeySym "KeySym"
#define XmRKeySymTable "KeySymTable"
#define XmRKeyboardFocusPolicy "KeyboardFocusPolicy"
#define XmRLabelType "LabelType"
#define XmRListMarginHeight "ListMarginHeight"
#define XmRListMarginWidth "ListMarginWidth"
#define XmRListSizePolicy "ListSizePolicy"
#define XmRListSpacing "ListSpacing"
#define XmRManBottomShadowPixmap "ManBottomShadowPixmap"
#define XmRManForegroundPixmap "ManForegroundPixmap"
#define XmRManHighlightPixmap "ManHighlightPixmap"
#define XmRManTopShadowPixmap "ManTopShadowPixmap"
#define XmRMenuWidget "MenuWidget"
#define XmRMnemonic "Mnemonic"
#define XmRMultiClick "MultiClick"
#define XmRNavigationType "NavigationType"
#define XmRPacking "Packing"
#define XmRPrimForegroundPixmap "PrimForegroundPixmap"
#define XmRProc "Proc"
#define XmRProcessingDirection "ProcessingDirection"
#define XmRRectangleList "RectangleList"
#define XmRResizePolicy "ResizePolicy"
#define XmRRowColumnType "RowColumnType"
#define XmRScrollBarDisplayPolicy "ScrollBarDisplayPolicy"
#define XmRScrollBarPlacement "ScrollBarPlacement"
#define XmRScrollingPolicy "ScrollingPolicy"
#define XmRSelectedItemCount "SelectedItemCount"
#define XmRSelectedItems "SelectedItems"
#define XmRSelectionPolicy "SelectionPolicy"

System Data Interfaces

6-257

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 348

Figure 6-311: <Xm/XmStrDefs.h>*, Part 24 of 34

#define XmRSelectionType "SelectionType"
#define XmRSeparatorType "SeparatorType"
#define XmRShadowType "ShadowType"
#define XmRShellHorizDim "ShellHorizDim"
#define XmRShellHorizPos "ShellHorizPos"
#define XmRShellUnitType "ShellUnitType"
#define XmRShellVertDim "ShellVertDim"
#define XmRShellVertPos "ShellVertPos"
#define XmRSizePolicy "SizePolicy"
#define XmRStringDirection "StringDirection"
#define XmRTearOffModel "TearOffModel"
#define XmRTopShadowPixmap "TopShadowPixmap"
#define XmRTransferStatus "TransferStatus"
#define XmRTraversalType "TraversalType"
#define XmRUnitType "UnitType"
#define XmRUnpostBehavior "UnpostBehavior"
#define XmRValueWcs "ValueWcs"
#define XmRVerticalAlignment "VerticalAlignment"
#define XmRVerticalDimension "VerticalDimension"
#define XmRVerticalInt "VerticalInt"
#define XmRVerticalPosition "VerticalPosition"
#define XmRVirtualBinding "VirtualBinding"
#define XmRVisibleItemCount "VisibleItemCount"
#define XmRVisualPolicy "VisualPolicy"
#define XmRWhichButton "WhichButton"
#define XmRXmBackgroundPixmap "XmBackgroundPixmap"
#define XmRXmString "XmString"
#define XmRXmStringCharSet "XmStringCharSet"
#define XmRXmStringTable "XmStringTable"
#define XmVosfActivate "osfActivate"
#define XmVosfAddMode "osfAddMode"
#define XmVosfBackSpace "osfBackSpace"
#define XmVosfBeginLine "osfBeginLine"
#define XmVosfCancel "osfCancel"
#define XmVosfClear "osfClear"

6-258

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 349

Figure 6-312: <Xm/XmStrDefs.h>*, Part 25 of 34

#define XmVosfCopy "osfCopy"
#define XmVosfCut "osfCut"
#define XmVosfDelete "osfDelete"
#define XmVosfDown "osfDown"
#define XmVosfEndLine "osfEndLine"
#define XmVosfHelp "osfHelp"
#define XmVosfInsert "osfInsert"
#define XmVosfLeft "osfLeft"
#define XmVosfMenu "osfMenu"
#define XmVosfMenuBar "osfMenuBar"
#define XmVosfPageDown "osfPageDown"
#define XmVosfPageLeft "osfPageLeft"
#define XmVosfPageRight "osfPageRight"
#define XmVosfPageUp "osfPageUp"
#define XmVosfPaste "osfPaste"
#define XmVosfPrimaryPaste "osfPrimaryPaste"
#define XmVosfQuickPaste "osfQuickPaste"
#define XmVosfRight "osfRight"
#define XmVosfSelect "osfSelect"
#define XmVosfUndo "osfUndo"
#define XmVosfUp "osfUp"
#define XmSFONTLIST_DEFAULT_TAG_STRING "FONTLIST_DEFAULT_TAG_STRING"
#define XmSXmFONTLIST_DEFAULT_TAG_STRING "XmFONTLIST_DEFAULT_TAG_STRING"
#define _XmConst /**/
#define XmSTRING_DEFAULT_CHARSET
#define XmSTRING_ISO8859_1
#define XmFONTLIST_DEFAULT_TAG
#define XmFONTLIST_DEFAULT_TAG_STRING

XmS
"ISO8859-1"
XmSFONTLIST_DEFAULT_TAG_STRING
XmSXmFONTLIST_DEFAULT_TAG_STRING

#define XmVaCASCADEBUTTON
#define XmVaCHECKBUTTON
#define XmVaDOUBLE_SEPARATOR
#define XmVaPUSHBUTTON
#define XmVaRADIOBUTTON

"cascadeButton"
"checkButton"
"doubleSeparator"
"pushButton"
"radioButton"

System Data Interfaces

6-259

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 350

Figure 6-313: <Xm/XmStrDefs.h>*, Part 26 of 34

#define XmVaSEPARATOR
#define XmVaSINGLE_SEPARATOR
#define XmVaTOGGLEBUTTON
#define XmVaTITLE

"separator"
"singleSeparator"
"checkButton"
XtNtitle

#define XtCKeyboardFocusPolicy
#define XtCShellUnitType
#define XtNkeyboardFocusPolicy
#define XtNshellUnitType
#define XtRKeyboardFocusPolicy

XmCKeyboardFocusPolicy
XmCShellUnitType
XmNkeyboardFocusPolicy
XmNshellUnitType
XmRKeyboardFocusPolicy

#define XmRPrimBottomShadowPixmap
#define XmRPrimHighlightPixmap
#define XmRPrimTopShadowPixmap

XmRBottomShadowPixmap
XmRHighlightPixmap
XmRTopShadowPixmap

#define XmCAccelerators
#define XmCAllowShellResize
#define XmCArgc
#define XmCArgv
#define XmCBackground
#define XmCBaseHeight
#define XmCBaseHeight
#define XmCBaseWidth
#define XmCBaseWidth
#define XmCBitmap
#define XmCBoolean
#define XmCBorderColor
#define XmCBorderWidth
#define XmCCallback
#define XmCColor
#define XmCColormap
#define XmCCreatePopupChildProc
#define XmCCursor
#define XmCDepth
#define XmCDimension

XtCAccelerators
XtCAllowShellResize
XtCArgc
XtCArgv
XtCBackground
XtCBaseHeight
XtCBaseHeight
XtCBaseWidth
XtCBaseWidth
XtCBitmap
XtCBoolean
XtCBorderColor
XtCBorderWidth
XtCCallback
XtCColor
XtCColormap
XtCCreatePopupChildProc
XtCCursor
XtCDepth
XtRDimension

6-260

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 351

Figure 6-314: <Xm/XmStrDefs.h>*, Part 27 of 34

#define XmCEditMode
#define XmCEditType
#define XmCEventBindings
#define XmCFile
#define XmCFont
#define XmCFontSet
#define XmCForeground
#define XmCFraction
#define XmCFunction
#define XmCGeometry
#define XmCHSpace
#define XmCHeight
#define XmCHeightInc
#define XmCIconMask
#define XmCIconName
#define XmCIconNameEncoding
#define XmCIconPixmap
#define XmCIconWindow
#define XmCIconX
#define XmCIconY
#define XmCIconic
#define XmCIndex
#define XmCInitialResourcesPersistent
#define XmCInitialState
#define XmCInput
#define XmCInsertPosition
#define XmCInterval
#define XmCJustify
#define XmCLabel
#define XmCLength
#define XmCMappedWhenManaged
#define XmCMargin
#define XmCMaxAspectX
#define XmCMaxAspectY
#define XmCMaxHeight

XtREditMode
XtCEditType
XtCEventBindings
XtCFile
XtCFont
XtCFontSet
XtCForeground
XtCFraction
XtCFunction
XtCGeometry
XtCHSpace
XtCHeight
XtCHeightInc
XtCIconMask
XtCIconName
XtCIconNameEncoding
XtCIconPixmap
XtCIconWindow
XtCIconX
XtCIconY
XtCIconic
XtCIndex
XtCInitialResourcesPersistent
XtCInitialState
XtCInput
XtCInsertPosition
XtCInterval
XtCJustify
XtCLabel
XtCLength
XtCMappedWhenManaged
XtCMargin
XtCMaxAspectX
XtCMaxAspectY
XtCMaxHeight

System Data Interfaces

6-261

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 352

Figure 6-315: <Xm/XmStrDefs.h>*, Part 28 of 34

#define XmCMaxWidth
#define XmCMenuEntry
#define XmCMinAspectX
#define XmCMinAspectY
#define XmCMinHeight
#define XmCMinWidth
#define XmCNotify
#define XmCOrientation
#define XmCOverrideRedirect
#define XmCParameter
#define XmCPixmap
#define XmCPosition
#define XmCReadOnly
#define XmCResize
#define XmCReverseVideo
#define XmCSaveUnder
#define XmCScreen
#define XmCScrollDCursor
#define XmCScrollHCursor
#define XmCScrollLCursor
#define XmCScrollProc
#define XmCScrollRCursor
#define XmCScrollUCursor
#define XmCScrollVCursor
#define XmCSelection
#define XmCSelectionArray
#define XmCSensitive
#define XmCSpace
#define XmCString
#define XmCTextOptions
#define XmCTextPosition
#define XmCTextSink
#define XmCTextSource
#define XmCThickness
#define XmCThumb

XtCMaxWidth
XtCMenuEntry
XtCMinAspectX
XtCMinAspectY
XtCMinHeight
XtCMinWidth
XtCNotify
XtCOrientation
XtCOverrideRedirect
XtCParameter
XtCPixmap
XtCPosition
XtCReadOnly
XtCResize
XtCReverseVideo
XtCSaveUnder
XtCScreen
XtCScrollDCursor
XtCScrollHCursor
XtCScrollLCursor
XtCScrollProc
XtCScrollRCursor
XtCScrollUCursor
XtCScrollVCursor
XtCSelection
XtCSelectionArray
XtCSensitive
XtCSpace
XtCString
XtCTextOptions
XtCTextPosition
XtCTextSink
XtCTextSource
XtCThickness
XtCThumb

6-262

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 353

Figure 6-316: <Xm/XmStrDefs.h>*, Part 29 of 34

#define XmCTitle
#define XmCTitleEncoding
#define XmCTransient
#define XmCTransientFor
#define XmCTranslations
#define XmCVSpace
#define XmCValue
#define XmCVisual
#define XmCWaitForWm
#define XmCWidget
#define XmCWidth
#define XmCWidthInc
#define XmCWinGravity
#define XmCWindow
#define XmCWindowGroup
#define XmCWmTimeout
#define XmCX
#define XmCY
#define XmNaccelerators
#define XmNallowShellResize
#define XmNancestorSensitive
#define XmNargc
#define XmNargv
#define XmNbackground
#define XmNbackgroundPixmap
#define XmNbaseHeight
#define XmNbaseHeight
#define XmNbaseWidth
#define XmNbaseWidth
#define XmNbitmap
#define XmNborder
#define XmNborderColor
#define XmNborderPixmap
#define XmNborderWidth
#define XmNcallback

XtCTitle
XtCTitleEncoding
XtCTransient
XtCTransientFor
XtCTranslations
XtCVSpace
XtCValue
XtCVisual
XtCWaitForWm
XtRWidget
XtCWidth
XtCWidthInc
XtCWinGravity
XtCWindow
XtCWindowGroup
XtCWmTimeout
XtCX
XtCY
XtNaccelerators
XtNallowShellResize
XtNancestorSensitive
XtNargc
XtNargv
XtNbackground
XtNbackgroundPixmap
XtNbaseHeight
XtNbaseHeight
XtNbaseWidth
XtNbaseWidth
XtNbitmap
XtNborder
XtNborderColor
XtNborderPixmap
XtNborderWidth
XtNcallback

System Data Interfaces

6-263

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 354

Figure 6-317: <Xm/XmStrDefs.h>*, Part 30 of 34

#define XmNchildren
#define XmNcolormap
#define XmNcreatePopupChildProc
#define XmNdepth
#define XmNdestroyCallback
#define XmNeditType
#define XmNfile
#define XmNfont
#define XmNfontSet
#define XmNforceBars
#define XmNforeground
#define XmNfunction
#define XmNgeometry
#define XmNheight
#define XmNheightInc
#define XmNhighlight
#define XmNiconMask
#define XmNiconName
#define XmNiconNameEncoding
#define XmNiconPixmap
#define XmNiconWindow
#define XmNiconX
#define XmNiconY
#define XmNiconic
#define XmNindex
#define XmNinitialResourcesPersistent
#define XmNinitialState
#define XmNinnerHeight
#define XmNinnerWidth
#define XmNinnerWindow
#define XmNinput
#define XmNinsertPosition
#define XmNinternalHeight
#define XmNinternalWidth
#define XmNjumpProc

XtNchildren
XtNcolormap
XtNcreatePopupChildProc
XtNdepth
XtNdestroyCallback
XtNeditType
XtNfile
XtNfont
XtNfontSet
XtNforceBars
XtNforeground
XtNfunction
XtNgeometry
XtNheight
XtNheightInc
XtNhighlight
XtNiconMask
XtNiconName
XtNiconNameEncoding
XtNiconPixmap
XtNiconWindow
XtNiconX
XtNiconY
XtNiconic
XtNindex
XtNinitialResourcesPersistent
XtNinitialState
XtNinnerHeight
XtNinnerWidth
XtNinnerWindow
XtNinput
XtNinsertPosition
XtNinternalHeight
XtNinternalWidth
XtNjumpProc

6-264

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 355

Figure 6-318: <Xm/XmStrDefs.h>*, Part 31 of 34

#define XmNjustify
#define XmNlength
#define XmNlowerRight
#define XmNmappedWhenManaged
#define XmNmaxAspectX
#define XmNmaxAspectY
#define XmNmaxHeight
#define XmNmaxWidth
#define XmNmenuEntry
#define XmNminAspectX
#define XmNminAspectY
#define XmNminHeight
#define XmNminWidth
#define XmNname
#define XmNnotify
#define XmNnumChildren
#define XmNorientation
#define XmNoverrideRedirect
#define XmNparameter
#define XmNpixmap
#define XmNpopdownCallback
#define XmNpopupCallback
#define XmNresize
#define XmNreverseVideo
#define XmNsaveUnder
#define XmNscreen
#define XmNscrollDCursor
#define XmNscrollHCursor
#define XmNscrollLCursor
#define XmNscrollProc
#define XmNscrollRCursor
#define XmNscrollUCursor
#define XmNscrollVCursor
#define XmNselection
#define XmNselectionArray

XtNjustify
XtNlength
XtNlowerRight
XtNmappedWhenManaged
XtNmaxAspectX
XtNmaxAspectY
XtNmaxHeight
XtNmaxWidth
XtNmenuEntry
XtNminAspectX
XtNminAspectY
XtNminHeight
XtNminWidth
XtNname
XtNnotify
XtNnumChildren
XtNorientation
XtNoverrideRedirect
XtNparameter
XtNpixmap
XtNpopdownCallback
XtNpopupCallback
XtNresize
XtNreverseVideo
XtNsaveUnder
XtNscreen
XtNscrollDCursor
XtNscrollHCursor
XtNscrollLCursor
XtNscrollProc
XtNscrollRCursor
XtNscrollUCursor
XtNscrollVCursor
XtNselection
XtNselectionArray

System Data Interfaces

6-265

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 356

Figure 6-319: <Xm/XmStrDefs.h>*, Part 32 of 34

#define XmNsensitive
#define XmNshown
#define XmNspace
#define XmNstring
#define XmNtextOptions
#define XmNtextSink
#define XmNtextSource
#define XmNthickness
#define XmNthumb
#define XmNthumbProc
#define XmNtitle
#define XmNtitleEncoding
#define XmNtop
#define XmNtransient
#define XmNtransientFor
#define XmNtransientFor
#define XmNtranslations
#define XmNupdate
#define XmNuseBottom
#define XmNuseRight
#define XmNvalue
#define XmNvisual
#define XmNwaitForWm
#define XmNwidth
#define XmNwidthInc
#define XmNwinGravity
#define XmNwindow
#define XmNwindowGroup
#define XmNwmTimeout
#define XmNx
#define XmNy
#define XmRAcceleratorTable
#define XmRAtom
#define XmRBitmap
#define XmRBool

XtNsensitive
XtNshown
XtNspace
XtNstring
XtNtextOptions
XtNtextSink
XtNtextSource
XtNthickness
XtNthumb
XtNthumbProc
XtNtitle
XtNtitleEncoding
XtNtop
XtNtransient
XtNtransientFor
XtNtransientFor
XtNtranslations
XtNupdate
XtNuseBottom
XtNuseRight
XtNvalue
XtNvisual
XtNwaitForWm
XtNwidth
XtNwidthInc
XtNwinGravity
XtNwindow
XtNwindowGroup
XtNwmTimeout
XtNx
XtNy
XtRAcceleratorTable
XtRAtom
XtRBitmap
XtRBool

6-266

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 357

Figure 6-320: <Xm/XmStrDefs.h>*, Part 33 of 34

#define XmRBoolean
#define XmRCallProc
#define XmRCallback
#define XmRCardinal
#define XmRColor
#define XmRColormap
#define XmRCursor
#define XmRDimension
#define XmRDisplay
#define XmREditMode
#define XmREnum
#define XmRFile
#define XmRFloat
#define XmRFont
#define XmRFontSet
#define XmRFontStruct
#define XmRFunction
#define XmRGeometry
#define XmRImmediate
#define XmRInitialState
#define XmRInt
#define XmRJustify
#define XmRLongBoolean
#define XmROrientation
#define XmRObject
#define XmRPixel
#define XmRPixmap
#define XmRPointer
#define XmRPosition
#define XmRScreen
#define XmRShort
#define XmRString
#define XmRStringArray
#define XmRStringTable
#define XmRTextPosition

XtRBoolean
XtRCallProc
XtRCallback
XtRCardinal
XtRColor
XtRColormap
XtRCursor
XtRDimension
XtRDisplay
XtREditMode
XtREnum
XtRFile
XtRFloat
XtRFont
XtRFontSet
XtRFontStruct
XtRFunction
XtRGeometry
XtRImmediate
XtRInitialState
XtRInt
XtRJustify
XtRLongBoolean
XtROrientation
XtRObject
XtRPixel
XtRPixmap
XtRPointer
XtRPosition
XtRScreen
XtRShort
XtRString
XtRStringArray
XtRStringTable
XtCTextPosition

System Data Interfaces

6-267

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 358

Figure 6-321: <Xm/XmStrDefs.h>*, Part 34 of 34

#define XmRTranslationTable
#define XmRUnsignedChar
#define XmRVisual
#define XmRWidget
#define XmRWidgetClass
#define XmRWidgetList
#define XmRWindow

XtRTranslationTable
XtRUnsignedChar
XtRVisual
XtRWidget
XtRWidgetClass
XtRWidgetList
XtRWindow

6-268

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 359

TCP/IP Data Definitions
NOTE

This section is new to the Third Edition of this document, but will not be marked with
the "G" diff-mark.

This section contains standard data definitions that describe system data for the
optional TCP/IP Interfaces. These data definitions are referred to by their names
in angle brackets: <name.h> and <sys/name.h>. Included in these data definitions
are macro definitions and structure definitions. While an ABI-conforming system
may provide TCP/IP interfaces, it need not contain the actual data definitions
referenced here. Programmers should observe that the sources of the structures
defined in these data definitions are defined in SVID.

System Data Interfaces

6-269

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 360

Figure 6-322: <netinet/in.h>

#define
#define

IPPROTO_IP
IPPROTO_TCP

0
6

struct in_addr {
union {
struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;
struct { u_short s_w1,s_w2; } S_un_w;
u_long S_addr;
} S_un;
#define
s_addr
S_un.S_addr
};
#define
#define
#define

INADDR_ANY
INADDR_LOOPBACK
INADDR_BROADCAST

(u_long)0x00000000
(u_long)0x7F000001
(u_long)0xffffffff

#define
IN_SET_LOOPBACK_ADDR(a) \
{(a)->sin_addr.s_addr = htonl(INADDR_LOOPBACK); \
(a)->sin_family = AF_INET;}
struct sockaddr_in {
short
sin_family;
u_short
sin_port;
struct in_addr
sin_addr;
char
sin_zero[8];
};
#define

IP_OPTIONS

1

6-270

LIBRARIES

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 361

M

Figure 6-323: <netinet/ip.h>

#define
#define
#define
#define

IPOPT_EOL
IPOPT_NOP
IPOPT_LSRR
IPOPT_SSRR

0
1
131
137

Figure 6-324: <netinet/tcp.h>

#define

TCP_NODELAY

0x01

System Data Interfaces

6-271

DRAFT COPY
March 19, 1997
File: abi_386/chap6 (Delta 44.21)
386:adm.book:sum
Page: 362

7

DEVELOPMENT ENVIRONMENT

Development Commands
PATH Access to Development Tools

Software Packaging Tools
System Headers
Static Archives

Table of Contents

7-1
7-1

7-2
7-2
7-2

i

DRAFT COPY
March 19, 1997
File: abi_386/Cchap7 (Delta 44.3)
386:adm.book:sum
Page: 363

Development Commands

NOTE

THE FACILITIES AND INTERFACES DESCRIBED IN THIS SECTION ARE
OPTIONAL COMPONENTS OF THE System V Application Binary Interface.

NOTE

This section is new to the Third Edition of this document, but will not be marked with
the "G" diff-mark.

The Development Environment for Intel386 implementations of UnixWare 2.0
will contain all of the development commands required by the System V ABI,
namely;
________________
as
cc
ld
m4 lex yacc

M

Each command accepts all of the options required by the System V ABI, as defined
in the SD_CMD section of the System V Interface Definition, Edition 4.

PATH Access to Development Tools
The development environment for the Intel386 System V implementations is
accessible using the system default value for PATH. The default if no options are
given to the cc command is to use the libraries and object file formats that are
required for ABI compliance.

Development Commands

7-1

DRAFT COPY
March 19, 1997
File: abi_386/chap7 (Delta 44.4)
386:adm.book:sum
Page: 364

Software Packaging Tools
The development environment for i386 implementations of the System V ABI shall
include each of the following commands as defined in the AS_CMD section of System V Interface Definition, Edition 4.
pkgproto

pkgtrans

pkgmk

System Headers
Systems that do not have an ABI Development Environment may not have system
header files. If an ABI Development Environment is supported, system header
files will be included with the Development Environment. The primary source for
contents of header files is always the System V Interface Definition, Edition 4. In
those cases where SVID Fourth Edition doesn’t specify the contents of system
headers, Chapter 6 "Data Definitions" of this document shall define the associations of data elements to system headers for compilation. For greatest source portability, applications should only depend on header file contents defined in SVID.

Static Archives
Level 1 interfaces defined in System V Interface Definition, Edition 4, for each of the
following libraries, may be statically linked safely into applications. The resulting
executable will not be made non-compliant to the ABI solely because of the static
linkage of such members in the executable.
libcurses

libm

The archive libcurses.a is located in /usr/lib on conforming i386 development
environments. The archive libm.a is located in /usr/lib on conforming i386
development environments.

7-2

DEVELOPMENT ENVIRONMENT

DRAFT COPY
March 19, 1997
File: abi_386/chap7 (Delta 44.4)
386:adm.book:sum
Page: 365

M

8

EXECUTION ENVIRONMENT

Application Environment
The /dev Subtree

Table of Contents

8-1
8-1

i

DRAFT COPY
March 19, 1997
File: abi_386/Cchap8 (Delta 44.3)
386:adm.book:sum
Page: 366

Application Environment

NOTE

This section is new to the Third Edition of this document, but will not be marked with
the "G" diff-mark.

This section specifies the execution environment information available to application programs running on an i386 ABI-conforming computer.

The /dev Subtree
All networking device files described in the Generic ABI shall be supported on all
i386 ABI-conforming computers. In addition, the following device files are
required to be present on all i386 ABI-conforming computers.
/dev/null

This device file is a special ‘‘null’’ device that may be
used to test programs or provide a data sink. This file is
writable by all processes.

/dev/tty

This device file is a special one that directs all output to
the controlling TTY of the current process group. This
file is readable and writable by all processes.

/dev/sxtXX
/dev/ttyXX

These device files, where XX represents a two-digit
integer, represent device entries for terminal sessions.
All these device files must be examined by the
ttyname() call. Applications must not have the device
names of individual terminals hard-coded within them.
The sxt entries are optional in the system but, if present
must be included in the library routine’s search.

The following device files are required to be present on all i386 ABI-conforming
computers that support the corresponding hardware devices.

Application Environment

8-1

DRAFT COPY
March 19, 1997
File: abi_386/chap8 (Delta 44.5)
386:adm.book:sum
Page: 367

/dev/lpX

/dev/dsk/
/dev/rdsk/

This device file is the lineprinter device. The letter ‘‘X’’
represents a one-digit integer that identifies the particular lineprinter device.
These directories contain the raw and block disk device
files. They are of the form:
f[01][t]
f[01][35][dh][t]
c#t#d#s#
where ’c’ is followed by a controller number,
’t’ is followed by a target number,
’d’ is followed by a disk unit number,
’s’ is followed by a disk slice number.

/dev/rmt/

/dev/cdrom/
/dev/rcdrom/

These directories contain the raw and block tape device
files. The devices guaranteed to be in this directory are:
ctape1
ntape1
These directories contain the raw and block CD-ROM
disk device files. They are of the form:
c#t#l#
c#t#l#
cdrom#
The letter ’c’ is followed by a controller number. The
letter ’t’ is followed by a target number on the controller.
The letter ’l’ is followed by a logical unit number on the
target. The device "cdrom" is followed by a sequential
number as nodes are created.
No leading zeroes are used in the numbers (target four is
t4 not t04). The numbering for ’c’, ’t’ and ’l’ begins at
zero and the numbering for ’n’ begins at one.

8-2

EXECUTION ENVIRONMENT

DRAFT COPY
March 19, 1997
File: abi_386/chap8 (Delta 44.5)
386:adm.book:sum
Page: 368

IN

Index

Index

IN-1

Table of Contents

i

DRAFT COPY
March 19, 1997
File: abi_386/Cindex (Delta 44.3)
386:adm.book:sum
Page: 369

Index
A
ABI Compliance 7: 1
ABI conformance 3: 1, 3, 5, 18, 24,
28–29, 34

application 6: 4
see also undefined behavior 3: 1
see also unspecified property 3: 1
system 6: 4
ABI Development Environment 7: 2
absolute code 3: 34, 5: 3
see also position-independent code
3: 34

address
absolute 3: 46
stack 3: 29
stack object 3: 46
unaligned 3: 3
virtual 5: 1
addressing, virtual (see virtual
addressing)
aggregate 3: 3
aio.h 6: 6
alignment
array 3: 3
bit-field 3: 6
double 3: 2–3, 5, 18
executable file 5: 1
scalar types 3: 2
stack 3: 11
stack frame 3: 10, 44
structure and union 3: 3
allocation, dynamic stack space
3: 43–44

ANSI, C (see C language, ANSI)
ANSI C 3: 28
Application Environment 8: 1
architecture

implementation 3: 1
processor 3: 1
archive file 7: 2
argc 3: 26
arguments
bad assumptions 3: 44
exec(BA_OS) 3: 26
floating-point 3: 17
function 3: 9
integer 3: 17
main 3: 26
order 3: 11
pointer 3: 17
sign extension 3: 17
stack 3: 11, 17
structure and union 3: 18
variable list 3: 44
argv 3: 26
array 3: 3
ArrowBG.h 6: 193
ArrowB.h 6: 193
as 7: 1
assert.h 6: 6
Atom.h 6: 130
automatic variables 3: 43
auxiliary vector 3: 29

B
base address 3: 31, 4: 4, 5: 3
behavior, undefined (see undefined
behavior)
bit-field 3: 6
alignment 3: 6
allocation 3: 6
unnamed 3: 6
bounds check fault 3: 25

Index

IN-1

DRAFT COPY
March 19, 1997
File: abi_386/index (Delta 44.5)
386:adm.book:sum
Page: 370

branch instructions 3: 41
breakpoint trap 3: 25
BulletinB.h 6: 193

C
C language
ANSI 3: 2, 26, 44, 6: 5
calling sequence 3: 9, 44
fundamental types 3: 2
main 3: 26
portability 3: 44
switch statements 3: 41
call by value 3: 18
call instruction 3: 13, 15, 36, 39–40
calling sequence 3: 9
function epilogue 3: 13, 15–16, 37
function prologue 3: 13, 15, 37
function prologue and epilogue
3: 36

CascadeBG.h 6: 194
Cascade.h 6: 193
char 3: 2
code generation 3: 34
code sequences 3: 34
Command.h 6: 194
Composite.h 6: 131
configuration parameters (see tunable
parameters)
Constraint.h 6: 131
coprocessor error fault 3: 25
coprocessor overrun abort 3: 25
Core.h 6: 131
ctype.h 6: 7
cursorfont.h 6: 134
CutPaste.h 6: 195

D
data
process

3: 20

uninitialized 5: 2
data representation 3: 1
Development Environment 7: 1–2
DialogS.h 6: 195
dirent.h 6: 8
Display.h 6: 196
divide error fault 3: 25
dlfcn.h 6: 8
double 3: 2
double fault abort 3: 25
doubleword 3: 1, 3
DragC.h 6: 201
DragIcon.h 6: 201
DragOverS.h 6: 201
DrawingA.h 6: 202
DrawnB.h 6: 202
DropSMgr.h 6: 204
DropTrans.h 6: 205
dynamic frame size 3: 43
dynamic linking 3: 14, 17, 20, 5: 5
environment 5: 10
lazy binding 5: 10
LD_BIND_NOW 5: 10
relocation 5: 5, 9
see also dynamic linker 5: 5
dynamic segments 3: 21, 5: 3
dynamic stack allocation 3: 44
signals 3: 45

E
EFLAGS register, initial value
EIP-relative 3: 35, 41
ELF 4: 1
elf.h 6: 14
emulation, instructions 3: 1
environment 5: 10
exec(BA_OS) 3: 26
envp 3: 26
errno.h 6: 17
exceptions 3: 24

IN-2

3: 26

Index

DRAFT COPY
March 19, 1997
File: abi_386/index (Delta 44.5)
386:adm.book:sum
Page: 371

interface 3: 24
signals 3: 24
exec(BA_OS) 3: 28, 35
interpreter 3: 31
paging 5: 1
process initialization 3: 26
executable file, segments 5: 3
execution mode (see processor execution mode)
_exit(BA_OS) 3: 24
extended instruction pointer, relative
addressing (see EIP-relative)
extended-precision 3: 13

initial value 3: 29
frame size, dynamic 3: 44
Frame.h 6: 206
ftw.h 6: 23
function, void 3: 12
function arguments (see arguments)
function call, code 3: 39
function linkage (see calling
sequence)
function prologue and epilogue (see
calling sequence)

G
general protection fault/abort 3: 25
global offset table 3: 14, 17, 35, 4: 2, 4–6,

F
fcntl.h 6: 19
file, object (see object file)
file offset 5: 1
FileSB.h 6: 205
float 3: 2
float.h 6: 21
floating-point
arguments 3: 17
return value 3: 12
floating-point control register, initial
value 3: 26
floating-point status register, initial
value 3: 26
fmtmsg.h 6: 22
fnmatch.h 6: 22
formats
array 3: 3
structure 3: 3
union 3: 3
Form.h 6: 205
FORTRAN
COMMON 3: 3
EQUIVALENCE 3: 3
_fpstart 3: 28
frame pointer 3: 11, 37

5: 5

ebx 3: 36
_GLOBAL_OFFSET_TABLE_ 3: 36
relocation 3: 35
_GLOBAL_OFFSET_TABLE_ (see global
offset table)
glob.h 6: 24
grp.h 6: 25

H
halfword 3: 1
heap, dynamic stack

3: 44

I
iconv.h 6: 25
IEEE 754 3: 28
in.h 6: 270
initialization, process 3: 26
instructions, emulation 3: 1
int 3: 2
int instruction 3: 25
integer arguments 3: 17

Index

IN-3

DRAFT COPY
March 19, 1997
File: abi_386/index (Delta 44.5)
386:adm.book:sum
Page: 372

Intel386 3: 1, 9, 24, 44, 5: 1
Intel387 3: 1
interrupt 3: 12
Intrinsic.h 6: 140
invalid opcode fault 3: 25
invalid TSS fault 3: 25
ip.h 6: 271

J
jmp instruction

5: 8

L
LabelG.h 6: 206
Label.h 6: 206
langinfo.h 6: 28
lazy binding 5: 10
lcall instruction 3: 24
ld 7: 1
LD_BIND_NOW 5: 10
ld(SD_CMD) (see link editor)
lex 7: 1
libc 6: 2
libcurses 7: 2
libm 7: 2
limits.h 6: 30
link editor 4: 6, 5: 5
linkage, function (see calling
sequence)
List.h 6: 207
local variables 3: 43
locale.h 6: 31
long 3: 2
long double 3: 2
longjmp(BA_LIB) (see
setjmp(BA_LIB))
lwpsynch.h 6: 32

M
m4 7: 1
Machine Status Word register, initial
value 3: 26
machlock.h 6: 32
main
arguments 3: 26
declaration 3: 26
MainW.h 6: 207
malloc(BA_OS) 3: 22–23
math.h 6: 32
memory allocation, stack 3: 43–44
memory management 3: 20
MenuShell.h 6: 207
MessageB.h 6: 208
mmap(KE_OS) 3: 23
MrmPublic.h 6: 212
MwmUtil.h 6: 214

N
netconfig.h 6: 38
netdir.h 6: 40
nl_types.h 6: 40
no coprocessor fault 3: 25
nonmaskable interrupt 3: 25
null pointer 3: 3, 21, 26

O
object file 4: 1
ELF header 4: 1
executable 3: 35
executable file 3: 35
relocation 4: 4
section 4: 2
see also archive file 4: 1
see also dynamic linking 5: 5
see also executable file 4: 1
see also relocatable file 4: 1

IN-4

Index

DRAFT COPY
March 19, 1997
File: abi_386/index (Delta 44.5)
386:adm.book:sum
Page: 373

see also shared object file 4: 1
segment 5: 1
shared object file 3: 35
special sections 4: 2
Object.h 6: 140
offset table, global (see global offset
table)
optimization 3: 14, 17
overflow trap 3: 25

P
padding
arguments 3: 11, 18
structure and union 3: 3
page fault 3: 25
page size 3: 20, 31, 5: 1
paging 3: 20, 5: 1
performance 5: 1
PanedW.h 6: 214
parameters
function (see arguments)
system configuration (see tunable
parameters)
PATH variable 7: 1
performance, paging 5: 1
physical addressing 3: 20
pkgmk 7: 2
pkgproto 7: 2
pkgtrans 7: 2
pointer 3: 3
function argument 3: 17
null 3: 3, 26
poll.h 6: 42
portability
C program 3: 44
instructions 3: 1
position-independent code 3: 14, 17,
34, 36, 5: 3

see also absolute code 3: 34
see also global offset table 3: 35

see also procedure linkage table
3: 35

priocntl.h 6: 43
procedure linkage table

3: 35, 4: 2, 5–6,

5: 5, 7

procedures (see functions)
process
dead 3: 45
entry point 3: 26
initialization 3: 26
segment 3: 20
size 3: 20
stack 3: 28
virtual addressing 3: 20
processor architecture 3: 1
processor execution mode 3: 24, 26
processor-specific information 3: 1, 9,
20, 34, 5: 1, 5–7, 6: 2–3, 7: 1

program loading 3: 31, 5: 1
PushBG.h 6: 215
PushB.h 6: 215
pushl instruction 5: 8
pwd.h 6: 45

R
RectObj.h 6: 140
re-entrancy 3: 14
regex.h 6: 47
registers
calling sequence 3: 11
cs, ds, es, and ss 3: 29
description 3: 9, 11
eax 3: 11
ebp 3: 11
ebx 3: 11
ecx 3: 12
edi 3: 11
edx 3: 12
EFLAGS 3: 12
esi 3: 11

Index

IN-5

DRAFT COPY
March 19, 1997
File: abi_386/index (Delta 44.5)
386:adm.book:sum
Page: 374

esp 3: 11
floating-point 3: 9, 12
floating-point control word 3: 12
floating-point return value 3: 13
global 3: 9
initial values 3: 29
scratch 3: 12
variable 3: 11
registers cr0 (see Machine Status
Word register)
registers eax, integer return value
3: 12

relocation
global offset table 3: 35
see object file 4: 4
RepType.h 6: 215
resources, shared 3: 20
ret instruction 3: 13, 15
return address 3: 13
return value
floating-point 3: 12
integer 3: 12
pointer 3: 12
structure and union 3: 14
RowColumn.h 6: 216
rpc.h 6: 63
rtpriocntl.h 6: 63

S
scalar types 3: 2
Scale.h 6: 216
Screen.h 6: 216
ScrollBar.h 6: 216
ScrolledW.h 6: 217
search.h 6: 64
secondary storage 3: 20
section, object file 5: 1
segment
dynamic 3: 21
permissions 5: 2

process 3: 20–21, 5: 1, 6
segment not present fault 3: 25
segment permissions 3: 23
segment registers 3: 29
SelectioB.h 6: 217
SeparatoG.h 6: 217
Separator.h 6: 217
setjmp(BA_LIB) 3: 45
setjmp.h 6: 66
setrlimit(BA_OS) 3: 23
shared object file 3: 35
segments 3: 21, 5: 3
Shell.h 6: 141
short 3: 2
sign extension
arguments 3: 17
bit-field 3: 6
signal(BA_OS) 3: 12, 24
signal.h 6: 69
signals 3: 12, 45
signed 3: 2, 6
single step trap/fault 3: 25
sizeof 3: 2
structure 3: 3
Ssape.h 6: 141
stack
address 3: 29
dynamic allocation 3: 44
growth 3: 10
initial process 3: 28
process 3: 20–21
system management 3: 22
stack exception fault 3: 25
stack frame 3: 9–10, 13–15, 17, 37, 43
alignment 3: 10, 29, 44
organization 3: 10, 43
size 3: 11, 43
stack pointer 3: 11, 29, 37
initial value 3: 29
<stdarg.h> 3: 44
stdarg.h 6: 76
stddef.h 6: 76

IN-6

Index

DRAFT COPY
March 19, 1997
File: abi_386/index (Delta 44.5)
386:adm.book:sum
Page: 375

stdio.h 6: 79
stdlib.h 6: 79
stropts.h 6: 85
structure 3: 3
function argument 3: 18
padding 3: 3
return value 3: 14
supervisor mode (see processor execution mode)
SVID 7: 2
switch statements 3: 41
<synch> 6: 88
sysconf(BA_OS) 3: 20, 31
sys/ipc.h 6: 26
sys/mman.h 6: 33
sys/mod.h 6: 34
sys/mount.h 6: 35
sys/msg.h 6: 36
sys/param.h 6: 41
sys/procset.h 6: 44
sys/resource.h 6: 48
sys/sem.h 6: 65
sys/shm.h 6: 66
sys/siginfo.h 6: 72
sys/stat.h 6: 74
sys/statvfs.h 6: 75
sys/sysi86.h 6: 88
System Headers 7: 2
system load 3: 20
System V ABI 6: 4
sys/time.h 6: 103
sys/times.h 6: 104
sys/types.h 6: 114
sys/uio.h 6: 117
sys/utsname.h 6: 120

T
tcpip/tcp.h 6: 271
termination, process
termios.h 6: 98

3: 45

text
process 3: 20
sharing 3: 35
TextF.h 6: 218
Text.h 6: 218
<thread> 6: 100
ticlts.h 6: 100
ticots.h 6: 101
ticotsord.h 6: 101
time.h 6: 102
tiuser.h 6: 112
ToggleBG.h 6: 218
ToggleB.h 6: 218
tspriocntl.h 6: 113
tunable parameters, stack size
type mismatch 3: 15

3: 23

U
ucontext.h 6: 116
ulimit.h 6: 117
unaligned address (see address,
unaligned)
undefined behavior 3: 1, 12, 15, 28–29,
5: 2

see also ABI conformance 3: 1
see also unspecified property 3: 1
uninitialized data 5: 2
union 3: 3
function argument 3: 18
return value 3: 14
unistd.h 6: 119
unsigned 3: 2, 6
unspecified property 3: 1, 12, 14, 24,
26–27, 29, 5: 1–2

see also ABI conformance 3: 1
see also undefined behavior 3: 1
user mode (see processor execution
mode)
utime.h 6: 119

Index

IN-7

DRAFT COPY
March 19, 1997
File: abi_386/index (Delta 44.5)
386:adm.book:sum
Page: 376

V
<varargs.h> 3: 44
variable argument list 3: 17, 44
variables, automatic 3: 43
Vendor.h 6: 141
VendorS.h 6: 219
VirtKeys.h 6: 220
virtual addressing 3: 20, 35
bounds 3: 21
void functions 3: 12

W
wait.h 6: 121
wchar.h 6: 122
wctype.h 6: 125
word 3: 1, 10
wordexp.h 6: 126

X
Xcms.h 6: 158
X.h 6: 153
Xlib.h 6: 184
Xm.h 6: 234
XmStrDefs.h 6: 268
Xresource.h 6: 186
Xutil.h 6: 191

Y
yacc

7: 1

Z
zero
null pointer 3: 3
uninitialized data

5: 2

IN-8

Index

DRAFT COPY
March 19, 1997
File: abi_386/index (Delta 44.5)
386:adm.book:sum
Page: 377

