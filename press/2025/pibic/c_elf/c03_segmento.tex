\section{Segmentos ELF (Program Headers)}\label{sec:elf_segments}

Os segmentos ELF, definidos na Program Header Table, são essenciais para o carregamento e execução de arquivos ELF pelo sistema operacional. Enquanto o cabeçalho ELF, discutido na \secref{sec:elf_header}, fornece informações gerais sobre o arquivo, os segmentos descrevem como as partes do arquivo devem ser mapeadas na memória durante a execução.

\subsection{Função dos Segmentos}\label{subsec:segment_function}

Os segmentos representam uma visão do arquivo ELF orientada à execução, descrevendo como o carregador do sistema operacional deve preparar o programa para ser executado:

\begin{itemize}
    \item Eles mapeiam partes do arquivo para a memória virtual.
    \item Definem atributos como permissões de leitura, escrita e execução.
    \item Especificam o alinhamento de memória necessário.
    \item Podem incluir múltiplas seções com características similares.
\end{itemize}

Esta abstração é diretamente relacionada ao conceito de memória virtual discutido na \secref{subsec:virtual_memory}, onde o mapeamento entre arquivo e memória é fundamental para a execução eficiente de programas.

\subsection{Estrutura do Program Header}\label{subsec:program_header_structure}

Cada entrada na Program Header Table é definida pela estrutura \texttt{Elf64\_Phdr} (para ELF de 64 bits):

\begin{lstlisting}[language=C, caption={Estrutura do Program Header de 64 bits}, label={lst:elf64_phdr}]
typedef struct {
    Elf64_Word    p_type;     /* Tipo de segmento */
    Elf64_Word    p_flags;    /* Flags do segmento */
    Elf64_Off     p_offset;   /* Offset do segmento no arquivo */
    Elf64_Addr    p_vaddr;    /* Endereco virtual para carregar o segmento */
    Elf64_Addr    p_paddr;    /* Endereco fisico (relevante para sistemas embarcados) */
    Elf64_Xword   p_filesz;   /* Tamanho do segmento no arquivo */
    Elf64_Xword   p_memsz;    /* Tamanho do segmento na memoria */
    Elf64_Xword   p_align;    /* Alinhamento do segmento */
} Elf64_Phdr;
\end{lstlisting}

Esta estrutura permite ao sistema operacional determinar exatamente como cada parte do arquivo deve ser carregada na memória.

\subsection{Tipos de Segmentos (p\_type)}\label{subsec:segment_types}

O campo \texttt{p\_type} especifica o tipo do segmento. Alguns valores comuns incluem:

\begin{itemize}
    \item \texttt{PT\_NULL} (0): Entrada de segmento não utilizada
    \item \texttt{PT\_LOAD} (1): Segmento carregável
    \item \texttt{PT\_DYNAMIC} (2): Informações de ligação dinâmica
    \item \texttt{PT\_INTERP} (3): Caminho para o interpretador de programa
    \item \texttt{PT\_NOTE} (4): Informações auxiliares
    \item \texttt{PT\_PHDR} (6): Entrada para a própria tabela de cabeçalhos de programa
    \item \texttt{PT\_TLS} (7): Thread Local Storage
\end{itemize}

\begin{figure}[ht]
    \centering
    \rule{10cm}{6cm} % Placeholder para um diagrama real
    \caption{Mapeamento de segmentos ELF do arquivo para a memória}
    \label{fig:segment_mapping}
\end{figure}

A \figref{fig:segment_mapping} ilustra o processo de mapeamento de segmentos do arquivo para a memória. Este processo será explicado em mais detalhes no \chapref{chap:code} quando discutirmos o carregamento de ELF.

\subsection{Flags de Segmento (p\_flags)}\label{subsec:segment_flags}

O campo \texttt{p\_flags} define as permissões do segmento na memória:

\begin{itemize}
    \item \texttt{PF\_X} (1): Permissão de execução
    \item \texttt{PF\_W} (2): Permissão de escrita 
    \item \texttt{PF\_R} (4): Permissão de leitura
\end{itemize}

Estas flags podem ser combinadas para criar diferentes permissões. Por exemplo, um valor de 5 (= 4 + 1) representa um segmento com permissão de leitura (R) e execução (X), mas não de escrita (W). Esta configuração é típica para segmentos de código executável, como discutimos na \secref{subsec:segmentation} sobre segmentação de memória.

\subsection{Mapeamento de Arquivo para Memória}\label{subsec:file_to_memory}

Os campos \texttt{p\_offset}, \texttt{p\_vaddr}, \texttt{p\_filesz}, e \texttt{p\_memsz} definem como o segmento é mapeado do arquivo para a memória:

\begin{itemize}
    \item \texttt{p\_offset}: Posição no arquivo onde o segmento começa
    \item \texttt{p\_vaddr}: Endereço virtual onde o segmento deve ser carregado
    \item \texttt{p\_filesz}: Tamanho do segmento no arquivo
    \item \texttt{p\_memsz}: Tamanho do segmento na memória (pode ser maior que \texttt{p\_filesz})
\end{itemize}

Quando \texttt{p\_memsz} é maior que \texttt{p\_filesz}, o sistema operacional preenche a diferença com zeros. Este recurso é utilizado principalmente para o segmento BSS, que contém dados não inicializados.

\subsection{Segmentos PT\_LOAD}\label{subsec:pt_load}

Os segmentos do tipo \texttt{PT\_LOAD} são os mais fundamentais para a execução do programa, pois são os que efetivamente são carregados na memória. Tipicamente, um arquivo ELF executável contém pelo menos dois segmentos \texttt{PT\_LOAD}:

\begin{itemize}
    \item Segmento de texto: contém código executável e dados somente leitura (flags: R-X)
    \item Segmento de dados: contém dados inicializados e espaço para dados não inicializados (flags: RW-)
\end{itemize}

Esta separação é uma implementação direta do princípio de segmentação discutido anteriormente na \secref{subsec:segmentation}.

\begin{table}[ht]
    \centering
    \caption{Segmentos típicos em um arquivo ELF executável}
    \label{tab:typical_segments}
    \begin{tabular}{|l|c|c|c|l|}
        \hline
        \textbf{Tipo} & \textbf{Flags} & \textbf{Conteúdo} & \textbf{Seções Incluídas} & \textbf{Propósito} \\
        \hline
        PT\_LOAD & R-X & Código & .text, .rodata & Código executável e constantes \\
        PT\_LOAD & RW- & Dados & .data, .bss & Variáveis globais \\
        PT\_DYNAMIC & RW- & Informações dinâmicas & .dynamic & Ligação dinâmica \\
        PT\_INTERP & R-- & Caminho do interpretador & .interp & Nome do carregador dinâmico \\
        \hline
    \end{tabular}
\end{table}

\subsection{Segmento PT\_INTERP}\label{subsec:pt_interp}

O segmento \texttt{PT\_INTERP} é especialmente importante para programas com ligação dinâmica, pois especifica o caminho para o interpretador de programa (geralmente o carregador dinâmico, como \texttt{/lib64/ld-linux-x86-64.so.2}). Este segmento contém uma string terminada em nulo que aponta para o arquivo do interpretador.

Quando o sistema operacional encontra este segmento, ele carrega o interpretador especificado, que então assume o controle para carregar as bibliotecas compartilhadas e resolver símbolos dinâmicos.

\subsection{Segmento PT\_DYNAMIC}\label{subsec:pt_dynamic}

O segmento \texttt{PT\_DYNAMIC} contém informações cruciais para a ligação dinâmica, incluindo:

\begin{itemize}
    \item Referências a tabelas de símbolos dinâmicos
    \item Listas de bibliotecas compartilhadas necessárias
    \item Informações de relocação
    \item Endereços de inicialização e finalização
\end{itemize}

Este segmento é essencial para o funcionamento do carregador dinâmico discutido na \secref{subsec:pt_interp}.

\subsection{Alinhamento de Segmentos (p\_align)}\label{subsec:segment_alignment}

O campo \texttt{p\_align} especifica o alinhamento necessário para o segmento em memória. Para segmentos carregáveis:

\begin{itemize}
    \item \texttt{p\_vaddr} $\equiv$ \texttt{p\_offset} (mod \texttt{p\_align})
    \item \texttt{p\_align} é geralmente uma potência de 2
    \item Valores típicos são 0x1000 (4KB, tamanho de página padrão)
\end{itemize}

Este alinhamento é crucial para o desempenho e compatibilidade, conforme discutido na \secref{subsec:alignment}.

\subsection{Análise de Segmentos com Ferramentas}\label{subsec:segment_analysis}

Podemos analisar os segmentos de um arquivo ELF usando ferramentas como \texttt{readelf}:

\begin{lstlisting}[language=bash, caption={Exemplo de uso do readelf para analisar segmentos}, label={lst:readelf_segments}]
$ readelf -l /bin/ls

Elf file type is DYN (Shared object file)
Entry point 0x6050
There are 13 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                 0x00000000000002d8 0x00000000000002d8  R      0x8
  INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000004d08 0x0000000000004d08  R      0x1000
  LOAD           0x0000000000005000 0x0000000000005000 0x0000000000005000
                 0x0000000000013798 0x0000000000013798  R E    0x1000
  LOAD           0x0000000000019000 0x0000000000019000 0x0000000000019000
                 0x00000000000053e0 0x00000000000053e0  R      0x1000
  LOAD           0x000000000001f000 0x000000000001f000 0x000000000001f000
                 0x0000000000001088 0x0000000000002800  RW     0x1000
\end{lstlisting}

No \chapref{chap:code}, exploraremos como nossa própria ferramenta de análise pode processar e interpretar estas informações.

\subsection{Relação entre Segmentos e Seções}\label{subsec:segments_and_sections}

Como será explicado em maior detalhe na próxima seção (\secref{sec:elf_sections}), existe uma relação importante entre segmentos e seções:

\begin{itemize}
    \item Seções são unidades lógicas de código ou dados com propósitos específicos.
    \item Segmentos são unidades de carregamento que podem incluir múltiplas seções.
    \item A visão por seções é mais relevante para ferramentas como compiladores e linkers.
    \item A visão por segmentos é mais relevante para o carregamento e execução pelo sistema operacional.
\end{itemize}

Esta dualidade de perspectivas reflete a natureza dupla do formato ELF como formato tanto para vinculação (linking) quanto para execução.

\subsection{Considerações para Diferentes Arquiteturas}\label{subsec:arch_considerations}

Embora a estrutura básica dos segmentos ELF seja padronizada, diferentes arquiteturas podem ter requisitos específicos:

\begin{itemize}
    \item Arquiteturas Harvard puras podem necessitar de segmentos distintos para código e dados.
    \item Algumas arquiteturas têm requisitos especiais de alinhamento.
    \item Sistemas embarcados podem usar o campo \texttt{p\_paddr} (endereço físico) que normalmente é ignorado em sistemas com memória virtual.
\end{itemize}

Estas considerações serão exploradas mais a fundo na \secref{sec:architecture}, onde discutiremos como o formato ELF se adapta a diferentes arquiteturas de processador.