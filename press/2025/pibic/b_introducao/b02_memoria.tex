\section{Conceitos de Memória e Armazenamento}\label{sec:memory_concepts}

Em um sistema computacional, a memória é um componente crítico que afeta diretamente o desempenho e as capacidades do sistema. Compreender seus diferentes tipos e hierarquias é fundamental para entender como os programas em formato ELF são carregados e executados.

\subsection{Hierarquia de Memória}\label{subsec:memory_hierarchy}

Os sistemas computacionais modernos implementam uma hierarquia de memória para equilibrar velocidade, capacidade e custo:

\begin{itemize}
    \item \textbf{Registradores}: Extremamente rápidos, localizados no processador, com capacidade muito limitada.
    \item \textbf{Cache}: Memória intermediária de alta velocidade que armazena cópias de dados frequentemente acessados.
        \begin{itemize}
            \item \textbf{Cache L1}: Menor e mais rápido, geralmente dividido em cache de instruções e cache de dados.
            \item \textbf{Cache L2}: Maior e um pouco mais lento que o L1, geralmente unificado.
            \item \textbf{Cache L3}: Presente em processadores mais modernos, compartilhado entre núcleos.
        \end{itemize}
    \item \textbf{Memória Principal (RAM)}: Armazena programas e dados ativamente em uso, com acesso mais lento que caches.
    \item \textbf{Armazenamento Secundário}: Dispositivos não voláteis como SSDs e HDDs, com grande capacidade mas acesso significativamente mais lento.
\end{itemize}

\begin{figure}[ht]
    \centering
    \rule{8cm}{6cm} % Placeholder for an actual figure
    \caption{Hierarquia de memória em sistemas computacionais modernos}
    \label{fig:memory_hierarchy}
\end{figure}

Como mostrado na \figref{fig:memory_hierarchy}, esta hierarquia é essencial para o desempenho do sistema. Os conceitos apresentados na \secref{sec:comp_concepts} combinados com esta hierarquia de memória influenciam diretamente o desenho do formato ELF.

\subsection{Memória Virtual}\label{subsec:virtual_memory}

\subsubsection{Conceito e Função}\label{subsubsec:vm_concept}

A memória virtual é uma abstração que separa o espaço de endereçamento lógico (visto pelos processos) do espaço de endereçamento físico (hardware real). Suas principais funções incluem:

\begin{itemize}
    \item Permitir que programas operem como se tivessem mais memória disponível que a RAM física.
    \item Proteger processos, impedindo que acessem áreas de memória de outros processos.
    \item Facilitar o compartilhamento de memória e bibliotecas entre processos diferentes.
\end{itemize}

\subsubsection{Paginação}\label{subsubsec:paging}

A memória virtual geralmente é implementada usando paginação:

\begin{itemize}
    \item O espaço de endereçamento é dividido em unidades de tamanho fixo chamadas páginas.
    \item O mapeamento entre páginas virtuais e quadros físicos é mantido em tabelas de páginas.
    \item Páginas não utilizadas podem ser temporariamente transferidas para armazenamento secundário (swap).
    \item O hardware MMU (Memory Management Unit) traduz endereços virtuais em físicos durante a execução.
\end{itemize}

\begin{table}[ht]
    \centering
    \caption{Comparação entre sistemas com e sem memória virtual}
    \label{tab:vm_comparison}
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Característica} & \textbf{Com Memória Virtual} & \textbf{Sem Memória Virtual} \\
        \hline
        Limitação de memória & Endereçamento virtual & RAM física disponível \\
        Proteção de memória & Sim, por processo & Limitada ou inexistente \\
        Compartilhamento & Eficiente via mapeamento & Complicado \\
        Fragmentação & Gerenciada via paginação & Problemática \\
        \hline
    \end{tabular}
\end{table}

Veremos em \secref{sec:elf_segments} como o formato ELF é projetado para funcionar eficientemente com sistemas de memória virtual, especificando como segmentos devem ser carregados na memória.

\subsection{Segmentação de Memória}\label{subsec:segmentation}

A segmentação é um esquema de gerenciamento de memória que divide o espaço de endereçamento em segmentos lógicos:

\begin{itemize}
    \item \textbf{Segmento de Código}: Contém as instruções executáveis do programa (somente leitura).
    \item \textbf{Segmento de Dados}: Armazena variáveis globais e estáticas inicializadas.
    \item \textbf{Segmento BSS (Block Started by Symbol)}: Contém variáveis globais e estáticas não inicializadas.
    \item \textbf{Heap}: Área para alocação dinâmica de memória durante a execução.
    \item \textbf{Stack}: Armazena variáveis locais, parâmetros de função e informações de controle.
\end{itemize}

Este conceito de segmentação é particularmente relevante para o formato ELF, que organiza seções de código e dados em segmentos para carregamento eficiente. Esta organização será explorada em detalhes no \chapref{chap:elf}.

\subsection{Alinhamento de Memória}\label{subsec:alignment}

O alinhamento de memória refere-se à forma como os dados são organizados em endereços que são múltiplos de seu tamanho:

\begin{itemize}
    \item Instrução ou dado de 4 bytes geralmente é alinhado em endereços múltiplos de 4.
    \item Dados de 8 bytes geralmente são alinhados em endereços múltiplos de 8.
\end{itemize}

O alinhamento adequado é crucial para:
\begin{itemize}
    \item Melhorar a eficiência de acesso à memória.
    \item Garantir compatibilidade com arquiteturas que exigem alinhamento.
    \item Otimizar o desempenho do sistema.
\end{itemize}

No formato ELF, o alinhamento é especificado para diferentes seções e segmentos, garantindo que quando carregados na memória, eles mantenham o alinhamento necessário para execução eficiente. Como será detalhado na \secref{sec:elf_sections}, esta é uma propriedade fundamental do formato.

\subsection{Endianess}\label{subsec:endianness}

Endianess refere-se à ordem em que bytes de dados multi-byte são armazenados na memória:

\begin{itemize}
    \item \textbf{Little-endian}: O byte menos significativo é armazenado no endereço mais baixo.
    \item \textbf{Big-endian}: O byte mais significativo é armazenado no endereço mais baixo.
\end{itemize}

Arquiteturas diferentes usam convenções diferentes (Intel x86 usa little-endian, enquanto algumas versões do PowerPC usam big-endian). O formato ELF inclui informações sobre endianess no seu cabeçalho, permitindo que sistemas interpretem corretamente os dados binários independentemente da arquitetura, como será discutido na \secref{sec:elf_header} no próximo capítulo.