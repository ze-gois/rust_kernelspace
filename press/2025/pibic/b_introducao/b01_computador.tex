\section{Conceitos Fundamentais de Arquitetura de Computadores}\label{sec:comp_concepts}

A compreensão do formato ELF (Executable and Linkable Format) depende fundamentalmente do entendimento da arquitetura de computadores e de como os programas são representados e executados em um sistema computacional. Esta seção apresenta os conceitos básicos necessários para esse entendimento.

\subsection{Arquitetura de von Neumann}\label{subsec:von_neumann}

A maioria dos computadores modernos é baseada na arquitetura de von Neumann, proposta por John von Neumann em 1945. Essa arquitetura define um computador com:

\begin{itemize}
    \item \textbf{Unidade Central de Processamento (CPU)}: responsável por buscar instruções da memória, decodificá-las e executá-las.
    \item \textbf{Unidade de Memória}: armazena tanto dados quanto instruções.
    \item \textbf{Dispositivos de Entrada e Saída}: permitem a comunicação do computador com o mundo externo.
    \item \textbf{Barramento}: conecta os componentes, permitindo o fluxo de dados entre eles.
\end{itemize}

\begin{figure}[ht]
    \centering
    \rule{8cm}{5cm} % Placeholder for an actual figure
    \caption{Diagrama simplificado da arquitetura de von Neumann}
    \label{fig:von_neumann}
\end{figure}

Como podemos observar na \figref{fig:von_neumann}, a arquitetura de von Neumann estabelece uma conexão direta entre a CPU e a memória, formando a base para o funcionamento dos computadores modernos. Esta arquitetura será importante para entendermos como os programas no formato ELF são carregados e executados, como veremos em \chapref{chap:elf}.

\subsection{Representação Binária}\label{subsec:binary}

Na essência de qualquer computador digital está a representação binária de informações. Todos os dados e instruções são codificados como sequências de bits (0s e 1s). Um byte, composto de 8 bits, é a unidade básica de armazenamento na maioria dos computadores modernos.

Múltiplas representações podem ser derivadas dessa codificação binária:
\begin{itemize}
    \item \textbf{Valores inteiros}: representados diretamente em binário ou usando complemento de dois para números negativos.
    \item \textbf{Caracteres}: codificados usando padrões como ASCII ou UTF-8.
    \item \textbf{Instruções de máquina}: sequências específicas de bits que a CPU interpreta como comandos.
\end{itemize}

\begin{table}[ht]
    \centering
    \caption{Exemplos de representação binária para diferentes tipos de dados}
    \label{tab:binary_examples}
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Tipo de Dado} & \textbf{Valor} & \textbf{Representação Binária} \\
        \hline
        Inteiro positivo & 42 & 00101010 \\
        Inteiro negativo & -42 & 11010110 (complemento de dois) \\
        Caractere ASCII & 'A' & 01000001 \\
        Instrução x86 & ADD AL, BL & 00000000 \\
        \hline
    \end{tabular}
\end{table}

A \tabref{tab:binary_examples} ilustra como diferentes tipos de dados são representados em formato binário. Esta compreensão da representação binária é fundamental para a análise de arquivos ELF, que será discutida em detalhes na \secref{sec:elf_header} do \chapref{chap:elf}.

\subsection{Conjunto de Instruções (ISA)}\label{subsec:isa}

O ISA (Instruction Set Architecture) define as instruções que o processador pode executar, incluindo operações aritméticas, lógicas, de transferência de dados e de controle de fluxo. O ISA representa a interface entre software e hardware, determinando como os programas são escritos e compilados para serem executados na máquina.

Existem dois paradigmas principais de ISA:
\begin{itemize}
    \item \textbf{CISC (Complex Instruction Set Computer)}: oferece instruções complexas e poderosas, como o x86.
    \item \textbf{RISC (Reduced Instruction Set Computer)}: utiliza instruções mais simples e uniformes, como ARM e RISC-V.
\end{itemize}

Como veremos na \secref{sec:x86_64}, a arquitetura x86-64 é particularmente relevante para nossa discussão sobre o formato ELF em sistemas Linux modernos.

\subsection{Ciclo de Execução de Instruções}\label{subsec:exec_cycle}

O ciclo básico de execução em um processador consiste em:
\begin{enumerate}
    \item \textbf{Fetch}: buscar a próxima instrução da memória
    \item \textbf{Decode}: identificar a operação a ser realizada
    \item \textbf{Execute}: realizar a operação
    \item \textbf{Write-back}: armazenar os resultados, se necessário
\end{enumerate}

Este ciclo, conhecido como ciclo de busca-execução, é fundamental para entender como programas são executados e, consequentemente, como o formato ELF é estruturado para permitir essa execução. A relação entre este ciclo e a organização de memória discutida na \secref{sec:memory_concepts} será essencial para compreender como o sistema operacional carrega binários ELF.

\subsection{Registradores e Memória}\label{subsec:registers}

Processadores possuem registradores, pequenas unidades de memória de acesso rápido dentro da CPU:

\begin{itemize}
    \item \textbf{Registradores de Uso Geral}: armazenam dados temporários durante processamento
    \item \textbf{Registrador de Instrução}: mantém a instrução atual sendo executada
    \item \textbf{Contador de Programa (PC)}: aponta para a próxima instrução a ser executada
    \item \textbf{Ponteiro de Pilha (SP)}: gerencia a pilha de execução
\end{itemize}

Compreender a relação entre registradores e memória é essencial para entender como os programas compilados no formato ELF são carregados e executados pelo sistema operacional. Esta relação será explorada em maior detalhe no \chapref{chap:code} quando discutirmos a análise de código assembly em arquivos ELF.